{
  "classes": [
    {
      "name": "Accordion",
      "extends": null,
      "file": "module\\applications\\accordion.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActivityChoiceDialog",
      "extends": "Application5e",
      "file": "module\\applications\\activity\\activity-choice-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActivitySheet",
      "extends": "PseudoDocumentSheet",
      "file": "module\\applications\\activity\\activity-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActivityUsageDialog",
      "extends": "Dialog5e",
      "file": "module\\applications\\activity\\activity-usage-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "AttackSheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\attack-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "CastSheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\cast-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "CheckSheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\check-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "DamageSheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\damage-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "EnchantSheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\enchant-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "EnchantUsageDialog",
      "extends": "ActivityUsageDialog",
      "file": "module\\applications\\activity\\enchant-usage-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "ForwardSheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\forward-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "HealSheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\heal-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "OrderUsageDialog",
      "extends": "ActivityUsageDialog",
      "file": "module\\applications\\activity\\order-usage-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "SaveSheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\save-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "SummonSheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\summon-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "SummonUsageDialog",
      "extends": "ActivityUsageDialog",
      "file": "module\\applications\\activity\\summon-usage-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "UtilitySheet",
      "extends": "ActivitySheet",
      "file": "module\\applications\\activity\\utility-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "BaseConfigSheet",
      "extends": "DocumentSheet5e",
      "file": "module\\applications\\actor\\api\\base-config-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "BaseConfigSheet",
      "extends": "DocumentSheet",
      "file": "module\\applications\\actor\\base-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorSheet5eCharacter",
      "extends": "ActorSheet5e",
      "file": "module\\applications\\actor\\character-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "AbilityConfig",
      "extends": "BaseProficiencyConfig",
      "file": "module\\applications\\actor\\config\\ability-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ArmorClassConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\armor-class-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "BaseProficiencyConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\base-proficiency-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ConcentrationConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\concentration-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "DamagesConfig",
      "extends": "TraitsConfig",
      "file": "module\\applications\\actor\\config\\damages-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "DeathConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\death-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "HabitatConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\habitat-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "HitDiceConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\hit-dice-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "HitPointsConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\hit-points-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "InitiativeConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\initiative-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "LanguagesConfig",
      "extends": "TraitsConfig",
      "file": "module\\applications\\actor\\config\\languages-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "SkillToolConfig",
      "extends": "BaseProficiencyConfig",
      "file": "module\\applications\\actor\\config\\skill-tool-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "SkillsConfig",
      "extends": "TraitsConfig",
      "file": "module\\applications\\actor\\config\\skills-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "SpellSlotsConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\spell-slots-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ToolsConfig",
      "extends": "TraitsConfig",
      "file": "module\\applications\\actor\\config\\tools-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "TraitsConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\traits-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "TreasureConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\config\\treasure-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "WeaponsConfig",
      "extends": "TraitsConfig",
      "file": "module\\applications\\actor\\config\\weapons-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorAbilityConfig",
      "extends": "AbilityConfig",
      "file": "module\\applications\\actor\\deprecated\\ability-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorArmorConfig",
      "extends": "ArmorClassConfig",
      "file": "module\\applications\\actor\\deprecated\\armor-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorConcentrationConfig",
      "extends": "ConcentrationConfig",
      "file": "module\\applications\\actor\\deprecated\\concentration-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "DamageModificationConfig",
      "extends": "DamagesConfig",
      "file": "module\\applications\\actor\\deprecated\\damage-modification-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorHitDiceConfig",
      "extends": "HitDiceConfig",
      "file": "module\\applications\\actor\\deprecated\\hit-dice-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorHitPointsConfig",
      "extends": "HitPointsConfig",
      "file": "module\\applications\\actor\\deprecated\\hit-points-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorInitiativeConfig",
      "extends": "InitiativeConfig",
      "file": "module\\applications\\actor\\deprecated\\initiative-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorMovementConfig",
      "extends": "MovementSensesConfig",
      "file": "module\\applications\\actor\\deprecated\\movement-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ProficiencyConfig",
      "extends": "SkillToolConfig",
      "file": "module\\applications\\actor\\deprecated\\proficiency-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorSensesConfig",
      "extends": "MovementSensesConfig",
      "file": "module\\applications\\actor\\deprecated\\senses-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorSkillsConfig",
      "extends": "SkillsConfig",
      "file": "module\\applications\\actor\\deprecated\\skills-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorSpellSlotsConfig",
      "extends": "SpellSlotsConfig",
      "file": "module\\applications\\actor\\deprecated\\spell-slots-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ToolSelector",
      "extends": "ToolsConfig",
      "file": "module\\applications\\actor\\deprecated\\tool-selector.mjs",
      "jsDoc": ""
    },
    {
      "name": "TraitSelector",
      "extends": "TraitsConfig",
      "file": "module\\applications\\actor\\deprecated\\trait-selector.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorTypeConfig",
      "extends": "CreatureTypeConfig",
      "file": "module\\applications\\actor\\deprecated\\type-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorSheet5eNPC",
      "extends": "ActorSheet5e",
      "file": "module\\applications\\actor\\npc-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "BaseRestDialog",
      "extends": "Dialog5e",
      "file": "module\\applications\\actor\\rest\\base-rest-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "LongRestDialog",
      "extends": "BaseRestDialog",
      "file": "module\\applications\\actor\\rest\\long-rest-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "ShortRestDialog",
      "extends": "BaseRestDialog",
      "file": "module\\applications\\actor\\rest\\short-rest-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorSheetFlags",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\actor\\sheet-flags.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorSheet5eVehicle",
      "extends": "ActorSheet5e",
      "file": "module\\applications\\actor\\vehicle-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "AbilityScoreImprovementConfig",
      "extends": "AdvancementConfig",
      "file": "module\\applications\\advancement\\ability-score-improvement-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "AbilityScoreImprovementFlow",
      "extends": "AdvancementFlow",
      "file": "module\\applications\\advancement\\ability-score-improvement-flow.mjs",
      "jsDoc": ""
    },
    {
      "name": "AdvancementConfig",
      "extends": "PseudoDocumentSheet",
      "file": "module\\applications\\advancement\\advancement-config-v2.mjs",
      "jsDoc": ""
    },
    {
      "name": "AdvancementConfig",
      "extends": "FormApplication",
      "file": "module\\applications\\advancement\\advancement-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "AdvancementConfirmationDialog",
      "extends": "Dialog",
      "file": "module\\applications\\advancement\\advancement-confirmation-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "AdvancementFlow",
      "extends": "FormApplication",
      "file": "module\\applications\\advancement\\advancement-flow.mjs",
      "jsDoc": ""
    },
    {
      "name": "AdvancementManager",
      "extends": "Application5e",
      "file": "module\\applications\\advancement\\advancement-manager.mjs",
      "jsDoc": ""
    },
    {
      "name": "AdvancementVisualizer",
      "extends": "Application5e",
      "file": "module\\applications\\advancement\\advancement-manager.mjs",
      "jsDoc": "Internal type used to manage each step within the advancement process.\n@typedef {object} AdvancementStep\n@property {string} type                Step type from \"forward\", \"reverse\", \"restore\", or \"delete\".\n@property {AdvancementFlow} [flow]     Flow object for the advancement being applied by this step. In the case of\n                                       \"delete\" steps, this flow indicates the advancement flow that originally\n                                       deleted the item.\n@property {Item5e} [item]              For \"delete\" steps only, the item to be removed.\n@property {object} [class]             Contains data on class if step was triggered by class level change.\n@property {Item5e} [class.item]        Class item that caused this advancement step.\n@property {number} [class.level]       Level the class should be during this step.\n@property {boolean} [automatic=false]  Should the manager attempt to apply this step without user interaction?\n@property {boolean} [synthetic=false]  Was this step created as a result of an item introduced or deleted?\n/\n\n/**\n@typedef AdvancementManagerConfiguration\n@property {boolean} [automaticApplication=false]  Apply advancement steps automatically if no user input is required.\n@property {boolean} [showVisualizer=false]        Display the step debugging application.\n/\n\n/**\nApplication for controlling the advancement workflow and displaying the interface.\n@param {Actor5e} actor        Actor on which this advancement is being performed.\n@param {object} [options={}]  Additional application options.\n/\nexport default class AdvancementManager extends Application5e {\n  constructor(actor, options={}) {\n    super(options);\n    this.actor = actor;\n    this.clone = actor.clone();\n    if ( this.options.showVisualizer ) this.#visualizer = new AdvancementVisualizer({ manager: this });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"advancement\", \"manager\"],\n    window: {\n      icon: \"fa-solid fa-forward\",\n      title: \"DND5E.ADVANCEMENT.Manager.Title.Default\"\n    },\n    actions: {\n      complete: AdvancementManager.#process,\n      next: AdvancementManager.#process,\n      previous: AdvancementManager.#process,\n      restart: AdvancementManager.#process\n    },\n    position: {\n      width: 460\n    },\n    automaticApplication: false,\n    showVisualizer: false\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    manager: {\n      template: \"systems/dnd5e/templates/advancement/advancement-manager.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nThe original actor to which changes will be applied when the process is complete.\n@type {Actor5e}\n/\n  actor;\n\n  /* -------------------------------------------- */\n\n  /**\nIs the prompt currently advancing through un-rendered steps?\n@type {boolean}\n/\n  #advancing = false;\n\n  /* -------------------------------------------- */\n\n  /**\nA clone of the original actor to which the changes can be applied during the advancement process.\n@type {Actor5e}\n/\n  clone;\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get subtitle() {\n    const parts = [];\n\n    // Item Name\n    const item = this.step.flow.item;\n    parts.push(item.name);\n\n    // Class/Subclass level\n    let level = this.step.flow.level;\n    if ( this.step.class && [\"class\", \"subclass\"].includes(item.type) ) level = this.step.class.level;\n    if ( level ) parts.push(game.i18n.format(\"DND5E.AdvancementLevelHeader\", { level }));\n\n    // Step Count\n    const visibleSteps = this.steps.filter(s => !s.automatic);\n    const visibleIndex = visibleSteps.indexOf(this.step);\n    if ( visibleIndex >= 0 ) parts.push(game.i18n.format(\"DND5E.ADVANCEMENT.Manager.Steps\", {\n      current: visibleIndex + 1,\n      total: visibleSteps.length\n    }));\n\n    return parts.join(\" â€¢ \");\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get id() {\n    return `actor-${this.actor.id}-advancement`;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nGet the step that is currently in progress.\n@type {object|null}\n/\n  get step() {\n    return this.steps[this.#stepIndex] ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStep being currently displayed.\n@type {number|null}\n/\n  #stepIndex = null;\n\n  /* -------------------------------------------- */\n\n  /**\nIndividual steps that will be applied in order.\n@type {AdvancementStep[]}\n/\n  steps = [];\n\n  /* -------------------------------------------- */\n\n  /**\nGet the step before the current one.\n@type {object|null}\n/\n  get previousStep() {\n    return this.steps[this.#stepIndex - 1] ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nGet the step after the current one.\n@type {object|null}\n/\n  get nextStep() {\n    const nextIndex = this.#stepIndex === null ? 0 : this.#stepIndex + 1;\n    return this.steps[nextIndex] ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nSide application for debugging advancement steps.\n@type {AdvancementVisualizer}\n/\n  #visualizer;\n\n  /* -------------------------------------------- */\n  /*  Factory Methods                             */\n  /* -------------------------------------------- */\n\n  /**\nConstruct a manager for a newly added advancement from drag-drop.\n@param {Actor5e} actor               Actor from which the advancement should be updated.\n@param {string} itemId               ID of the item to which the advancements are being dropped.\n@param {Advancement[]} advancements  Dropped advancements to add.\n@param {object} [options={}]         Rendering options passed to the application.\n@returns {AdvancementManager}  Prepared manager. Steps count can be used to determine if advancements are needed.\n/\n  static forNewAdvancement(actor, itemId, advancements, options={}) {\n    const manager = new this(actor, options);\n    const clonedItem = manager.clone.items.get(itemId);\n    if ( !clonedItem || !advancements.length ) return manager;\n\n    const currentLevel = this.currentLevel(clonedItem, manager.clone);\n    const minimumLevel = advancements.reduce((min, a) => Math.min(a.levels[0] ?? Infinity, min), Infinity);\n    if ( minimumLevel > currentLevel ) return manager;\n\n    const oldFlows = Array.fromRange(currentLevel + 1).slice(minimumLevel)\n      .flatMap(l => this.flowsForLevel(clonedItem, l));\n\n    // Revert advancements through minimum level\n    oldFlows.reverse().forEach(flow => manager.steps.push({ type: \"reverse\", flow, automatic: true }));\n\n    // Add new advancements\n    const advancementArray = clonedItem.toObject().system.advancement;\n    advancementArray.push(...advancements.map(a => {\n      const obj = a.toObject();\n      if ( obj.constructor.dataModels?.value ) a.value = (new a.constructor.metadata.dataModels.value()).toObject();\n      else obj.value = foundry.utils.deepClone(a.constructor.metadata.defaults?.value ?? {});\n      return obj;\n    }));\n    clonedItem.updateSource({\"system.advancement\": advancementArray});\n\n    const newFlows = Array.fromRange(currentLevel + 1).slice(minimumLevel)\n      .flatMap(l => this.flowsForLevel(clonedItem, l));\n\n    // Restore existing advancements and apply new advancements\n    newFlows.forEach(flow => {\n      const matchingFlow = oldFlows.find(f => (f.advancement.id === flow.advancement.id) && (f.level === flow.level));\n      if ( matchingFlow ) manager.steps.push({ type: \"restore\", flow: matchingFlow, automatic: true });\n      else manager.steps.push({ type: \"forward\", flow });\n    });\n\n    return manager;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct a manager for a newly added item.\n@param {Actor5e} actor         Actor to which the item is being added.\n@param {object} itemData       Data for the item being added.\n@param {object} [options={}]   Rendering options passed to the application.\n@returns {AdvancementManager}  Prepared manager. Steps count can be used to determine if advancements are needed.\n/\n  static forNewItem(actor, itemData, options={}) {\n    const manager = new this(actor, options);\n\n    // Prepare data for adding to clone\n    const dataClone = foundry.utils.deepClone(itemData);\n    dataClone._id = foundry.utils.randomID();\n    if ( itemData.type === \"class\" ) {\n      dataClone.system.levels = 0;\n      if ( !manager.clone.system.details.originalClass ) {\n        manager.clone.updateSource({\"system.details.originalClass\": dataClone._id});\n      }\n    }\n\n    // Add item to clone & get new instance from clone\n    manager.clone.updateSource({items: [dataClone]});\n    const clonedItem = manager.clone.items.get(dataClone._id);\n\n    // For class items, prepare level change data\n    if ( itemData.type === \"class\" ) {\n      return manager.createLevelChangeSteps(clonedItem, itemData.system?.levels ?? 1);\n    }\n\n    // All other items, just create some flows up to current character level (or class level for subclasses)\n    let targetLevel = manager.clone.system.details.level ?? 0;\n    if ( clonedItem.type === \"subclass\" ) targetLevel = clonedItem.class?.system.levels ?? 0;\n    Array.fromRange(targetLevel + 1)\n      .flatMap(l => this.flowsForLevel(clonedItem, l))\n      .forEach(flow => manager.steps.push({ type: \"forward\", flow }));\n\n    return manager;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct a manager for modifying choices on an item at a specific level.\n@param {Actor5e} actor         Actor from which the choices should be modified.\n@param {object} itemId         ID of the item whose choices are to be changed.\n@param {number} level          Level at which the choices are being changed.\n@param {object} [options={}]   Rendering options passed to the application.\n@returns {AdvancementManager}  Prepared manager. Steps count can be used to determine if advancements are needed.\n/\n  static forModifyChoices(actor, itemId, level, options={}) {\n    const manager = new this(actor, options);\n    const clonedItem = manager.clone.items.get(itemId);\n    if ( !clonedItem ) return manager;\n\n    const flows = Array.fromRange(this.currentLevel(clonedItem, manager.clone) + 1).slice(level)\n      .flatMap(l => this.flowsForLevel(clonedItem, l));\n\n    // Revert advancements through changed level\n    flows.reverse().forEach(flow => manager.steps.push({ type: \"reverse\", flow, automatic: true }));\n\n    // Create forward advancements for level being changed\n    flows.reverse().filter(f => f.level === level).forEach(flow => manager.steps.push({ type: \"forward\", flow }));\n\n    // Create restore advancements for other levels\n    flows.filter(f => f.level > level).forEach(flow => manager.steps.push({ type: \"restore\", flow, automatic: true }));\n\n    return manager;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct a manager for an advancement that needs to be deleted.\n@param {Actor5e} actor         Actor from which the advancement should be unapplied.\n@param {string} itemId         ID of the item from which the advancement should be deleted.\n@param {string} advancementId  ID of the advancement to delete.\n@param {object} [options={}]   Rendering options passed to the application.\n@returns {AdvancementManager}  Prepared manager. Steps count can be used to determine if advancements are needed.\n/\n  static forDeletedAdvancement(actor, itemId, advancementId, options={}) {\n    const manager = new this(actor, options);\n    const clonedItem = manager.clone.items.get(itemId);\n    const advancement = clonedItem?.advancement.byId[advancementId];\n    if ( !advancement ) return manager;\n\n    const minimumLevel = advancement.levels[0];\n    const currentLevel = this.currentLevel(clonedItem, manager.clone);\n\n    // If minimum level is greater than current level, no changes to remove\n    if ( (minimumLevel > currentLevel) || !advancement.appliesToClass ) return manager;\n\n    advancement.levels\n      .reverse()\n      .filter(l => l <= currentLevel)\n      .map(l => new advancement.constructor.metadata.apps.flow(clonedItem, advancementId, l))\n      .forEach(flow => manager.steps.push({ type: \"reverse\", flow, automatic: true }));\n\n    if ( manager.steps.length ) manager.steps.push({ type: \"delete\", advancement, automatic: true });\n\n    return manager;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct a manager for an item that needs to be deleted.\n@param {Actor5e} actor         Actor from which the item should be deleted.\n@param {string} itemId         ID of the item to be deleted.\n@param {object} [options={}]   Rendering options passed to the application.\n@returns {AdvancementManager}  Prepared manager. Steps count can be used to determine if advancements are needed.\n/\n  static forDeletedItem(actor, itemId, options={}) {\n    const manager = new this(actor, options);\n    const clonedItem = manager.clone.items.get(itemId);\n    if ( !clonedItem ) return manager;\n\n    // For class items, prepare level change data\n    if ( clonedItem.type === \"class\" ) {\n      return manager.createLevelChangeSteps(clonedItem, clonedItem.system.levels * -1);\n    }\n\n    // All other items, just create some flows down from current character level\n    Array.fromRange((manager.clone.system.details.level ?? 0) + 1)\n      .flatMap(l => this.flowsForLevel(clonedItem, l))\n      .reverse()\n      .forEach(flow => manager.steps.push({ type: \"reverse\", flow, automatic: true }));\n\n    // Add a final step to remove the item only if there are advancements to apply\n    if ( manager.steps.length ) manager.steps.push({ type: \"delete\", item: clonedItem, automatic: true });\n    return manager;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct a manager for a change in a class's levels.\n@param {Actor5e} actor         Actor whose level has changed.\n@param {string} classId        ID of the class being changed.\n@param {number} levelDelta     Levels by which to increase or decrease the class.\n@param {object} options        Rendering options passed to the application.\n@returns {AdvancementManager}  Prepared manager. Steps count can be used to determine if advancements are needed.\n/\n  static forLevelChange(actor, classId, levelDelta, options={}) {\n    const manager = new this(actor, options);\n    const clonedItem = manager.clone.items.get(classId);\n    if ( !clonedItem ) return manager;\n    return manager.createLevelChangeSteps(clonedItem, levelDelta);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreate steps based on the provided level change data.\n@param {string} classItem      Class being changed.\n@param {number} levelDelta     Levels by which to increase or decrease the class.\n@returns {AdvancementManager}  Manager with new steps.\n/\n  createLevelChangeSteps(classItem, levelDelta) {\n    const raceItem = this.clone.system?.details?.race instanceof Item ? this.clone.system.details.race : null;\n    const pushSteps = (flows, data) => this.steps.push(...flows.map(flow => ({ flow, ...data })));\n    const getItemFlows = characterLevel => this.clone.items.contents.flatMap(i => {\n      if ( [\"class\", \"subclass\", \"race\"].includes(i.type) ) return [];\n      return this.constructor.flowsForLevel(i, characterLevel);\n    });\n\n    // Level increased\n    for ( let offset = 1; offset <= levelDelta; offset++ ) {\n      const classLevel = classItem.system.levels + offset;\n      const characterLevel = (this.actor.system.details.level ?? 0) + offset;\n      const stepData = { type: \"forward\", class: {item: classItem, level: classLevel} };\n      pushSteps(this.constructor.flowsForLevel(raceItem, characterLevel), stepData);\n      pushSteps(this.constructor.flowsForLevel(classItem, classLevel), stepData);\n      pushSteps(this.constructor.flowsForLevel(classItem.subclass, classLevel), stepData);\n      pushSteps(getItemFlows(characterLevel), stepData);\n    }\n\n    // Level decreased\n    for ( let offset = 0; offset > levelDelta; offset-- ) {\n      const classLevel = classItem.system.levels + offset;\n      const characterLevel = (this.actor.system.details.level ?? 0) + offset;\n      const stepData = { type: \"reverse\", class: {item: classItem, level: classLevel}, automatic: true };\n      pushSteps(getItemFlows(characterLevel).reverse(), stepData);\n      pushSteps(this.constructor.flowsForLevel(classItem.subclass, classLevel).reverse(), stepData);\n      pushSteps(this.constructor.flowsForLevel(classItem, classLevel).reverse(), stepData);\n      pushSteps(this.constructor.flowsForLevel(raceItem, characterLevel).reverse(), stepData);\n      if ( classLevel === 1 ) this.steps.push({ type: \"delete\", item: classItem, automatic: true });\n    }\n\n    // Ensure the class level ends up at the appropriate point\n    this.steps.push({\n      type: \"forward\", automatic: true,\n      class: { item: classItem, level: classItem.system.levels += levelDelta }\n    });\n\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreates advancement flows for all advancements at a specific level.\n@param {Item5e} item                               Item that has advancement.\n@param {number} level                              Level in question.\n@param {object} [options={}]\n@param {AdvancementStep[]} [options.findExisting]  Find if an existing matching flow exists.\n@returns {AdvancementFlow[]}                       Created or matched flow applications.\n/\n  static flowsForLevel(item, level, { findExisting }={}) {\n    const match = (advancement, step) => (step.flow?.item.id === item.id)\n      && (step.flow?.advancement.id === advancement.id)\n      && (step.flow?.level === level);\n    return (item?.advancement.byLevel[level] ?? [])\n      .filter(a => a.appliesToClass)\n      .map(a => {\n        const existing = findExisting?.find(s => match(a, s))?.flow;\n        if ( !existing ) return new a.constructor.metadata.apps.flow(item, a.id, level);\n        existing.item = item;\n        return existing;\n      });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDetermine the proper working level either from the provided item or from the cloned actor.\n@param {Item5e} item    Item being advanced. If class or subclass, its level will be used.\n@param {Actor5e} actor  Actor being advanced.\n@returns {number}       Working level.\n/\n  static currentLevel(item, actor) {\n    return item.system.levels ?? item.class?.system.levels ?? actor.system.details.level ?? 0;\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _configureRenderOptions(options) {\n    super._configureRenderOptions(options);\n    options.window ??= {};\n    options.window.subtitle ??= this.subtitle;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _prepareContext(options) {\n    const context = await super._prepareContext(options);\n    if ( !this.step ) return context;\n\n    const visibleSteps = this.steps.filter(s => !s.automatic);\n    const visibleIndex = visibleSteps.indexOf(this.step);\n\n    return {\n      ...context,\n      actor: this.clone,\n      // Keep styles from non-converted flow applications functioning\n      // Should be removed when V1 of `AdvancementFlow` is deprecated\n      flowClasses: this.step.flow instanceof Application ? \"dnd5e advancement flow\" : \"\",\n      flowId: this.step.flow.id,\n      steps: {\n        current: visibleIndex + 1,\n        total: visibleSteps.length,\n        hasPrevious: visibleIndex > 0,\n        hasNext: visibleIndex < visibleSteps.length - 1\n      }\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  render(forced=false, options={}) {\n    if ( this.steps.length && (this.#stepIndex === null) ) this.#stepIndex = 0;\n\n    // Ensure the level on the class item matches the specified level\n    if ( this.step?.class ) {\n      let level = this.step.class.level;\n      if ( this.step.type === \"reverse\" ) level -= 1;\n      this.step.class.item.updateSource({\"system.levels\": level});\n      this.clone.reset();\n    }\n\n    /**\nA hook event that fires when an AdvancementManager is about to be processed.\n@function dnd5e.preAdvancementManagerRender\n@memberof hookEvents\n@param {AdvancementManager} advancementManager The advancement manager about to be rendered\n/\n    const allowed = Hooks.call(\"dnd5e.preAdvancementManagerRender\", this);\n\n    // Abort if not allowed\n    if ( allowed === false ) return this;\n\n    const automaticData = (this.options.automaticApplication && (options.direction !== \"backward\"))\n      ? this.step?.flow?.getAutomaticApplicationValue() : false;\n\n    if ( this.step?.automatic || (automaticData !== false) ) {\n      if ( this.#advancing ) return this;\n      this.#forward({ automaticData });\n      return this;\n    }\n\n    return super.render(forced, options);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _onRender(context, options) {\n    super._onRender(context, options);\n    if ( !this.rendered || !this.step ) return;\n    this.#visualizer?.render({ force: true });\n\n    // Render the step\n    this.step.flow._element = null;\n    this.step.flow.options.manager ??= this;\n    await this.step.flow._render(true, options);\n    this.setPosition();\n  }\n\n  /* -------------------------------------------- */\n  /*  Life-Cycle Handlers                         */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async close(options={}) {\n    if ( !options.skipConfirmation ) {\n      return new Dialog({\n        title: `${game.i18n.localize(\"DND5E.ADVANCEMENT.Manager.ClosePrompt.Title\")}: ${this.actor.name}`,\n        content: game.i18n.localize(\"DND5E.ADVANCEMENT.Manager.ClosePrompt.Message\"),\n        buttons: {\n          close: {\n            icon: '<i class=\"fas fa-times\" inert></i>',\n            label: game.i18n.localize(\"DND5E.ADVANCEMENT.Manager.ClosePrompt.Action.Stop\"),\n            callback: () => {\n              this.#visualizer?.close();\n              super.close(options);\n            }\n          },\n          continue: {\n            icon: '<i class=\"fas fa-chevron-right\" inert></i>',\n            label: game.i18n.localize(\"DND5E.ADVANCEMENT.Manager.ClosePrompt.Action.Continue\")\n          }\n        },\n        default: \"close\"\n      }).render(true);\n    }\n    this.#visualizer?.close();\n    await super.close(options);\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers                */\n  /* -------------------------------------------- */\n\n  /**\nHandle one of the buttons for moving through the process.\n@this {AdvancementManager}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static async #process(event, target) {\n    target.disabled = true;\n    this.element.querySelector(\".error\")?.classList.remove(\"error\");\n    try {\n      switch ( target.dataset.action ) {\n        case \"restart\":\n          if ( this.previousStep ) await this.#restart(event);\n          break;\n        case \"previous\":\n          if ( this.previousStep ) await this.#backward(event);\n          break;\n        case \"next\":\n        case \"complete\":\n          await this.#forward(event);\n          break;\n      }\n    } finally {\n      target.disabled = false;\n    }\n  }\n\n  /* -------------------------------------------- */\n  /*  Process                                     */\n  /* -------------------------------------------- */\n\n  /**\nAdvance through the steps until one requiring user interaction is encountered.\n@param {object} config\n@param {object} [config.automaticData]  Data provided to handle automatic application.\n@param {Event} [config.event]           Triggering click event if one occurred.\n@returns {Promise}\n/\n  async #forward({ automaticData, event }) {\n    this.#advancing = true;\n    try {\n      do {\n        const flow = this.step.flow;\n        const type = this.step.type;\n        const preEmbeddedItems = Array.from(this.clone.items);\n\n        // Apply changes based on step type\n        if ( (type === \"delete\") && this.step.item ) {\n          if ( this.step.flow?.retainedData?.retainedItems ) {\n            this.step.flow.retainedData.retainedItems[this.step.item.flags.dnd5e?.sourceId] = this.step.item.toObject();\n          }\n          this.clone.items.delete(this.step.item.id);\n        } else if ( (type === \"delete\") && this.step.advancement ) {\n          this.step.advancement.item.deleteAdvancement(this.step.advancement.id, { source: true });\n        }\n        else if ( type === \"restore\" ) await flow.advancement.restore(flow.level, flow.retainedData);\n        else if ( type === \"reverse\" ) await flow.retainData(await flow.advancement.reverse(flow.level));\n        else if ( automaticData && flow ) await flow.advancement.apply(flow.level, automaticData);\n        else if ( flow ) await flow._updateObject(event, flow._getSubmitData());\n\n        this.#synthesizeSteps(preEmbeddedItems);\n        this.#stepIndex++;\n\n        // Ensure the level on the class item matches the specified level\n        if ( this.step?.class ) {\n          let level = this.step.class.level;\n          if ( this.step.type === \"reverse\" ) level -= 1;\n          this.step.class.item.updateSource({\"system.levels\": level});\n        }\n        this.clone.reset();\n      } while ( this.step?.automatic );\n    } catch(error) {\n      if ( !(error instanceof Advancement.ERROR) ) throw error;\n      ui.notifications.error(error.message);\n      this.step.automatic = false;\n      if ( this.step.type === \"restore\" ) this.step.type = \"forward\";\n    } finally {\n      this.#advancing = false;\n    }\n\n    if ( this.step ) this.render({ force: true, direction: \"forward\" });\n    else this.#complete();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd synthetic steps for any added or removed items with advancement.\n@param {Item5e[]} preEmbeddedItems  Items present before the current step was applied.\n/\n  #synthesizeSteps(preEmbeddedItems) {\n    // Build a set of item IDs for non-synthetic steps\n    const initialIds = this.steps.reduce((ids, step) => {\n      if ( step.synthetic || !step.flow?.item ) return ids;\n      ids.add(step.flow.item.id);\n      return ids;\n    }, new Set());\n\n    const preIds = new Set(preEmbeddedItems.map(i => i.id));\n    const postIds = new Set(this.clone.items.map(i => i.id));\n    const addedIds = postIds.difference(preIds).difference(initialIds);\n    const deletedIds = preIds.difference(postIds).difference(initialIds);\n\n    for ( const addedId of addedIds ) {\n      const item = this.clone.items.get(addedId);\n      if ( !item.hasAdvancement ) continue;\n\n      let handledLevel = 0;\n      for ( let idx = this.#stepIndex; idx < this.steps.length; idx++ ) {\n        // Find spots where the level increases\n        const thisLevel = this.steps[idx].flow?.level ?? this.steps[idx].class?.level;\n        const nextLevel = this.steps[idx + 1]?.flow?.level ?? this.steps[idx + 1]?.class?.level;\n        if ( (thisLevel < handledLevel) || (thisLevel === nextLevel) ) continue;\n\n        // Determine if there is any advancement to be done for the added item to this level\n        // from the previously handled level\n        const steps = Array.fromRange(thisLevel - handledLevel + 1, handledLevel)\n          .flatMap(l => this.constructor.flowsForLevel(item, l, { findExisting: this.steps }))\n          .map(flow => ({ type: \"forward\", flow, synthetic: true }));\n\n        // Add new steps at the end of the level group\n        this.steps.splice(idx + 1, 0, ...steps);\n        idx += steps.length;\n\n        handledLevel = nextLevel ?? handledLevel;\n      }\n    }\n\n    if ( (this.step.type === \"delete\") && this.step.synthetic ) return;\n    for ( const deletedId of deletedIds ) {\n      let item = preEmbeddedItems.find(i => i.id === deletedId);\n      if ( !item?.hasAdvancement ) continue;\n\n      // Temporarily add the item back\n      this.clone.updateSource({items: [item.toObject()]});\n      item = this.clone.items.get(item.id);\n\n      // Check for advancement from the maximum level handled by this manager to zero\n      let steps = [];\n      Array.fromRange(this.clone.system.details.level + 1)\n        .flatMap(l => this.constructor.flowsForLevel(item, l))\n        .reverse()\n        .forEach(flow => steps.push({ type: \"reverse\", flow, automatic: true, synthetic: true }));\n\n      // Add a new remove item step to the end of the synthetic steps to finally get rid of this item\n      steps.push({ type: \"delete\", flow: this.step.flow, item, automatic: true, synthetic: true });\n\n      // Add new steps after the current step\n      this.steps.splice(this.#stepIndex + 1, 0, ...steps);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nReverse through the steps until one requiring user interaction is encountered.\n@param {Event} [event]                  Triggering click event if one occurred.\n@param {object} [options]               Additional options to configure behavior.\n@param {boolean} [options.render=true]  Whether to render the Application after the step has been reversed. Used\n                                        by the restart workflow.\n@returns {Promise}\n/\n  async #backward(event, { render=true }={}) {\n    this.#advancing = true;\n    try {\n      do {\n        this.#stepIndex--;\n        if ( !this.step ) break;\n        const flow = this.step.flow;\n        const type = this.step.type;\n        const preEmbeddedItems = Array.from(this.clone.items);\n\n        // Reverse step based on step type\n        if ( (type === \"delete\") && this.step.item ) this.clone.updateSource({items: [this.step.item]});\n        else if ( (type === \"delete\") && this.step.advancement ) this.advancement.item.createAdvancement(\n          this.advancement.typeName, this.advancement._source, { source: true }\n        );\n        else if ( type === \"reverse\" ) await flow.advancement.restore(flow.level, flow.retainedData);\n        else if ( flow ) await flow.retainData(await flow.advancement.reverse(flow.level));\n\n        this.#clearSyntheticSteps(preEmbeddedItems);\n        this.clone.reset();\n      } while ( this.step?.automatic );\n    } catch(error) {\n      if ( !(error instanceof Advancement.ERROR) ) throw error;\n      ui.notifications.error(error.message);\n      this.step.automatic = false;\n    } finally {\n      this.#advancing = false;\n    }\n\n    if ( !render ) return;\n    if ( this.step ) this.render(true, { direction: \"backward\" });\n    else this.close({ skipConfirmation: true });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRemove synthetic steps for any added or removed items.\n@param {Item5e[]} preEmbeddedItems  Items present before the current step was applied.\n/\n  #clearSyntheticSteps(preEmbeddedItems) {\n    // Create a disjoint union of the before and after items\n    const preIds = new Set(preEmbeddedItems.map(i => i.id));\n    const postIds = new Set(this.clone.items.map(i => i.id));\n    const modifiedIds = postIds.symmetricDifference(preIds);\n\n    // Remove any synthetic steps after the current step if their item has been modified\n    for ( const [idx, element] of Array.from(this.steps.entries()).reverse() ) {\n      if ( idx <= this.#stepIndex ) break;\n      if ( element.synthetic && modifiedIds.has(element.flow?.item?.id) ) this.steps.splice(idx, 1);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nReset back to the manager's initial state.\n@param {MouseEvent} [event]  The triggering click event if one occurred.\n@returns {Promise}\n/\n  async #restart(event) {\n    const restart = await Dialog.confirm({\n      title: game.i18n.localize(\"DND5E.ADVANCEMENT.Manager.RestartPrompt.Title\"),\n      content: game.i18n.localize(\"DND5E.ADVANCEMENT.Manager.RestartPrompt.Message\")\n    });\n    if ( !restart ) return;\n    // While there is still a renderable step.\n    while ( this.steps.slice(0, this.#stepIndex).some(s => !s.automatic) ) {\n      await this.#backward(event, {render: false});\n    }\n    this.render(true);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nApply changes to actual actor after all choices have been made.\n@param {Event} event  Button click that triggered the change.\n@returns {Promise}\n/\n  async #complete(event) {\n    const updates = this.clone.toObject();\n    const items = updates.items;\n    delete updates.items;\n\n    // Gather changes to embedded items\n    const { toCreate, toUpdate, toDelete } = items.reduce((obj, item) => {\n      if ( !this.actor.items.get(item._id) ) {\n        obj.toCreate.push(item);\n      } else {\n        obj.toUpdate.push(item);\n        obj.toDelete.findSplice(id => id === item._id);\n      }\n      return obj;\n    }, { toCreate: [], toUpdate: [], toDelete: this.actor.items.map(i => i.id) });\n\n    /**\nA hook event that fires at the final stage of a character's advancement process, before actor and item updates\nare applied.\n@function dnd5e.preAdvancementManagerComplete\n@memberof hookEvents\n@param {AdvancementManager} advancementManager  The advancement manager.\n@param {object} actorUpdates                    Updates to the actor.\n@param {object[]} toCreate                      Items that will be created on the actor.\n@param {object[]} toUpdate                      Items that will be updated on the actor.\n@param {string[]} toDelete                      IDs of items that will be deleted on the actor.\n/\n    if ( Hooks.call(\"dnd5e.preAdvancementManagerComplete\", this, updates, toCreate, toUpdate, toDelete) === false ) {\n      log(\"AdvancementManager completion was prevented by the 'preAdvancementManagerComplete' hook.\");\n      return this.close({ skipConfirmation: true });\n    }\n\n    // Apply changes from clone to original actor\n    await Promise.all([\n      this.actor.update(updates, { isAdvancement: true }),\n      this.actor.createEmbeddedDocuments(\"Item\", toCreate, { keepId: true, isAdvancement: true }),\n      this.actor.updateEmbeddedDocuments(\"Item\", toUpdate, { isAdvancement: true }),\n      this.actor.deleteEmbeddedDocuments(\"Item\", toDelete, { isAdvancement: true })\n    ]);\n\n    /**\nA hook event that fires when an AdvancementManager is done modifying an actor.\n@function dnd5e.advancementManagerComplete\n@memberof hookEvents\n@param {AdvancementManager} advancementManager The advancement manager that just completed\n/\n    Hooks.callAll(\"dnd5e.advancementManagerComplete\", this);\n\n    // Close prompt\n    return this.close({ skipConfirmation: true });\n  }\n}\n\n/* -------------------------------------------- */\n\n/**\nDebug application for visualizing advancement steps.\nNote: Intentionally not localized due to its nature as a debug application."
    },
    {
      "name": "AdvancementMigrationDialog",
      "extends": "Dialog",
      "file": "module\\applications\\advancement\\advancement-migration-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "AdvancementSelection",
      "extends": "Dialog",
      "file": "module\\applications\\advancement\\advancement-selection.mjs",
      "jsDoc": ""
    },
    {
      "name": "HitPointsConfig",
      "extends": "AdvancementConfig",
      "file": "module\\applications\\advancement\\hit-points-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "HitPointsFlow",
      "extends": "AdvancementFlow",
      "file": "module\\applications\\advancement\\hit-points-flow.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemChoiceConfig",
      "extends": "AdvancementConfig",
      "file": "module\\applications\\advancement\\item-choice-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemChoiceFlow",
      "extends": "ItemGrantFlow",
      "file": "module\\applications\\advancement\\item-choice-flow.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemGrantConfig",
      "extends": "AdvancementConfig",
      "file": "module\\applications\\advancement\\item-grant-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemGrantFlow",
      "extends": "AdvancementFlow",
      "file": "module\\applications\\advancement\\item-grant-flow.mjs",
      "jsDoc": ""
    },
    {
      "name": "ScaleValueConfig",
      "extends": "AdvancementConfig",
      "file": "module\\applications\\advancement\\scale-value-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "ScaleValueFlow",
      "extends": "AdvancementFlow",
      "file": "module\\applications\\advancement\\scale-value-flow.mjs",
      "jsDoc": ""
    },
    {
      "name": "SizeConfig",
      "extends": "AdvancementConfig",
      "file": "module\\applications\\advancement\\size-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "SizeFlow",
      "extends": "AdvancementFlow",
      "file": "module\\applications\\advancement\\size-flow.mjs",
      "jsDoc": ""
    },
    {
      "name": "SubclassFlow",
      "extends": "AdvancementFlow",
      "file": "module\\applications\\advancement\\subclass-flow.mjs",
      "jsDoc": ""
    },
    {
      "name": "TraitConfig",
      "extends": "AdvancementConfig",
      "file": "module\\applications\\advancement\\trait-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "TraitFlow",
      "extends": "AdvancementFlow",
      "file": "module\\applications\\advancement\\trait-flow.mjs",
      "jsDoc": ""
    },
    {
      "name": "Dialog5e",
      "extends": "Application5e",
      "file": "module\\applications\\api\\dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "PseudoDocumentSheet",
      "extends": "Application5e",
      "file": "module\\applications\\api\\pseudo-document-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "Award",
      "extends": "Application5e",
      "file": "module\\applications\\award.mjs",
      "jsDoc": ""
    },
    {
      "name": "BastionConfig",
      "extends": "BastionSettingsConfig",
      "file": "module\\applications\\bastion.mjs",
      "jsDoc": ""
    },
    {
      "name": "CompendiumBrowserSourceConfig",
      "extends": "CompendiumBrowserSettingsConfig",
      "file": "module\\applications\\compendium-browser-source-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "CompendiumBrowser",
      "extends": "Application5e",
      "file": "module\\applications\\compendium-browser.mjs",
      "jsDoc": ""
    },
    {
      "name": "AdoptedStyleSheetElement",
      "extends": "Base",
      "file": "module\\applications\\components\\adopted-stylesheet-mixin.mjs",
      "jsDoc": ""
    },
    {
      "name": "ChatTrayElement",
      "extends": "HTMLElement",
      "file": "module\\applications\\components\\chat-tray-element.mjs",
      "jsDoc": ""
    },
    {
      "name": "CopyableTextElement",
      "extends": "HTMLElement",
      "file": "module\\applications\\components\\copyable-text.mjs",
      "jsDoc": ""
    },
    {
      "name": "EffectsElement",
      "extends": "HTMLElement",
      "file": "module\\applications\\components\\effects.mjs",
      "jsDoc": ""
    },
    {
      "name": "EnchantmentApplicationElement",
      "extends": "HTMLElement",
      "file": "module\\applications\\components\\enchantment-application.mjs",
      "jsDoc": ""
    },
    {
      "name": "InventoryElement",
      "extends": "HTMLElement",
      "file": "module\\applications\\components\\inventory.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemListControlsElement",
      "extends": "HTMLElement",
      "file": "module\\applications\\components\\item-list-controls.mjs",
      "jsDoc": ""
    },
    {
      "name": "SlideToggleElement",
      "extends": "CheckboxElement",
      "file": "module\\applications\\components\\slide-toggle.mjs",
      "jsDoc": ""
    },
    {
      "name": "TargetedApplicationElement",
      "extends": "Base",
      "file": "module\\applications\\components\\targeted-application-mixin.mjs",
      "jsDoc": ""
    },
    {
      "name": "CurrencyManager",
      "extends": "Application5e",
      "file": "module\\applications\\currency-manager.mjs",
      "jsDoc": ""
    },
    {
      "name": "AttackRollConfigurationDialog",
      "extends": "D20RollConfigurationDialog",
      "file": "module\\applications\\dice\\attack-configuration-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "D20RollConfigurationDialog",
      "extends": "RollConfigurationDialog",
      "file": "module\\applications\\dice\\d20-configuration-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "DamageRollConfigurationDialog",
      "extends": "RollConfigurationDialog",
      "file": "module\\applications\\dice\\damage-configuration-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "RollConfigurationDialog",
      "extends": "Dialog5e",
      "file": "module\\applications\\dice\\roll-configuration-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "SkillToolRollConfigurationDialog",
      "extends": "D20RollConfigurationDialog",
      "file": "module\\applications\\dice\\skill-tool-configuration-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "ContainerSheet",
      "extends": "ItemSheet5e",
      "file": "module\\applications\\item\\container-sheet.mjs",
      "jsDoc": ""
    },
    {
      "name": "CreateScrollDialog",
      "extends": "Dialog5e",
      "file": "module\\applications\\item\\create-scroll-dialog.mjs",
      "jsDoc": ""
    },
    {
      "name": "EnchantmentConfig",
      "extends": "DocumentSheet",
      "file": "module\\applications\\item\\enchantment-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "StartingEquipmentConfig",
      "extends": "DocumentSheet5e",
      "file": "module\\applications\\item\\starting-equipment-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "SummoningConfig",
      "extends": "DocumentSheet",
      "file": "module\\applications\\item\\summoning-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "JournalEditor",
      "extends": "DocumentSheet5e",
      "file": "module\\applications\\journal\\journal-editor.mjs",
      "jsDoc": ""
    },
    {
      "name": "SpellsUnlinkedConfig",
      "extends": "DocumentSheet5e",
      "file": "module\\applications\\journal\\spells-unlinked-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "DragDropApplication",
      "extends": "Base",
      "file": "module\\applications\\mixins\\drag-drop-mixin.mjs",
      "jsDoc": ""
    },
    {
      "name": "PropertyAttribution",
      "extends": "Application5e",
      "file": "module\\applications\\property-attribution.mjs",
      "jsDoc": ""
    },
    {
      "name": "BaseSettingsConfig",
      "extends": "Application5e",
      "file": "module\\applications\\settings\\base-settings.mjs",
      "jsDoc": ""
    },
    {
      "name": "BastionSettingsConfig",
      "extends": "BaseSettingsConfig",
      "file": "module\\applications\\settings\\bastion-settings.mjs",
      "jsDoc": ""
    },
    {
      "name": "CombatSettingsConfig",
      "extends": "BaseSettingsConfig",
      "file": "module\\applications\\settings\\combat-settings.mjs",
      "jsDoc": ""
    },
    {
      "name": "CompendiumBrowserSettingsConfig",
      "extends": "Application5e",
      "file": "module\\applications\\settings\\compendium-browser-settings.mjs",
      "jsDoc": ""
    },
    {
      "name": "ModuleArtSettingsConfig",
      "extends": "FormApplication",
      "file": "module\\applications\\settings\\module-art-settings.mjs",
      "jsDoc": ""
    },
    {
      "name": "VariantRulesSettingsConfig",
      "extends": "BaseSettingsConfig",
      "file": "module\\applications\\settings\\variant-rules-settings.mjs",
      "jsDoc": ""
    },
    {
      "name": "VisibilitySettingsConfig",
      "extends": "BaseSettingsConfig",
      "file": "module\\applications\\settings\\visibility-settings.mjs",
      "jsDoc": ""
    },
    {
      "name": "CreatureTypeConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\shared\\creature-type-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "MovementSensesConfig",
      "extends": "BaseConfigSheet",
      "file": "module\\applications\\shared\\movement-senses-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "SourceConfig",
      "extends": "DocumentSheet5e",
      "file": "module\\applications\\source-config.mjs",
      "jsDoc": ""
    },
    {
      "name": "TokenPlacement",
      "extends": null,
      "file": "module\\canvas\\token-placement.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorDataModel",
      "extends": "SystemDataModel",
      "file": "module\\data\\abstract.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemDataModel",
      "extends": "SystemDataModel",
      "file": "module\\data\\abstract.mjs",
      "jsDoc": ""
    },
    {
      "name": "AttackActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\attack-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "CastActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\cast-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "CheckActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\check-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "DamageActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\damage-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "EnchantActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\enchant-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "AppliedEffectField",
      "extends": "SchemaField",
      "file": "module\\data\\activity\\fields\\applied-effect-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "ConsumptionTargetsField",
      "extends": "ArrayField",
      "file": "module\\data\\activity\\fields\\consumption-targets-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "ConsumptionError",
      "extends": "Error",
      "file": "module\\data\\activity\\fields\\consumption-targets-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "ForwardActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\forward-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "HealActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\heal-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "OrderActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\order-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "SaveActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\save-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "SummonActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\summon-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "UtilityActivityData",
      "extends": "BaseActivityData",
      "file": "module\\data\\activity\\utility-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "CharacterData",
      "extends": "CreatureTemplate",
      "file": "module\\data\\actor\\character.mjs",
      "jsDoc": ""
    },
    {
      "name": "DamageTraitField",
      "extends": "SimpleTraitField",
      "file": "module\\data\\actor\\fields\\damage-trait-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "SimpleTraitField",
      "extends": "SchemaField",
      "file": "module\\data\\actor\\fields\\simple-trait-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "NPCData",
      "extends": "CreatureTemplate",
      "file": "module\\data\\actor\\npc.mjs",
      "jsDoc": ""
    },
    {
      "name": "AttributesFields",
      "extends": null,
      "file": "module\\data\\actor\\templates\\attributes.mjs",
      "jsDoc": ""
    },
    {
      "name": "CreatureTemplate",
      "extends": "CommonTemplate",
      "file": "module\\data\\actor\\templates\\creature.mjs",
      "jsDoc": ""
    },
    {
      "name": "DetailsField",
      "extends": null,
      "file": "module\\data\\actor\\templates\\details.mjs",
      "jsDoc": ""
    },
    {
      "name": "TraitsField",
      "extends": null,
      "file": "module\\data\\actor\\templates\\traits.mjs",
      "jsDoc": ""
    },
    {
      "name": "VehicleData",
      "extends": "CommonTemplate",
      "file": "module\\data\\actor\\vehicle.mjs",
      "jsDoc": ""
    },
    {
      "name": "AbilityScoreImprovementValueData",
      "extends": "SparseDataModel",
      "file": "module\\data\\advancement\\ability-score-improvement.mjs",
      "jsDoc": ""
    },
    {
      "name": "BaseAdvancement",
      "extends": "SparseDataModel",
      "file": "module\\data\\advancement\\base-advancement.mjs",
      "jsDoc": ""
    },
    {
      "name": "ScaleValueTypeNumber",
      "extends": "ScaleValueType",
      "file": "module\\data\\advancement\\scale-value.mjs",
      "jsDoc": ""
    },
    {
      "name": "ScaleValueTypeCR",
      "extends": "ScaleValueTypeNumber",
      "file": "module\\data\\advancement\\scale-value.mjs",
      "jsDoc": ""
    },
    {
      "name": "ScaleValueTypeDice",
      "extends": "ScaleValueType",
      "file": "module\\data\\advancement\\scale-value.mjs",
      "jsDoc": ""
    },
    {
      "name": "ScaleValueTypeDistance",
      "extends": "ScaleValueTypeNumber",
      "file": "module\\data\\advancement\\scale-value.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActivationsField",
      "extends": "SetField",
      "file": "module\\data\\chat-message\\fields\\activations-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActorDeltasField",
      "extends": "SchemaField",
      "file": "module\\data\\chat-message\\fields\\deltas-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "IndividualDeltaField",
      "extends": "SchemaField",
      "file": "module\\data\\chat-message\\fields\\deltas-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "RestMessageData",
      "extends": "ChatMessageDataModel",
      "file": "module\\data\\chat-message\\rest-message-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "TurnMessageData",
      "extends": "ChatMessageDataModel",
      "file": "module\\data\\chat-message\\turn-message-data.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActivitiesField",
      "extends": "MappingField",
      "file": "module\\data\\fields\\activities-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActivityCollection",
      "extends": "Collection",
      "file": "module\\data\\fields\\activities-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "EnchantmentField",
      "extends": "EmbeddedDataField",
      "file": "module\\data\\item\\fields\\enchantment-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "EnchantmentError",
      "extends": "Error",
      "file": "module\\data\\item\\fields\\enchantment-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "SpellcastingField",
      "extends": "SchemaField",
      "file": "module\\data\\item\\fields\\spellcasting-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "SummonsField",
      "extends": "EmbeddedDataField",
      "file": "module\\data\\item\\fields\\summons-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActionTemplate",
      "extends": "ItemDataModel",
      "file": "module\\data\\item\\templates\\action.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActivatedEffectTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\item\\templates\\activated-effect.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemUsesField",
      "extends": "SchemaField",
      "file": "module\\data\\item\\templates\\activated-effect.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActivitiesTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\item\\templates\\activities.mjs",
      "jsDoc": ""
    },
    {
      "name": "EquippableItemTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\item\\templates\\equippable-item.mjs",
      "jsDoc": ""
    },
    {
      "name": "IdentifiableTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\item\\templates\\identifiable.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemDescriptionTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\item\\templates\\item-description.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemTypeTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\item\\templates\\item-type.mjs",
      "jsDoc": ""
    },
    {
      "name": "MountableTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\item\\templates\\mountable.mjs",
      "jsDoc": ""
    },
    {
      "name": "PhysicalItemTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\item\\templates\\physical-item.mjs",
      "jsDoc": ""
    },
    {
      "name": "StartingEquipmentTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\item\\templates\\starting-equipment.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActivationField",
      "extends": "SchemaField",
      "file": "module\\data\\shared\\activation-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "CurrencyTemplate",
      "extends": "SystemDataModel",
      "file": "module\\data\\shared\\currency.mjs",
      "jsDoc": ""
    },
    {
      "name": "DamageField",
      "extends": "EmbeddedDataField",
      "file": "module\\data\\shared\\damage-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "DurationField",
      "extends": "SchemaField",
      "file": "module\\data\\shared\\duration-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "RangeField",
      "extends": "SchemaField",
      "file": "module\\data\\shared\\range-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "SourceField",
      "extends": "SchemaField",
      "file": "module\\data\\shared\\source-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "TargetField",
      "extends": "SchemaField",
      "file": "module\\data\\shared\\target-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "UsesField",
      "extends": "SchemaField",
      "file": "module\\data\\shared\\uses-field.mjs",
      "jsDoc": ""
    },
    {
      "name": "BasicRoll",
      "extends": "Roll",
      "file": "module\\dice\\basic-roll.mjs",
      "jsDoc": ""
    },
    {
      "name": "D20Die",
      "extends": "Die",
      "file": "module\\dice\\d20-die.mjs",
      "jsDoc": ""
    },
    {
      "name": "D20Roll",
      "extends": "BasicRoll",
      "file": "module\\dice\\d20-roll.mjs",
      "jsDoc": ""
    },
    {
      "name": "DamageRoll",
      "extends": "BasicRoll",
      "file": "module\\dice\\damage-roll.mjs",
      "jsDoc": ""
    },
    {
      "name": "ActiveEffect5e",
      "extends": "ActiveEffect",
      "file": "module\\documents\\active-effect.mjs",
      "jsDoc": ""
    },
    {
      "name": "EnchantmentError",
      "extends": "Error",
      "file": "module\\documents\\activity\\enchant.mjs",
      "jsDoc": ""
    },
    {
      "name": "SourcedItemsMap",
      "extends": "Map",
      "file": "module\\documents\\actor\\actor.mjs",
      "jsDoc": "Extend the base Actor class to implement additional system-specific logic.\n/\nexport default class Actor5e extends SystemDocumentMixin(Actor) {\n\n  /**\nThe data source for Actor5e.classes allowing it to be lazily computed.\n@type {Record<string, Item5e>}\n@private\n/\n  _classes;\n\n  /**\nCached spellcasting classes.\n@type {Record<string, Item5e>}\n@private\n/\n  _spellcastingClasses;\n\n  /**\nMapping of item compendium source UUIDs to the items.\n@type {Map<string, Item5e>}\n/\n  sourcedItems = this.sourcedItems;\n\n  /* -------------------------------------------- */\n\n  /**\nTypes that can be selected within the compendium browser.\n@param {object} [options={}]\n@param {Set<string>} [options.chosen]  Types that have been selected.\n@returns {SelectChoices}\n/\n  static compendiumBrowserTypes({ chosen=new Set() }={}) {\n    return new SelectChoices(Actor.TYPES.filter(t => t !== CONST.BASE_DOCUMENT_TYPE).reduce((obj, type) => {\n      obj[type] = {\n        label: CONFIG.Actor.typeLabels[type],\n        chosen: chosen.has(type)\n      };\n      return obj;\n    }, {}));\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nA mapping of classes belonging to this Actor.\n@type {Record<string, Item5e>}\n/\n  get classes() {\n    if ( this._classes !== undefined ) return this._classes;\n    if ( ![\"character\", \"npc\"].includes(this.type) ) return this._classes = {};\n    return this._classes = Object.fromEntries(this.itemTypes.class.map(cls => [cls.identifier, cls]));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCalculate the bonus from any cover the actor is affected by.\n@type {number}     The cover bonus to AC and dexterity saving throws.\n/\n  get coverBonus() {\n    const { coverHalf, coverThreeQuarters } = CONFIG.DND5E.statusEffects;\n    if ( this.statuses.has(\"coverThreeQuarters\") ) return coverThreeQuarters?.coverBonus;\n    else if ( this.statuses.has(\"coverHalf\") ) return coverHalf?.coverBonus;\n    return 0;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nGet all classes which have spellcasting ability.\n@type {Record<string, Item5e>}\n/\n  get spellcastingClasses() {\n    if ( this._spellcastingClasses !== undefined ) return this._spellcastingClasses;\n    return this._spellcastingClasses = Object.entries(this.classes).reduce((obj, [identifier, cls]) => {\n      if ( cls.spellcasting && (cls.spellcasting.progression !== \"none\") ) obj[identifier] = cls;\n      return obj;\n    }, {});\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this Actor currently polymorphed into some other creature?\n@type {boolean}\n/\n  get isPolymorphed() {\n    return this.getFlag(\"dnd5e\", \"isPolymorphed\") || false;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe Actor's currently equipped armor, if any.\n@type {Item5e|null}\n/\n  get armor() {\n    return this.system.attributes?.ac?.equippedArmor ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe Actor's currently equipped shield, if any.\n@type {Item5e|null}\n/\n  get shield() {\n    return this.system.attributes?.ac?.equippedShield ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe items this actor is concentrating on, and the relevant effects.\n@type {{items: Set<Item5e>, effects: Set<ActiveEffect5e>}}\n/\n  get concentration() {\n    const concentration = {\n      items: new Set(),\n      effects: new Set()\n    };\n\n    const limit = this.system.attributes?.concentration?.limit ?? 0;\n    if ( !limit ) return concentration;\n\n    for ( const effect of this.effects ) {\n      if ( !effect.statuses.has(CONFIG.specialStatusEffects.CONCENTRATING) ) continue;\n      const data = effect.getFlag(\"dnd5e\", \"item\");\n      concentration.effects.add(effect);\n      if ( data ) {\n        let item = this.items.get(data.id);\n        if ( !item && (foundry.utils.getType(data.data) === \"Object\") ) {\n          item = new Item.implementation(data.data, { keepId: true, parent: this });\n        }\n        if ( item ) concentration.items.add(item);\n      }\n    }\n    return concentration;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreatures summoned by this actor.\n@type {Actor5e[]}\n/\n  get summonedCreatures() {\n    return dnd5e.registry.summons.creatures(this);\n  }\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _initializeSource(source, options={}) {\n    source = super._initializeSource(source, options);\n    if ( !source._id || !options.pack || dnd5e.moduleArt.suppressArt ) return source;\n    const uuid = `Compendium.${options.pack}.${source._id}`;\n    const art = game.dnd5e.moduleArt.map.get(uuid);\n    if ( art?.actor || art?.token ) {\n      if ( art.actor ) source.img = art.actor;\n      if ( typeof art.token === \"string\" ) source.prototypeToken.texture.src = art.token;\n      else if ( art.token ) foundry.utils.mergeObject(source.prototypeToken, art.token);\n      const biography = source.system.details?.biography;\n      if ( art.credit && biography ) {\n        if ( typeof biography.value !== \"string\" ) biography.value = \"\";\n        biography.value += `<p>${art.credit}</p>`;\n      }\n    }\n    return source;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  prepareData() {\n    if ( this.system.modelProvider !== dnd5e ) return super.prepareData();\n    this._clearCachedValues();\n    this._preparationWarnings = [];\n    super.prepareData();\n    this.items.forEach(item => item.prepareFinalAttributes());\n    this._prepareSpellcasting();\n  }\n\n  /* --------------------------------------------- */\n\n  /**\nClear cached class collections.\n@internal\n/\n  _clearCachedValues() {\n    this._classes = undefined;\n    this._spellcastingClasses = undefined;\n  }\n\n  /* --------------------------------------------- */\n\n  /** @inheritDoc */\n  prepareEmbeddedDocuments() {\n    this.sourcedItems = new SourcedItemsMap();\n    this._embeddedPreparation = true;\n    super.prepareEmbeddedDocuments();\n    delete this._embeddedPreparation;\n  }\n\n  /* --------------------------------------------- */\n\n  /** @inheritDoc */\n  applyActiveEffects() {\n    if ( this.system?.prepareEmbeddedData instanceof Function ) this.system.prepareEmbeddedData();\n    // The Active Effects do not have access to their parent at preparation time, so we wait until this stage to\n    // determine whether they are suppressed or not.\n    for ( const effect of this.allApplicableEffects() ) {\n      effect.determineSuppression();\n    }\n    return super.applyActiveEffects();\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\nallApplicableEffects() {\n    for ( const effect of super.allApplicableEffects() ) {\n      if ( effect.type === \"enchantment\" ) continue;\n      if ( effect.parent?.getFlag(\"dnd5e\", \"riders.effect\")?.includes(effect.id) ) continue;\n      yield effect;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  prepareDerivedData() {\n    const origin = this.getFlag(\"dnd5e\", \"summon.origin\");\n    // TODO: Replace with parseUuid once V11 support is dropped\n    if ( origin && this.token?.id ) dnd5e.registry.summons.track(origin.split(\".Item.\")[0], this.uuid);\n\n    if ( (this.system.modelProvider !== dnd5e) || (this.type === \"group\") ) return;\n    this.labels = {};\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCalculate the DC of a concentration save required for a given amount of damage.\n@param {number} damage  Amount of damage taken.\n@returns {number}       DC of the required concentration save.\n/\n  getConcentrationDC(damage) {\n    return Math.clamp(\n      Math.floor(damage / 2), 10, game.settings.get(\"dnd5e\", \"rulesVersion\") === \"modern\" ? 30 : Infinity\n    );\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nReturn the amount of experience required to gain a certain character level.\n@param {number} level  The desired level.\n@returns {number}      The XP required.\n/\n  getLevelExp(level) {\n    const levels = CONFIG.DND5E.CHARACTER_EXP_LEVELS;\n    return levels[Math.min(level, levels.length - 1)];\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nReturn the amount of experience granted by killing a creature of a certain CR.\n@param {number|null} cr  The creature's challenge rating.\n@returns {number|null}   The amount of experience granted per kill.\n/\n  getCRExp(cr) {\n    if ( cr === null ) return null;\n    if ( cr < 1.0 ) return Math.max(200 * cr, 10);\n    return CONFIG.DND5E.CR_EXP_LEVELS[cr] ?? Object.values(CONFIG.DND5E.CR_EXP_LEVELS).pop();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n@inheritdoc\n@param {object} [options]\n@param {boolean} [options.deterministic] Whether to force deterministic values for data properties that could be\n                                         either a die term or a flat term.\n/\n  getRollData({ deterministic=false }={}) {\n    let data;\n    if ( this.system.getRollData ) data = this.system.getRollData({ deterministic });\n    else data = {...super.getRollData()};\n    data.flags = {...this.flags};\n    data.name = this.name;\n    data.statuses = {};\n    for ( const status of this.statuses ) {\n      data.statuses[status] = status === \"exhaustion\" ? this.system.attributes?.exhaustion ?? 1 : 1;\n    }\n    return data;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this actor under the effect of this property from some status or due to its level of exhaustion?\n@param {string} key      A key in `DND5E.conditionEffects`.\n@returns {boolean}       Whether the actor is affected.\n/\n  hasConditionEffect(key) {\n    const props = CONFIG.DND5E.conditionEffects[key] ?? new Set();\n    const level = this.system.attributes?.exhaustion ?? null;\n    const imms = this.system.traits?.ci?.value ?? new Set();\n    const applyExhaustion = (level !== null) && !imms.has(\"exhaustion\")\n      && (game.settings.get(\"dnd5e\", \"rulesVersion\") === \"legacy\");\n    const statuses = this.statuses;\n    return props.some(k => {\n      const l = Number(k.split(\"-\").pop());\n      return (statuses.has(k) && !imms.has(k)) || (applyExhaustion && Number.isInteger(l) && (level >= l));\n    });\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /**\nPrepares data for a specific skill.\n@param {string} skillId    The id of the skill to prepare data for.\n@param {object} [options]  Additional options passed to {@link CreatureTemplate#prepareSkill}.\n@returns {SkillData}\n@internal\n/\n  _prepareSkill(skillId, options) {\n    return this.system.prepareSkill?.(skillId, options) ?? {};\n  }\n\n  /* -------------------------------------------- */\n  /*  Spellcasting Preparation                    */\n  /* -------------------------------------------- */\n\n  /**\nPrepare data related to the spell-casting capabilities of the Actor.\nMutates the value of the system.spells object. Must be called after final item preparation.\n@protected\n/\n  _prepareSpellcasting() {\n    if ( !this.system.spells ) return;\n\n    // Translate the list of classes into spellcasting progression\n    const progression = { slot: 0, pact: 0 };\n    const types = {};\n\n    // Grab all classes with spellcasting\n    const classes = this.itemTypes.class.filter(cls => {\n      const type = cls.spellcasting.type;\n      if ( !type ) return false;\n      types[type] ??= 0;\n      types[type] += 1;\n      return true;\n    });\n\n    for ( const cls of classes ) this.constructor.computeClassProgression(\n      progression, cls, { actor: this, count: types[cls.spellcasting.type] }\n    );\n\n    if ( this.type === \"npc\" ) {\n      if ( progression.slot || progression.pact ) {\n        this.system.attributes.spell.level = progression.slot || progression.pact;\n      } else progression.slot = this.system.attributes.spell.level ?? 0;\n    }\n\n    for ( const type of Object.keys(CONFIG.DND5E.spellcastingTypes) ) {\n      this.constructor.prepareSpellcastingSlots(this.system.spells, type, progression, { actor: this });\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nContribute to the actor's spellcasting progression.\n@param {object} progression                             Spellcasting progression data. *Will be mutated.*\n@param {Item5e} cls                                     Class for whom this progression is being computed.\n@param {object} [config={}]\n@param {Actor5e|null} [config.actor]                    Actor for whom the data is being prepared.\n@param {SpellcastingDescription} [config.spellcasting]  Spellcasting descriptive object.\n@param {number} [config.count=1]                        Number of classes with this type of spellcasting.\n/\n  static computeClassProgression(progression, cls, {actor, spellcasting, count=1}={}) {\n    const type = cls.spellcasting.type;\n    spellcasting = spellcasting ?? cls.spellcasting;\n\n    /**\nA hook event that fires while computing the spellcasting progression for each class on each actor.\nThe actual hook names include the spellcasting type (e.g. `dnd5e.computeLeveledProgression`).\n@param {object} progression                    Spellcasting progression data. *Will be mutated.*\n@param {Actor5e|null} [actor]                  Actor for whom the data is being prepared.\n@param {Item5e} cls                            Class for whom this progression is being computed.\n@param {SpellcastingDescription} spellcasting  Spellcasting descriptive object.\n@param {number} count                          Number of classes with this type of spellcasting.\n@returns {boolean}  Explicitly return false to prevent default progression from being calculated.\n@function dnd5e.computeSpellcastingProgression\n@memberof hookEvents\n/\n    const allowed = Hooks.call(\n      `dnd5e.compute${type.capitalize()}Progression`, progression, actor, cls, spellcasting, count\n    );\n\n    if ( allowed && (type === \"pact\") ) {\n      this.computePactProgression(progression, actor, cls, spellcasting, count);\n    } else if ( allowed && (type === \"leveled\") ) {\n      this.computeLeveledProgression(progression, actor, cls, spellcasting, count);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nContribute to the actor's spellcasting progression for a class with leveled spellcasting.\n@param {object} progression                    Spellcasting progression data. *Will be mutated.*\n@param {Actor5e} actor                         Actor for whom the data is being prepared.\n@param {Item5e} cls                            Class for whom this progression is being computed.\n@param {SpellcastingDescription} spellcasting  Spellcasting descriptive object.\n@param {number} count                          Number of classes with this type of spellcasting.\n/\n  static computeLeveledProgression(progression, actor, cls, spellcasting, count) {\n    const prog = CONFIG.DND5E.spellcastingTypes.leveled.progression[spellcasting.progression];\n    if ( !prog ) return;\n    const rounding = prog.roundUp ? Math.ceil : Math.floor;\n    progression.slot += rounding(spellcasting.levels / prog.divisor ?? 1);\n    // Single-classed, non-full progression rounds up, rather than down.\n    if ( (count === 1) && (prog.divisor > 1) && progression.slot ) {\n      progression.slot = Math.ceil(spellcasting.levels / prog.divisor);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nContribute to the actor's spellcasting progression for a class with pact spellcasting.\n@param {object} progression                    Spellcasting progression data. *Will be mutated.*\n@param {Actor5e} actor                         Actor for whom the data is being prepared.\n@param {Item5e} cls                            Class for whom this progression is being computed.\n@param {SpellcastingDescription} spellcasting  Spellcasting descriptive object.\n@param {number} count                          Number of classes with this type of spellcasting.\n/\n  static computePactProgression(progression, actor, cls, spellcasting, count) {\n    progression.pact += spellcasting.levels;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare actor's spell slots using progression data.\n@param {object} spells           The `data.spells` object within actor's data. *Will be mutated.*\n@param {string} type             Type of spellcasting slots being prepared.\n@param {object} progression      Spellcasting progression data.\n@param {object} [config]\n@param {Actor5e} [config.actor]  Actor for whom the data is being prepared.\n/\n  static prepareSpellcastingSlots(spells, type, progression, {actor}={}) {\n    /**\nA hook event that fires to convert the provided spellcasting progression into spell slots.\nThe actual hook names include the spellcasting type (e.g. `dnd5e.prepareLeveledSlots`).\n@param {object} spells        The `data.spells` object within actor's data. *Will be mutated.*\n@param {Actor5e} actor        Actor for whom the data is being prepared.\n@param {object} progression   Spellcasting progression data.\n@returns {boolean}            Explicitly return false to prevent default preparation from being performed.\n@function dnd5e.prepareSpellcastingSlots\n@memberof hookEvents\n/\n    const allowed = Hooks.call(`dnd5e.prepare${type.capitalize()}Slots`, spells, actor, progression);\n\n    if ( allowed && (type === \"pact\") ) this.preparePactSlots(spells, actor, progression);\n    else if ( allowed && (type === \"leveled\") ) this.prepareLeveledSlots(spells, actor, progression);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare leveled spell slots using progression data.\n@param {object} spells        The `data.spells` object within actor's data. *Will be mutated.*\n@param {Actor5e} actor        Actor for whom the data is being prepared.\n@param {object} progression   Spellcasting progression data.\n/\n  static prepareLeveledSlots(spells, actor, progression) {\n    const levels = Math.clamp(progression.slot, 0, CONFIG.DND5E.maxLevel);\n    const slots = CONFIG.DND5E.SPELL_SLOT_TABLE[Math.min(levels, CONFIG.DND5E.SPELL_SLOT_TABLE.length) - 1] ?? [];\n    for ( const level of Array.fromRange(Object.keys(CONFIG.DND5E.spellLevels).length - 1, 1) ) {\n      const slot = spells[`spell${level}`] ??= { value: 0 };\n      slot.label = CONFIG.DND5E.spellLevels[level];\n      slot.level = level;\n      slot.max = Number.isNumeric(slot.override) ? Math.max(parseInt(slot.override), 0) : slots[level - 1] ?? 0;\n      slot.type = \"leveled\";\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare non-leveled spell slots using progression data.\n@param {object} spells        The `data.spells` object within actor's data. *Will be mutated.*\n@param {Actor5e} actor        Actor for whom the data is being prepared.\n@param {object} progression   Spellcasting progression data.\n@param {string} key           The internal key for these spell slots on the actor.\n@param {object} table         The table used for determining the progression of slots.\n/\n  static prepareAltSlots(spells, actor, progression, key, table) {\n    // Spell data:\n    // - x.level: Slot level for casting\n    // - x.max: Total number of slots\n    // - x.value: Currently available slots\n    // - x.override: Override number of available spell slots\n\n    let keyLevel = Math.clamp(progression[key], 0, CONFIG.DND5E.maxLevel);\n    spells[key] ??= {};\n    spells[key].type = key;\n    const override = Number.isNumeric(spells[key].override) ? parseInt(spells[key].override) : null;\n\n    // Slot override\n    if ( (keyLevel === 0) && (actor.type === \"npc\") && (override !== null) ) {\n      keyLevel = actor.system.attributes.spell.level;\n    }\n\n    const [, keyConfig] = Object.entries(table).reverse().find(([l]) => Number(l) <= keyLevel) ?? [];\n    if ( keyConfig ) {\n      spells[key].level = keyConfig.level;\n      if ( override === null ) spells[key].max = keyConfig.slots;\n      else spells[key].max = Math.max(override, 1);\n      spells[key].value = Math.min(spells[key].value, spells[key].max);\n    }\n\n    else {\n      spells[key].max = override || 0;\n      spells[key].level = (spells[key].max > 0) ? 1 : 0;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConvenience method for preparing pact slots specifically.\n@param {object} spells        The `data.spells` object within actor's data. *Will be mutated.*\n@param {Actor5e} actor        Actor for whom the data is being prepared.\n@param {object} progression   Spellcasting progression data.\n/\n  static preparePactSlots(spells, actor, progression) {\n    this.prepareAltSlots(spells, actor, progression, \"pact\", CONFIG.DND5E.pactCastingProgression);\n    spells.pact.label = game.i18n.localize(\"DND5E.PactMagic\");\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Handlers                              */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _preCreate(data, options, user) {\n    if ( (await super._preCreate(data, options, user)) === false ) return false;\n\n    const sourceId = this._stats?.compendiumSource;\n    if ( sourceId?.startsWith(\"Compendium.\") ) return;\n\n    // Configure prototype token settings\n    const prototypeToken = {};\n    if ( \"size\" in (this.system.traits || {}) ) {\n      const size = CONFIG.DND5E.actorSizes[this.system.traits.size || \"med\"].token ?? 1;\n      if ( !foundry.utils.hasProperty(data, \"prototypeToken.width\") ) prototypeToken.width = size;\n      if ( !foundry.utils.hasProperty(data, \"prototypeToken.height\") ) prototypeToken.height = size;\n    }\n    if ( this.type === \"character\" ) Object.assign(prototypeToken, {\n      sight: { enabled: true }, actorLink: true, disposition: CONST.TOKEN_DISPOSITIONS.FRIENDLY\n    });\n    this.updateSource({ prototypeToken });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _preUpdate(changed, options, user) {\n    if ( (await super._preUpdate(changed, options, user)) === false ) return false;\n\n    // Apply changes in Actor size to Token width/height\n    if ( \"size\" in (this.system.traits || {}) ) {\n      const newSize = foundry.utils.getProperty(changed, \"system.traits.size\");\n      if ( newSize && (newSize !== this.system.traits?.size) ) {\n        let size = CONFIG.DND5E.actorSizes[newSize].token ?? 1;\n        if ( !foundry.utils.hasProperty(changed, \"prototypeToken.width\") ) {\n          changed.prototypeToken ||= {};\n          changed.prototypeToken.height = size;\n          changed.prototypeToken.width = size;\n        }\n      }\n    }\n\n    // Reset death save counters and store hp\n    if ( \"hp\" in (this.system.attributes || {}) ) {\n      const isDead = this.system.attributes.hp.value <= 0;\n      if ( isDead && (foundry.utils.getProperty(changed, \"system.attributes.hp.value\") > 0) ) {\n        foundry.utils.setProperty(changed, \"system.attributes.death.success\", 0);\n        foundry.utils.setProperty(changed, \"system.attributes.death.failure\", 0);\n      }\n      foundry.utils.setProperty(options, \"dnd5e.hp\", { ...this.system.attributes.hp });\n    }\n\n    // Record previous exhaustion level.\n    if ( Number.isFinite(foundry.utils.getProperty(changed, \"system.attributes.exhaustion\")) ) {\n      foundry.utils.setProperty(options, \"dnd5e.originalExhaustion\", this.system.attributes.exhaustion);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAssign a class item as the original class for the Actor based on which class has the most levels.\n@returns {Promise<Actor5e>}  Instance of the updated actor.\n@protected\n/\n  _assignPrimaryClass() {\n    const classes = this.itemTypes.class.sort((a, b) => b.system.levels - a.system.levels);\n    const newPC = classes[0]?.id || \"\";\n    return this.update({\"system.details.originalClass\": newPC});\n  }\n\n  /* -------------------------------------------- */\n  /*  Gameplay Mechanics                          */\n  /* -------------------------------------------- */\n\n  /** @override */\n  async modifyTokenAttribute(attribute, value, isDelta, isBar) {\n    if ( attribute === \"attributes.hp\" ) {\n      const hp = this.system.attributes.hp;\n      const delta = isDelta ? (-1 * value) : (hp.value + hp.temp) - value;\n      return this.applyDamage(delta);\n    } else if ( attribute.startsWith(\".\") ) {\n      const item = fromUuidSync(attribute, { relative: this });\n      let newValue = item?.system.uses?.value ?? 0;\n      if ( isDelta ) newValue += value;\n      else newValue = value;\n      return item?.update({ \"system.uses.spent\": item.system.uses.max - newValue });\n    }\n    return super.modifyTokenAttribute(attribute, value, isDelta, isBar);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDescription of a source of damage.\n@typedef {object} DamageDescription\n@property {number} value            Amount of damage.\n@property {string} type             Type of damage.\n@property {Set<string>} properties  Physical properties that affect damage application.\n@property {object} [active]\n@property {number} [active.multiplier]      Final calculated multiplier.\n@property {boolean} [active.modifications]  Did modification affect this description?\n@property {boolean} [active.resistance]     Did resistance affect this description?\n@property {boolean} [active.vulnerability]  Did vulnerability affect this description?\n@property {boolean} [active.immunity]       Did immunity affect this description?\n/\n\n  /**\nOptions for damage application.\n@typedef {object} DamageApplicationOptions\n@property {boolean|Set<string>} [downgrade]  Should this actor's resistances and immunities be downgraded by one\n                                             step? A set of damage types to be downgraded or `true` to downgrade\n                                             all damage types.\n@property {number} [multiplier=1]         Amount by which to multiply all damage.\n@property {object|boolean} [ignore]       Set to `true` to ignore all damage modifiers. If set to an object, then\n                                          values can either be `true` to indicate that the all modifications of\n                                          that type should be ignored, or a set of specific damage types for which\n                                          it should be ignored.\n@property {boolean|Set<string>} [ignore.immunity]       Should this actor's damage immunity be ignored?\n@property {boolean|Set<string>} [ignore.resistance]     Should this actor's damage resistance be ignored?\n@property {boolean|Set<string>} [ignore.vulnerability]  Should this actor's damage vulnerability be ignored?\n@property {boolean|Set<string>} [ignore.modification]   Should this actor's damage modification be ignored?\n@property {boolean} [invertHealing=true]  Automatically invert healing types to it heals, rather than damages.\n@property {\"damage\"|\"healing\"} [only]     Apply only damage or healing parts. Untyped rolls will always be applied.\n/\n\n  /**\nApply a certain amount of damage or healing to the health pool for Actor\n@param {DamageDescription[]|number} damages     Damages to apply.\n@param {DamageApplicationOptions} [options={}]  Damage application options.\n@returns {Promise<Actor5e>}                     A Promise which resolves once the damage has been applied.\n/\n  async applyDamage(damages, options={}) {\n    const hp = this.system.attributes.hp;\n    if ( !hp ) return this; // Group actors don't have HP at the moment\n\n    if ( Number.isNumeric(damages) ) {\n      damages = [{ value: damages }];\n      options.ignore ??= true;\n    }\n\n    damages = this.calculateDamage(damages, options);\n    if ( !damages ) return this;\n\n    // Round damage towards zero\n    let { amount, temp } = damages.reduce((acc, d) => {\n      if ( d.type === \"temphp\" ) acc.temp += d.value;\n      else acc.amount += d.value;\n      return acc;\n    }, { amount: 0, temp: 0 });\n    amount = amount > 0 ? Math.floor(amount) : Math.ceil(amount);\n\n    const deltaTemp = amount > 0 ? Math.min(hp.temp, amount) : 0;\n    const deltaHP = Math.clamp(amount - deltaTemp, -hp.damage, hp.value);\n    const updates = {\n      \"system.attributes.hp.temp\": hp.temp - deltaTemp,\n      \"system.attributes.hp.value\": hp.value - deltaHP\n    };\n\n    if ( temp > updates[\"system.attributes.hp.temp\"] ) updates[\"system.attributes.hp.temp\"] = temp;\n\n    /**\nA hook event that fires before damage is applied to an actor.\n@param {Actor5e} actor                     Actor the damage will be applied to.\n@param {number} amount                     Amount of damage that will be applied.\n@param {object} updates                    Distinct updates to be performed on the actor.\n@param {DamageApplicationOptions} options  Additional damage application options.\n@returns {boolean}                         Explicitly return `false` to prevent damage application.\n@function dnd5e.preApplyDamage\n@memberof hookEvents\n/\n    if ( Hooks.call(\"dnd5e.preApplyDamage\", this, amount, updates, options) === false ) return this;\n\n    // Delegate damage application to a hook\n    // TODO: Replace this in the future with a better modifyTokenAttribute function in the core\n    if ( Hooks.call(\"modifyTokenAttribute\", {\n      attribute: \"attributes.hp\",\n      value: amount,\n      isDelta: false,\n      isBar: true\n    }, updates) === false ) return this;\n\n    await this.update(updates);\n\n    /**\nA hook event that fires after damage has been applied to an actor.\n@param {Actor5e} actor                     Actor that has been damaged.\n@param {number} amount                     Amount of damage that has been applied.\n@param {DamageApplicationOptions} options  Additional damage application options.\n@function dnd5e.applyDamage\n@memberof hookEvents\n/\n    Hooks.callAll(\"dnd5e.applyDamage\", this, amount, options);\n\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCalculate the damage that will be applied to this actor.\n@param {DamageDescription[]} damages            Damages to calculate.\n@param {DamageApplicationOptions} [options={}]  Damage calculation options.\n@returns {DamageDescription[]|false}            New damage descriptions with changes applied, or `false` if the\n                                                calculation was canceled.\n/\n  calculateDamage(damages, options={}) {\n    damages = foundry.utils.deepClone(damages);\n\n    /**\nA hook event that fires before damage amount is calculated for an actor.\n@param {Actor5e} actor                     The actor being damaged.\n@param {DamageDescription[]} damages       Damage descriptions.\n@param {DamageApplicationOptions} options  Additional damage application options.\n@returns {boolean}                         Explicitly return `false` to prevent damage application.\n@function dnd5e.preCalculateDamage\n@memberof hookEvents\n/\n    if ( Hooks.call(\"dnd5e.preCalculateDamage\", this, damages, options) === false ) return false;\n\n    const multiplier = options.multiplier ?? 1;\n\n    const downgrade = type => options.downgrade === true || options.downgrade?.has?.(type);\n    const ignore = (category, type, skipDowngrade) => {\n      return options.ignore === true\n        || options.ignore?.[category] === true\n        || options.ignore?.[category]?.has?.(type)\n        || ((category === \"immunity\") && downgrade(type) && !skipDowngrade)\n        || ((category === \"resistance\") && downgrade(type) && !hasEffect(\"di\", type));\n    };\n\n    const traits = this.system.traits ?? {};\n    const hasEffect = (category, type, properties) => {\n      if ( (category === \"dr\") && downgrade(type) && hasEffect(\"di\", type, properties)\n        && !ignore(\"immunity\", type, true) ) return true;\n      const config = traits[category];\n      if ( !config?.value.has(type) ) return false;\n      if ( !CONFIG.DND5E.damageTypes[type]?.isPhysical || !properties?.size ) return true;\n      return !config.bypasses?.intersection(properties)?.size;\n    };\n\n    const skipped = type => {\n      if ( options.only === \"damage\" ) return type in CONFIG.DND5E.healingTypes;\n      if ( options.only === \"healing\" ) return type in CONFIG.DND5E.damageTypes;\n      return false;\n    };\n\n    const rollData = this.getRollData({deterministic: true});\n\n    damages.forEach(d => {\n      d.active ??= {};\n\n      // Skip damage types with immunity\n      if ( skipped(d.type) || (!ignore(\"immunity\", d.type) && hasEffect(\"di\", d.type, d.properties)) ) {\n        d.value = 0;\n        d.active.multiplier = 0;\n        d.active.immunity = true;\n        return;\n      }\n\n      // Apply type-specific damage reduction\n      if ( !ignore(\"modification\", d.type) && traits.dm?.amount[d.type]\n        && !traits.dm.bypasses.intersection(d.properties).size ) {\n        const modification = simplifyBonus(traits.dm.amount[d.type], rollData);\n        if ( Math.sign(d.value) !== Math.sign(d.value + modification) ) d.value = 0;\n        else d.value += modification;\n        d.active.modification = true;\n      }\n\n      let damageMultiplier = multiplier;\n\n      // Apply type-specific damage resistance\n      if ( !ignore(\"resistance\", d.type) && hasEffect(\"dr\", d.type, d.properties) ) {\n        damageMultiplier /= 2;\n        d.active.resistance = true;\n      }\n\n      // Apply type-specific damage vulnerability\n      if ( !ignore(\"vulnerability\", d.type) && hasEffect(\"dv\", d.type, d.properties) ) {\n        damageMultiplier *= 2;\n        d.active.vulnerability = true;\n      }\n\n      // Negate healing types\n      if ( (options.invertHealing !== false) && (d.type === \"healing\") ) damageMultiplier *= -1;\n\n      d.value = d.value * damageMultiplier;\n      d.active.multiplier = (d.active.multiplier ?? 1) * damageMultiplier;\n    });\n\n    /**\nA hook event that fires after damage values are calculated for an actor.\n@param {Actor5e} actor                     The actor being damaged.\n@param {DamageDescription[]} damages       Damage descriptions.\n@param {DamageApplicationOptions} options  Additional damage application options.\n@returns {boolean}                         Explicitly return `false` to prevent damage application.\n@function dnd5e.calculateDamage\n@memberof hookEvents\n/\n    if ( Hooks.call(\"dnd5e.calculateDamage\", this, damages, options) === false ) return false;\n\n    return damages;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nApply a certain amount of temporary hit point, but only if it's more than the actor currently has.\n@param {number} amount       An amount of temporary hit points to set\n@returns {Promise<Actor5e>}  A Promise which resolves once the temp HP has been applied\n/\n  async applyTempHP(amount=0) {\n    amount = parseInt(amount);\n    const hp = this.system.attributes.hp;\n\n    // Update the actor if the new amount is greater than the current\n    const tmp = parseInt(hp.temp) || 0;\n    return amount > tmp ? this.update({\"system.attributes.hp.temp\": amount}) : this;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nGet a color used to represent the current hit points of an Actor.\n@param {number} current        The current HP value\n@param {number} max            The maximum HP value\n@returns {Color}               The color used to represent the HP percentage\n/\n  static getHPColor(current, max) {\n    const pct = Math.clamp(current, 0, max) / max;\n    return Color.fromRGB([(1-(pct/2)), pct, 0]);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nInitiate concentration on an item.\n@param {Activity} activity                  The activity on which to being concentration.\n@param {object} [effectData]                Effect data to merge into the created effect.\n@returns {Promise<ActiveEffect5e|void>}     A promise that resolves to the created effect.\n/\n  async beginConcentrating(activity, effectData={}) {\n    if ( activity instanceof Item ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `beginConcentrating` method on Actor5e now takes an Activity, rather than an Item.\",\n        { since: \"DnD5e 4.0\", until: \"DnD5e 4.4\" }\n      );\n      activity = activity.system.activities?.contents[0];\n      if ( !activity ) return;\n    }\n\n    effectData = ActiveEffect5e.createConcentrationEffectData(activity, effectData);\n\n    /**\nA hook that is called before a concentration effect is created.\n@function dnd5e.preBeginConcentrating\n@memberof hookEvents\n@param {Actor5e} actor         The actor initiating concentration.\n@param {Item5e} item           The item that will be concentrated on.\n@param {object} effectData     Data used to create the ActiveEffect.\n@param {Activity} activity     The activity that triggered the concentration.\n@returns {boolean}             Explicitly return false to prevent the effect from being created.\n/\n    if ( Hooks.call(\"dnd5e.preBeginConcentrating\", this, activity.item, effectData, activity) === false ) return;\n\n    const effect = await ActiveEffect5e.create(effectData, { parent: this });\n\n    /**\nA hook that is called after a concentration effect is created.\n@function dnd5e.createConcentrating\n@memberof hookEvents\n@param {Actor5e} actor             The actor initiating concentration.\n@param {Item5e} item               The item that is being concentrated on.\n@param {ActiveEffect5e} effect     The created ActiveEffect instance.\n@param {Activity} activity         The activity that triggered the concentration.\n/\n    Hooks.callAll(\"dnd5e.beginConcentrating\", this, activity.item, effect, activity);\n\n    return effect;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEnd concentration on an item.\n@param {Item5e|ActiveEffect5e|string} [target]    An item or effect to end concentration on, or id of an effect.\n                                                  If not provided, all maintained effects are removed.\n@returns {Promise<ActiveEffect5e[]>}              A promise that resolves to the deleted effects.\n/\n  async endConcentration(target) {\n    let effect;\n    const { effects } = this.concentration;\n\n    if ( !target ) {\n      return effects.reduce(async (acc, effect) => {\n        acc = await acc;\n        return acc.concat(await this.endConcentration(effect));\n      }, []);\n    }\n\n    if ( foundry.utils.getType(target) === \"string\" ) effect = effects.find(e => e.id === target);\n    else if ( target instanceof ActiveEffect5e ) effect = effects.has(target) ? target : null;\n    else if ( target instanceof Item5e ) {\n      effect = effects.find(e => {\n        const data = e.getFlag(\"dnd5e\", \"item\") ?? {};\n        return (data.id === target._id) || (data.data?._id === target._id);\n      });\n    }\n    if ( !effect ) return [];\n\n    /**\nA hook that is called before a concentration effect is deleted.\n@function dnd5e.preEndConcentration\n@memberof hookEvents\n@param {Actor5e} actor             The actor ending concentration.\n@param {ActiveEffect5e} effect     The ActiveEffect that will be deleted.\n@returns {boolean}                 Explicitly return false to prevent the effect from being deleted.\n/\n    if ( Hooks.call(\"dnd5e.preEndConcentration\", this, effect) === false) return [];\n\n    await effect.delete();\n\n    /**\nA hook that is called after a concentration effect is deleted.\n@function dnd5e.endConcentration\n@memberof hookEvents\n@param {Actor5e} actor             The actor ending concentration.\n@param {ActiveEffect5e} effect     The ActiveEffect that was deleted.\n/\n    Hooks.callAll(\"dnd5e.endConcentration\", this, effect);\n\n    return [effect];\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreate a chat message for this actor with a prompt to challenge concentration.\n@param {object} [options]\n@param {number} [options.dc]         The target value of the saving throw.\n@param {string} [options.ability]    An ability to use instead of the default.\n@returns {Promise<ChatMessage5e>}    A promise that resolves to the created chat message.\n/\n  async challengeConcentration({ dc=10, ability=null }={}) {\n    const isConcentrating = this.concentration.effects.size > 0;\n    if ( !isConcentrating ) return null;\n\n    const dataset = {\n      action: \"concentration\",\n      dc: dc\n    };\n    if ( ability in CONFIG.DND5E.abilities ) dataset.ability = ability;\n\n    const config = {\n      type: \"concentration\",\n      format: \"short\",\n      icon: true\n    };\n\n    return ChatMessage.implementation.create({\n      content: await renderTemplate(\"systems/dnd5e/templates/chat/request-card.hbs\", {\n        buttons: [{\n          dataset: { ...dataset, type: \"concentration\", visbility: \"all\" },\n          buttonLabel: createRollLabel({ ...dataset, ...config }),\n          hiddenLabel: createRollLabel({ ...dataset, ...config, hideDC: true })\n        }]\n      }),\n      whisper: game.users.filter(user => this.testUserPermission(user, \"OWNER\")),\n      speaker: ChatMessage.implementation.getSpeaker({ actor: this })\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDetermine whether the provided ability is usable for remarkable athlete.\n@param {string} ability  Ability type to check.\n@returns {boolean}       Whether the actor has the remarkable athlete flag and the ability is physical.\n@private\n/\n  _isRemarkableAthlete(ability) {\n    return (game.settings.get(\"dnd5e\", \"rulesVersion\") === \"legacy\") && this.getFlag(\"dnd5e\", \"remarkableAthlete\")\n      && CONFIG.DND5E.characterFlags.remarkableAthlete.abilities.includes(ability);\n  }\n\n  /* -------------------------------------------- */\n  /*  Rolling                                     */\n  /* -------------------------------------------- */\n\n  /**\nAdd the reduction to this roll from exhaustion if using the modern rules.\n@param {string[]} parts  Roll parts.\n@param {object} data     Roll data.\n/\n  addRollExhaustion(parts, data) {\n    if ( (game.settings.get(\"dnd5e\", \"rulesVersion\") !== \"modern\") || !this.system.attributes?.exhaustion ) return;\n    const amount = this.system.attributes.exhaustion * (CONFIG.DND5E.conditionTypes.exhaustion?.reduction?.rolls ?? 0);\n    if ( amount ) {\n      parts.push(\"@exhaustion\");\n      data.exhaustion = -amount;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRoll an ability check with a skill.\n@param {Partial<SkillToolRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<SkillToolRollDialogConfiguration>} dialog   Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message     Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}                          A Promise which resolves to the created Roll instance.\n/\n  async rollSkill(config={}, dialog={}, message={}) {\n    const skillLabel = CONFIG.DND5E.skills[config.skill]?.label ?? \"\";\n    const ability = this.system.skills[config.skill]?.ability ?? CONFIG.DND5E.skills[config.skill]?.ability ?? \"\";\n    const abilityLabel = CONFIG.DND5E.abilities[ability]?.label ?? \"\";\n    const dialogConfig = foundry.utils.mergeObject({\n      options: {\n        window: {\n          title: game.i18n.format(\"DND5E.SkillPromptTitle\", { skill: skillLabel, ability: abilityLabel }),\n          subtitle: this.name\n        }\n      }\n    }, dialog);\n    return this.#rollSkillTool(\"skill\", config, dialogConfig, message);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRoll an ability check with a tool.\n@param {Partial<SkillToolRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<SkillToolRollDialogConfiguration>} dialog   Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message     Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}                          A Promise which resolves to the created Roll instance.\n/\n  async rollToolCheck(config={}, dialog={}, message={}) {\n    const toolLabel = Trait.keyLabel(config.tool, { trait: \"tool\" }) ?? \"\";\n    const dialogConfig = foundry.utils.mergeObject({\n      options: {\n        window: {\n          title: game.i18n.format(\"DND5E.ToolPromptTitle\", { tool: toolLabel }),\n          subtitle: this.name\n        }\n      }\n    }, dialog);\n    return this.#rollSkillTool(\"tool\", config, dialogConfig, message);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n@typedef {D20RollProcessConfiguration} SkillToolRollProcessConfiguration\n@property {string} [ability]  The ability to be rolled with the skill.\n@property {string} [bonus]    Additional bonus term added to the check.\n@property {Item5e} [item]     Tool item used for rolling.\n@property {string} [skill]    The skill to roll.\n@property {string} [tool]     The tool to roll.\n/\n\n  /**\n@typedef {BasicRollDialogConfiguration} SkillToolRollDialogConfiguration\n@property {SkillToolRollConfigurationDialogOptions} [options]  Configuration options.\n/\n\n  /**\nShared rolling functionality between skill & tool checks.\n@param {\"skill\"|\"tool\"} type                                Type of roll.\n@param {Partial<SkillToolRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<SkillToolRollDialogConfiguration>} dialog   Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message     Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}                          A Promise which resolves to the created Roll instance.\n/\n  async #rollSkillTool(type, config={}, dialog={}, message={}) {\n    let oldFormat = false;\n    const name = type === \"skill\" ? \"Skill\" : \"ToolCheck\";\n\n    // Handle deprecated calling pattern\n    if ( foundry.utils.getType(config) !== \"Object\" ) {\n      foundry.utils.logCompatibilityWarning(\n        `The \\`roll${name}\\` method on Actor5e now takes roll, dialog, and message config objects as parameters.`,\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      oldFormat = true;\n      const oldConfig = dialog;\n      config = { [type]: config };\n      if ( oldConfig.ability ) config.ability = oldConfig.ability;\n      if ( oldConfig.bonus ) config.bonus = oldConfig.bonus;\n      dialog = {};\n      _applyDeprecatedD20Configs(config, dialog, message, oldConfig);\n    }\n\n    const skillConfig = CONFIG.DND5E.skills[config.skill];\n    const toolConfig = CONFIG.DND5E.tools[config.tool];\n    if ( ((type === \"skill\") && !skillConfig) || ((type === \"tool\") && !toolConfig) ) {\n      return this.rollAbilityTest(config, dialog, message);\n    }\n\n    const relevant = type === \"skill\" ? this.system.skills?.[config.skill] : this.system.tools?.[config.tool];\n    const buildConfig = this._buildSkillToolConfig.bind(this, type);\n\n    const rollConfig = foundry.utils.mergeObject({\n      ability: relevant?.ability ?? (type === \"skill\" ? skillConfig.ability : toolConfig.ability),\n      advantage: relevant?.roll.mode === CONFIG.Dice.D20Roll.ADV_MODE.ADVANTAGE,\n      disadvantage: relevant?.roll.mode === CONFIG.Dice.D20Roll.ADV_MODE.DISADVANTAGE,\n      halflingLucky: this.getFlag(\"dnd5e\", \"halflingLucky\"),\n      reliableTalent: (relevant?.value >= 1) && this.getFlag(\"dnd5e\", \"reliableTalent\")\n    }, config);\n    rollConfig.hookNames = [...(config.hookNames ?? []), type, \"abilityCheck\", \"d20Test\"];\n    rollConfig.rolls = [BasicRoll.mergeConfigs({\n      options: {\n        maximum: relevant?.roll.max,\n        minimum: relevant?.roll.min\n      }\n    }, config.rolls?.shift())].concat(config.rolls ?? []);\n    rollConfig.subject = this;\n\n    const dialogConfig = foundry.utils.mergeObject({\n      applicationClass: SkillToolRollConfigurationDialog,\n      options: {\n        buildConfig,\n        chooseAbility: true\n      }\n    }, dialog);\n\n    const abilityLabel = CONFIG.DND5E.abilities[relevant?.ability ?? skillConfig?.ability ?? \"\"]?.label;\n\n    const messageConfig = foundry.utils.mergeObject({\n      create: true,\n      data: {\n        flags: {\n          dnd5e: {\n            messageType: \"roll\",\n            roll: {\n              [`${type}Id`]: config[type],\n              type\n            }\n          }\n        },\n        flavor: type === \"skill\"\n          ? game.i18n.format(\"DND5E.SkillPromptTitle\", { skill: skillConfig.label, ability: abilityLabel })\n          : game.i18n.format(\"DND5E.ToolPromptTitle\", { tool: Trait.keyLabel(config.tool, { trait: \"tool\" }) ?? \"\" }),\n        speaker: ChatMessage.getSpeaker({ actor: this })\n      }\n    }, message);\n\n    if ( `dnd5e.preRoll${name}` in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        `The \\`dnd5e.preRoll${name}\\` hook has been deprecated and replaced with \\`dnd5e.preRoll${type.capitalize()}V2\\`.`,\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      const oldConfig = _createDeprecatedD20Config(rollConfig, dialogConfig, messageConfig);\n      if ( Hooks.call(`dnd5e.preRoll${name}`, this, oldConfig, config.skill) === false ) return null;\n      _applyDeprecatedD20Configs(rollConfig, dialogConfig, messageConfig, oldConfig);\n    }\n\n    const rolls = await CONFIG.Dice.D20Roll.build(rollConfig, dialogConfig, messageConfig);\n    if ( !rolls.length ) return null;\n\n    /**\nA hook event that fires after a skill or tool check has been rolled.\n@function dnd5e.rollSkillV2\n@function dnd5e.rollToolCheckV2\n@memberof hookEvents\n@param {D20Roll[]} rolls       The resulting rolls.\n@param {object} data\n@param {string} [data.skill]   ID of the skill that was rolled as defined in `CONFIG.DND5E.skills`.\n@param {string} [data.tool]    ID of the tool that was rolled as defined in `CONFIG.DND5E.tools`.\n@param {Actor5e} data.subject  Actor for which the roll has been performed.\n/\n    Hooks.callAll(`dnd5e.roll${name}V2`, rolls, { [type]: config[type], subject: this });\n\n    if ( `dnd5e.roll${name}` in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        `The \\`dnd5e.roll${name}\\` hook has been deprecated and replaced with \\`dnd5e.roll${type.capitalize()}V2\\`.`,\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      Hooks.callAll(`dnd5e.roll${name}`, this, rolls[0], config.skill);\n    }\n\n    return oldFormat ? rolls[0] : rolls;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConfigure a roll config for each roll performed as part of the skill or tool check process. Will be called once\nper roll in the process each time an option is changed in the roll configuration interface.\n@param {\"skill\"|\"tool\"} type                          Type of roll.\n@param {D20RollProcessConfiguration} process          Configuration for the entire rolling process.\n@param {D20RollConfiguration} config                  Configuration for a specific roll.\n@param {FormDataExtended} [formData]                  Any data entered into the rolling prompt.\n@param {number} index                                 Index of the roll within all rolls being prepared.\n/\n  _buildSkillToolConfig(type, process, config, formData, index) {\n    const relevant = type === \"skill\" ? this.system.skills?.[process.skill] : this.system.tools?.[process.tool];\n    const rollData = this.getRollData();\n    const abilityId = formData?.get(\"ability\") ?? process.ability;\n    const ability = this.system.abilities?.[abilityId];\n    const prof = this.system.calculateAbilityCheckProficiency(relevant?.effectValue ?? 0, abilityId);\n\n    let { parts, data } = CONFIG.Dice.BasicRoll.constructParts({\n      mod: ability?.mod,\n      prof: prof?.hasProficiency ? prof.term : null,\n      [`${config[type]}Bonus`]: relevant?.bonuses?.check,\n      extraBonus: process.bonus,\n      [`${abilityId}CheckBonus`]: ability?.bonuses?.check,\n      [`${type}Bonus`]: this.system.bonuses?.abilities?.[type],\n      abilityCheckBonus: this.system.bonuses?.abilities?.check\n    }, { ...rollData });\n\n    // Add exhaustion reduction\n    this.addRollExhaustion(parts, data);\n\n    config.parts = [...(config.parts ?? []), ...parts];\n    config.data = { ...data, ...(config.data ?? {}) };\n    config.data.abilityId = abilityId;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRoll a generic ability test or saving throw.\nPrompt the user for input on which variety of roll they want to do.\n@param {Partial<AbilityRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<BasicRollDialogConfiguration>} dialog     Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message   Configuration for the roll message.\n/\n  rollAbility(config={}, dialog={}, message={}) {\n    let abilityId = config;\n    if ( foundry.utils.getType(config) === \"Object\" ) abilityId = config.ability;\n    else foundry.utils.logCompatibilityWarning(\n      \"The `rollAbility` method on Actor5e now takes roll, dialog, and message config objects as parameters.\",\n      { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n    );\n    const label = CONFIG.DND5E.abilities[abilityId]?.label ?? \"\";\n    new Dialog({\n      title: `${game.i18n.format(\"DND5E.AbilityPromptTitle\", { ability: label })}: ${this.name}`,\n      content: `<p>${game.i18n.format(\"DND5E.AbilityPromptText\", { ability: label })}</p>`,\n      buttons: {\n        test: {\n          label: game.i18n.localize(\"DND5E.ActionAbil\"),\n          callback: () => this.rollAbilityCheck(config, dialog, message)\n        },\n        save: {\n          label: game.i18n.localize(\"DND5E.ActionSave\"),\n          callback: () => this.rollSavingThrow(config, dialog, message)\n        }\n      }\n    }).render(true);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRoll an Ability Check.\n@param {Partial<AbilityRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<BasicRollDialogConfiguration>} dialog     Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message   Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}                        A Promise which resolves to the created Roll instance.\n/\n  async rollAbilityCheck(config={}, dialog={}, message={}) {\n    const abilityLabel = CONFIG.DND5E.abilities[config.ability]?.label ?? \"\";\n    const dialogConfig = foundry.utils.mergeObject({\n      options: {\n        window: {\n          title: game.i18n.format(\"DND5E.AbilityPromptTitle\", { ability: abilityLabel }),\n          subtitle: this.name\n        }\n      }\n    }, dialog);\n    return this.#rollD20Test(\"check\", config, dialogConfig, message);\n  }\n\n  /**\nRoll an Ability Test.\n@param {Partial<AbilityRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<BasicRollDialogConfiguration>} dialog     Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message   Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}                        A Promise which resolves to the created Roll instance.\n/\n  async rollAbilityTest(config={}, dialog={}, message={}) {\n    foundry.utils.logCompatibilityWarning(\n      \"The `rollAbilityTest` method on Actor5e has been renamed `rollAbilityCheck`.\",\n      { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n    );\n    return this.rollAbilityCheck(config, dialog, message);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRoll a Saving Throw.\n@param {Partial<AbilityRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<BasicRollDialogConfiguration>} dialog     Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message   Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}                        A Promise which resolves to the created Roll instances.\n/\n  async rollSavingThrow(config={}, dialog={}, message={}) {\n    const abilityLabel = CONFIG.DND5E.abilities[config.ability]?.label ?? \"\";\n    const dialogConfig = foundry.utils.mergeObject({\n      options: {\n        window: {\n          title: game.i18n.format(\"DND5E.SavePromptTitle\", { ability: abilityLabel }),\n          subtitle: this.name\n        }\n      }\n    }, dialog);\n    return this.#rollD20Test(\"save\", config, dialogConfig, message);\n  }\n\n  /**\nRoll an Ability Saving Throw.\n@param {Partial<AbilityRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<BasicRollDialogConfiguration>} dialog     Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message   Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}                        A Promise which resolves to the created Roll instances.\n/\n  async rollAbilitySave(config={}, dialog={}, message={}) {\n    foundry.utils.logCompatibilityWarning(\n      \"The `rollAbilitySave` method on Actor5e has been renamed `rollSavingThrow`.\",\n      { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n    );\n    return this.rollSavingThrow(config, dialog, message);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n@typedef {D20RollProcessConfiguration} AbilityRollProcessConfiguration\n@property {string} [ability]  ID of the ability to roll as found in `CONFIG.DND5E.abilities`.\n/\n\n  /**\nShared rolling functionality between ability checks & saving throws.\n@param {\"check\"|\"save\"} type                     D20 test type.\n@param {Partial<AbilityRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<BasicRollDialogConfiguration>} dialog     Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message   Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}               A Promise which resolves to the created Roll instance.\n/\n  async #rollD20Test(type, config={}, dialog={}, message={}) {\n    let oldFormat = false;\n    const name = type === \"check\" ? \"AbilityCheck\" : \"SavingThrow\";\n    const oldName = type === \"check\" ? \"AbilityTest\" : \"AbilitySave\";\n\n    // Handle deprecated calling pattern\n    if ( config && (foundry.utils.getType(config) !== \"Object\") ) {\n      foundry.utils.logCompatibilityWarning(\n        `The \\`roll${oldName}\\` method on Actor5e now takes roll, dialog, and message config objects as parameters.`,\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      oldFormat = true;\n      const oldConfig = dialog;\n      config = { ability: config };\n      dialog = {};\n      _applyDeprecatedD20Configs(config, dialog, message, oldConfig);\n    }\n\n    const ability = this.system.abilities?.[config.ability];\n    const abilityConfig = CONFIG.DND5E.abilities[config.ability];\n\n    const rollData = this.getRollData();\n    let { parts, data } = CONFIG.Dice.BasicRoll.constructParts({\n      mod: ability?.mod,\n      prof: ability?.[`${type}Prof`].hasProficiency ? ability[`${type}Prof`].term : null,\n      [`${config.ability}${type.capitalize()}Bonus`]: ability?.bonuses[type],\n      [`${type}Bonus`]: this.system.bonuses?.abilities?.[type],\n      cover: (config.ability === \"dex\") && (type === \"save\") ? this.system.attributes?.ac?.cover : null\n    }, rollData);\n    const options = {};\n\n    const rollConfig = foundry.utils.mergeObject({\n      halflingLucky: this.getFlag(\"dnd5e\", \"halflingLucky\")\n    }, config);\n    rollConfig.hookNames = [...(config.hookNames ?? []), name, \"d20Test\"];\n    rollConfig.rolls = [\n      BasicRoll.mergeConfigs({ parts, data, options }, config.rolls?.shift())\n    ].concat(config.rolls ?? []);\n    rollConfig.rolls.forEach(({ parts, data }) => this.addRollExhaustion(parts, data));\n    rollConfig.subject = this;\n\n    const dialogConfig = foundry.utils.deepClone(dialog);\n\n    const messageConfig = foundry.utils.mergeObject({\n      create: true,\n      data: {\n        flags: {\n          dnd5e: {\n            messageType: \"roll\",\n            roll: {\n              ability: config.ability,\n              type: type === \"check\" ? \"ability\" : \"save\"\n            }\n          }\n        },\n        flavor: game.i18n.format(\n          `DND5E.${type === \"check\" ? \"Ability\" : \"Save\"}PromptTitle`, { ability: abilityConfig?.label ?? \"\" }\n        ),\n        speaker: ChatMessage.getSpeaker({ actor: this })\n      }\n    }, message);\n\n    if ( \"dnd5e.preRollAbilityTest\" in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        `The \\`dnd5e.preRoll${oldName}\\` hook has been deprecated and replaced with \\`dnd5e.preRoll${name}V2\\`.`,\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      const oldConfig = _createDeprecatedD20Config(rollConfig, dialogConfig, messageConfig);\n      if ( Hooks.call(`dnd5e.preRoll${oldName}`, this, oldConfig, config.ability) === false ) return null;\n      _applyDeprecatedD20Configs(rollConfig, dialogConfig, messageConfig, oldConfig);\n    }\n\n    const rolls = await CONFIG.Dice.D20Roll.build(rollConfig, dialogConfig, messageConfig);\n    if ( !rolls.length ) return null;\n\n    /**\nA hook event that fires after an ability check or save has been rolled.\n@function dnd5e.rollAbilityCheck\n@function dnd5e.rollSavingThrow\n@memberof hookEvents\n@param {D20Roll[]} rolls       The resulting rolls.\n@param {object} data\n@param {string} data.ability   ID of the ability that was rolled as defined in `CONFIG.DND5E.abilities`.\n@param {Actor5e} data.subject  Actor for which the roll has been performed.\n/\n    Hooks.callAll(`dnd5e.roll${name}`, rolls, { ability: config.ability, subject: this });\n\n    if ( `dnd5e.roll${name}` in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        `The \\`dnd5e.roll${oldName}\\` hook has been deprecated and replaced with \\`dnd5e.roll${name}\\`.`,\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      Hooks.callAll(`dnd5e.roll${oldName}`, this, rolls[0], config.ability);\n    }\n\n    return oldFormat ? rolls[0] : rolls;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPerform a death saving throw, rolling a d20 plus any global save bonuses.\n@param {Partial<D20RollProcessConfiguration>} config     Configuration information for the roll.\n@param {Partial<BasicRollDialogConfiguration>} dialog    Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message  Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}                       A Promise which resolves to the Roll instance.\n/\n  async rollDeathSave(config={}, dialog={}, message={}) {\n    let oldFormat = false;\n    const death = this.system.attributes?.death;\n    if ( !death ) throw new Error(`Actors of the type '${this.type}' don't support death saves.`);\n\n    // Handle deprecated config object\n    if ( config.legacy !== false ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `rollDeathSave` method on Actor5e now takes roll, dialog, and message config objects as parameters. \"\n        + \"Pass the `legacy: false` option to config object to suppress this warning once updates have been made.\",\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      oldFormat = true;\n      const oldConfig = config;\n      config = {};\n      _applyDeprecatedD20Configs(config, dialog, message, oldConfig);\n    }\n\n    // Display a warning if we are not at zero HP or if we already have reached 3\n    if ( (this.system.attributes.hp.value > 0) || (death.failure >= 3) || (death.success >= 3) ) {\n      ui.notifications.warn(\"DND5E.DeathSaveUnnecessary\", { localize: true });\n      return null;\n    }\n\n    const parts = [];\n    let data = {};\n    const options = {\n      advantage: death.roll.mode === CONFIG.Dice.D20Roll.ADV_MODE.ADVANTAGE,\n      disadvantage: death.roll.mode === CONFIG.Dice.D20Roll.ADV_MODE.DISADVANTAGE,\n      maximum: death.roll.max,\n      minimum: death.roll.min\n    };\n\n    // Diamond Soul adds proficiency\n    if ( this.getFlag(\"dnd5e\", \"diamondSoul\") ) {\n      parts.push(\"@prof\");\n      data.prof = new Proficiency(this.system.attributes.prof, 1).term;\n    }\n\n    // Death save bonus\n    if ( death.bonuses.save ) parts.push(death.bonuses.save);\n\n    const rollConfig = foundry.utils.mergeObject({ target: 10 }, config);\n    rollConfig.hookNames = [...(config.hookNames ?? []), \"deathSave\"];\n    rollConfig.rolls = [\n      BasicRoll.mergeConfigs({ parts, data, options }, config.rolls?.shift())\n    ].concat(config.rolls ?? []);\n\n    const dialogConfig = foundry.utils.deepClone(dialog);\n\n    const messageConfig = foundry.utils.mergeObject({\n      data: {\n        flags: {\n          dnd5e: {\n            roll: {\n              type: \"death\"\n            }\n          }\n        },\n        flavor: game.i18n.localize(\"DND5E.DeathSavingThrow\")\n      }\n    }, message);\n\n    if ( \"dnd5e.preRollDeathSave\" in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `dnd5e.preRollDeathSave` hook has been deprecated and replaced with `dnd5e.preRollDeathSaveV2`.\",\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      const oldConfig = _createDeprecatedD20Config(rollConfig, dialogConfig, messageConfig);\n      if ( Hooks.call(\"dnd5e.preRollDeathSave\", this, oldConfig) === false ) return null;\n      _applyDeprecatedD20Configs(rollConfig, dialogConfig, messageConfig, oldConfig);\n    }\n\n    const rolls = await this.rollSavingThrow(rollConfig, dialogConfig, messageConfig);\n    if ( !rolls?.length ) return null;\n\n    // Take action depending on the result\n    const details = {};\n    const roll = rolls[0];\n    const returnValue = oldFormat ? roll : rolls;\n\n    // Save success\n    if ( roll.total >= (roll.options.target ?? 10) ) {\n      let successes = (death.success || 0) + 1;\n\n      // Critical Success = revive with 1hp\n      if ( roll.isCritical ) {\n        details.updates = {\n          \"system.attributes.death.success\": 0,\n          \"system.attributes.death.failure\": 0,\n          \"system.attributes.hp.value\": 1\n        };\n        details.chatString = \"DND5E.DeathSaveCriticalSuccess\";\n      }\n\n      // 3 Successes = survive and reset checks\n      else if ( successes === 3 ) {\n        details.updates = {\n          \"system.attributes.death.success\": 0,\n          \"system.attributes.death.failure\": 0\n        };\n        details.chatString = \"DND5E.DeathSaveSuccess\";\n      }\n\n      // Increment successes\n      else details.updates = {\"system.attributes.death.success\": Math.clamp(successes, 0, 3)};\n    }\n\n    // Save failure\n    else {\n      let failures = (death.failure || 0) + (roll.isFumble ? 2 : 1);\n      details.updates = {\"system.attributes.death.failure\": Math.clamp(failures, 0, 3)};\n      if ( failures >= 3 ) {  // 3 Failures = death\n        details.chatString = \"DND5E.DeathSaveFailure\";\n      }\n    }\n\n    /**\nA hook event that fires after a death saving throw has been rolled for an Actor, but before\nupdates have been performed.\n@function dnd5e.rollDeathSave\n@memberof hookEvents\n@param {D20Roll[]} rolls         The resulting rolls.\n@param {object} data\n@param {string} data.chatString  Localizable string displayed in the create chat message. If not set, then\n                                 no chat message will be displayed.\n@param {object} data.updates     Updates that will be applied to the actor as a result of this save.\n@param {Actor5e} data.subject    Actor for which the death saving throw has been rolled.\n@returns {boolean}               Explicitly return `false` to prevent updates from being performed.\n/\n    if ( Hooks.call(\"dnd5e.rollDeathSaveV2\", rolls, { ...details, subject: this }) === false ) return returnValue;\n\n    if ( \"dnd5e.rollDeathSave\" in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `dnd5e.rollDeathSave` hook has been deprecated and replaced with `dnd5e.rollDeathSaveV2`.\",\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      if ( Hooks.call(\"dnd5e.rollDeathSave\", this, rolls[0], details) === false ) return returnValue;\n    }\n\n    if ( !foundry.utils.isEmpty(details.updates) ) await this.update(details.updates);\n\n    // Display success/failure chat message\n    let resultsMessage;\n    if ( details.chatString ) {\n      const chatData = {\n        content: game.i18n.format(details.chatString, { name: this.name }),\n        speaker: messageConfig.speaker ?? ChatMessage.getSpeaker({ actor: this })\n      };\n      ChatMessage.applyRollMode(chatData, roll.options.rollMode);\n      resultsMessage = await ChatMessage.create(chatData);\n    }\n\n    /**\nA hook event that fires after a death saving throw has been rolled and after changes have been applied.\n@function dnd5e.postRollDeathSave\n@memberof hookEvents\n@param {D20Roll[]} rolls                  The resulting rolls.\n@param {object} data\n@param {ChatMessage5e|void} data.message  The created results chat message.\n@param {Actor5e} data.subject             Actor for which the death saving throw has been rolled.\n/\n    Hooks.callAll(\"dnd5e.postRollDeathSave\", rolls, { message: resultsMessage, subject: this });\n\n    return returnValue;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPerform a saving throw to maintain concentration.\n@param {Partial<AbilityRollProcessConfiguration>} config  Configuration information for the roll.\n@param {Partial<BasicRollDialogConfiguration>} dialog     Configuration for the roll dialog.\n@param {Partial<BasicRollMessageConfiguration>} message   Configuration for the roll message.\n@returns {Promise<D20Roll[]|null>}                        A Promise which resolves to the created Roll instance.\n/\n  async rollConcentration(config={}, dialog={}, message={}) {\n    let oldFormat = false;\n    if ( !this.isOwner ) return null;\n    const conc = this.system.attributes?.concentration;\n    if ( !conc ) throw new Error(\"You may not make a Concentration Saving Throw with this Actor.\");\n\n    // Handle deprecated config object\n    if ( config.legacy !== false ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `rollConcentration` method on Actor5e now takes roll, dialog, and message config objects as parameters.\"\n        + \"Pass the `legacy: false` option to config object to suppress this warning once updates have been made.\",\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      oldFormat = true;\n      const oldConfig = config;\n      config = {};\n      _applyDeprecatedD20Configs(config, dialog, message, oldConfig);\n    }\n\n    let data = {};\n    const parts = [];\n    const options = {\n      advantage: conc.roll.mode === CONFIG.Dice.D20Roll.ADV_MODE.ADVANTAGE,\n      disadvantage: conc.roll.mode === CONFIG.Dice.D20Roll.ADV_MODE.DISADVANTAGE,\n      maximum: conc.roll.max,\n      minimum: conc.roll.min\n    };\n\n    // Concentration bonus\n    if ( conc.bonuses.save ) parts.push(conc.bonuses.save);\n\n    const rollConfig = foundry.utils.mergeObject({\n      ability: (conc.ability in CONFIG.DND5E.abilities) ? conc.ability : CONFIG.DND5E.defaultAbilities.concentration,\n      isConcentration: true,\n      target: 10\n    }, config);\n    rollConfig.hookNames = [...(config.hookNames ?? []), \"concentration\"];\n    rollConfig.rolls = [\n      BasicRoll.mergeConfigs({ parts, data, options }, config.rolls?.shift())\n    ].concat(config.rolls ?? []);\n\n    const dialogConfig = foundry.utils.mergeObject({\n      options: {\n        window: {\n          title: game.i18n.format(\"DND5E.SavePromptTitle\", { ability: game.i18n.localize(\"DND5E.Concentration\") })\n        }\n      }\n    }, dialog);\n\n    const messageConfig = foundry.utils.deepClone(message);\n\n    /**\nA hook event that fires before a saving throw to maintain concentration is rolled for an Actor.\n@function dnd5e.preRollConcentration\n@memberof hookEvents\n@param {Actor5e} actor                   Actor for which the saving throw is being rolled.\n@param {D20RollConfiguration} options    Configuration data for the pending roll.\n@returns {boolean}                       Explicitly return `false` to prevent the save from being performed.\n/\n    if ( \"dnd5e.preRollConcentration\" in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `dnd5e.preRollConcentration` hook has been deprecated and replaced with `dnd5e.preRollConcentrationV2`.\",\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      const oldConfig = _createDeprecatedD20Config(rollConfig, dialogConfig, messageConfig);\n      if ( Hooks.call(\"dnd5e.preRollConcentration\", this, oldConfig) === false ) return null;\n      _applyDeprecatedD20Configs(rollConfig, dialogConfig, messageConfig, oldConfig);\n    }\n\n    const rolls = await this.rollSavingThrow(rollConfig, dialogConfig, messageConfig);\n    if ( !rolls?.length ) return null;\n\n    /**\nA hook event that fires after a saving throw to maintain concentration is rolled for an Actor.\n@function dnd5e.rollConcentration\n@memberof hookEvents\n@param {D20Roll[]} rolls     The resulting rolls.\n@param {object} data\n@param {Actor5e} data.actor  Actor for which the saving throw has been rolled.\n/\n    Hooks.callAll(\"dnd5e.rollConcentrationV2\", rolls, { subject: this });\n\n    if ( \"dnd5e.rollConcentration\" in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `dnd5e.rollConcentration` hook has been deprecated and replaced with `dnd5e.rollConcentrationV2`.\",\n        { since: \"DnD5e 4.1\", until: \"DnD5e 4.5\" }\n      );\n      Hooks.callAll(\"dnd5e.rollConcentration\", this, rolls[0]);\n    }\n\n    return oldFormat ? rolls[0] : rolls;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n@typedef {D20RollOptions} InitiativeRollOptions\n@property {D20Roll.ADV_MODE} [advantageMode]  A specific advantage mode to apply.\n@property {number} [fixed]                    Fixed initiative value to use rather than rolling.\n@property {string} [flavor]                   Special flavor text to apply to the created message.\n/\n\n  /**\nGet an un-evaluated D20Roll instance used to roll initiative for this Actor.\n@param {Partial<InitiativeRollOptions>} options  Configuration information for the roll.\n@returns {D20Roll|null}                          The constructed but unevaluated D20Roll.\n/\n  getInitiativeRoll(options={}) {\n    // Use a temporarily cached initiative roll\n    if ( this._cachedInitiativeRoll ) return this._cachedInitiativeRoll.clone();\n    const config = this.getInitiativeRollConfig(options);\n    if ( !config ) return null;\n\n    // Create a normal D20 roll\n    if ( config.options?.fixed === undefined ) {\n      const formula = [\"1d20\"].concat(config.parts).join(\" + \");\n      return new CONFIG.Dice.D20Roll(formula, config.data, config.options);\n    }\n\n    // Create a basic roll with the fixed score\n    return new CONFIG.Dice.BasicRoll(String(config.options.fixed), config.data, config.options);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nGet an un-evaluated D20Roll instance used to roll initiative for this Actor.\n@param {Partial<InitiativeRollOptions>} options  Configuration information for the roll.\n@returns {D20RollConfiguration|null}             Roll configuration.\n/\n  getInitiativeRollConfig(options={}) {\n    const init = this.system.attributes?.init;\n    const flags = this.flags.dnd5e ?? {};\n    const abilityId = init?.ability || CONFIG.DND5E.defaultAbilities.initiative;\n    const ability = this.system.abilities?.[abilityId];\n\n    const rollData = this.getRollData();\n    let { parts, data } = CONFIG.Dice.BasicRoll.constructParts({\n      mod: init?.mod,\n      prof: init.prof.hasProficiency ? init.prof.term : null,\n      initiativeBonus: init.bonus,\n      [`${abilityId}AbilityCheckBonus`]: ability?.bonuses?.check,\n      abilityCheckBonus: this.system.bonuses?.abilities?.check,\n      alert: flags.initiativeAlert && (game.settings.get(\"dnd5e\", \"rulesVersion\") === \"legacy\") ? 5 : null\n    }, rollData);\n\n    const remarkableAthlete = flags.remarkableAthlete && (game.settings.get(\"dnd5e\", \"rulesVersion\") === \"modern\");\n    if ( flags.initiativeAdv || remarkableAthlete ) options.advantage ??= true;\n\n    // Add exhaustion reduction\n    this.addRollExhaustion(parts, data);\n\n    // Ability score tiebreaker\n    const tiebreaker = game.settings.get(\"dnd5e\", \"initiativeDexTiebreaker\");\n    if ( tiebreaker && Number.isNumeric(ability?.value) ) parts.push(String(ability.value / 100));\n\n    // Fixed initiative score\n    const scoreMode = game.settings.get(\"dnd5e\", \"initiativeScore\");\n    const useScore = (scoreMode === \"all\") || ((scoreMode === \"npcs\") && game.user.isGM && (this.type === \"npc\"));\n\n    options = foundry.utils.mergeObject({\n      fixed: useScore ? init.score : undefined,\n      flavor: options.flavor ?? game.i18n.localize(\"DND5E.Initiative\"),\n      halflingLucky: flags.halflingLucky ?? false,\n      maximum: init.roll.max,\n      minimum: init.roll.min\n    }, options);\n\n    const rollConfig = { parts, data, options, subject: this };\n\n    /**\nA hook event that fires before initiative roll is prepared for an Actor.\n@function dnd5e.preConfigureInitiative\n@memberof hookEvents\n@param {Actor5e} subject              The Actor that is rolling initiative.\n@param {D20RollConfiguration} config  Configuration data for the pending roll.\n/\n    Hooks.callAll(\"dnd5e.preConfigureInitiative\", this, rollConfig);\n\n    return rollConfig;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRoll initiative for this Actor with a dialog that provides an opportunity to elect advantage or other bonuses.\n@param {Partial<InitiativeRollOptions>} [rollOptions={}]  Options forwarded to the Actor#getInitiativeRoll method.\n@returns {Promise<void>}           A promise which resolves once initiative has been rolled for the Actor.\n/\n  async rollInitiativeDialog(rollOptions={}) {\n    const config = {\n      evaluate: false,\n      event: rollOptions.event,\n      hookNames: [\"initiativeDialog\", \"abilityCheck\", \"d20Test\"],\n      rolls: [this.getInitiativeRollConfig(rollOptions)],\n      subject: this\n    };\n    if ( !config.rolls[0] ) return;\n\n    // Display the roll configuration dialog\n    const messageOptions = { rollMode: game.settings.get(\"core\", \"rollMode\") };\n    if ( config.rolls[0].options?.fixed === undefined ) {\n      const dialog = { options: { title: game.i18n.localize(\"DND5E.InitiativeRoll\") } };\n      const rolls = await CONFIG.Dice.D20Roll.build(config, dialog, messageOptions);\n      if ( !rolls.length ) return;\n      this._cachedInitiativeRoll = rolls[0];\n    }\n\n    // Just create a basic roll with the fixed score\n    else {\n      const { data, options } = config.rolls[0];\n      this._cachedInitiativeRoll = new CONFIG.Dice.BasicRoll(String(options.fixed), data, options);\n    }\n\n    await this.rollInitiative({ createCombatants: true, initiativeOptions: { messageOptions } });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async rollInitiative(options={}, rollOptions={}) {\n    this._cachedInitiativeRoll ??= this.getInitiativeRoll(rollOptions);\n\n    /**\nA hook event that fires before initiative is rolled for an Actor.\n@function dnd5e.preRollInitiative\n@memberof hookEvents\n@param {Actor5e} actor  The Actor that is rolling initiative.\n@param {D20Roll} roll   The initiative roll.\n/\n    if ( Hooks.call(\"dnd5e.preRollInitiative\", this, this._cachedInitiativeRoll) === false ) {\n      delete this._cachedInitiativeRoll;\n      return null;\n    }\n\n    const combat = await super.rollInitiative(options);\n    const combatants = this.isToken ? this.getActiveTokens(false, true).reduce((arr, t) => {\n      const combatant = game.combat.getCombatantByToken(t.id);\n      if ( combatant ) arr.push(combatant);\n      return arr;\n    }, []) : [game.combat.getCombatantByActor(this.id)];\n\n    /**\nA hook event that fires after an Actor has rolled for initiative.\n@function dnd5e.rollInitiative\n@memberof hookEvents\n@param {Actor5e} actor           The Actor that rolled initiative.\n@param {Combatant[]} combatants  The associated Combatants in the Combat.\n/\n    Hooks.callAll(\"dnd5e.rollInitiative\", this, combatants);\n    delete this._cachedInitiativeRoll;\n    return combat;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n@typedef {BasicRollProcessConfiguration} HitDieRollProcessConfiguration\n@property {string} [denomination]  The denomination of hit die to roll with the leading letter (e.g. `d8`).\n                                   If no denomination is provided, the first available hit die will be used.\n@property {boolean} [modifyHitDice=true]    Should the actor's spent hit dice count be updated?\n@property {boolean} [modifyHitPoints=true]  Should the actor's hit points be updated after the roll?\n/\n\n  /**\nRoll a hit die of the appropriate type, gaining hit points equal to the die roll plus your CON modifier.\n@param {HitDieRollProcessConfiguration} config  Configuration information for the roll.\n@param {BasicRollDialogConfiguration} dialog    Configuration for the roll dialog.\n@param {BasicRollMessageConfiguration} message  Configuration for the roll message.\n@returns {Promise<BasicRoll[]|null>}            The created Roll instances, or `null` if no hit die was rolled.\n/\n  async rollHitDie(config={}, dialog={}, message={}) {\n    let formula;\n    let oldFormat = false;\n\n    // Handle deprecated calling pattern\n    if ( config && (foundry.utils.getType(config) !== \"Object\") ) {\n      foundry.utils.logCompatibilityWarning(\n        \"Actor5e.rollHitDie now takes roll, dialog, and message config objects as parameters.\",\n        { since: \"DnD5e 4.0\", until: \"DnD5e 4.4\" }\n      );\n      oldFormat = true;\n      formula = dialog.formula;\n      config = { denomination: config, data: dialog.data };\n      message = { create: dialog.chatMessage, data: dialog.messageData };\n      dialog = {};\n    }\n\n    let cls = null;\n\n    // NPCs only have one denomination\n    if ( this.type === \"npc\" ) {\n      config.denomination = `d${this.system.attributes.hd.denomination}`;\n\n      // If no hit dice are available, display an error notification\n      if ( !this.system.attributes.hd.value ) {\n        ui.notifications.error(game.i18n.format(\"DND5E.HitDiceNPCWarn\", {name: this.name}));\n        return null;\n      }\n    }\n\n    // Otherwise check classes\n    else {\n      // If no denomination was provided, choose the first available\n      if ( !config.denomination ) {\n        cls = this.system.attributes.hd.classes.find(c => c.system.hd.value);\n        if ( !cls ) return null;\n        config.denomination = cls.system.hd.denomination;\n      }\n\n      // Otherwise, locate a class (if any) which has an available hit die of the requested denomination\n      else cls = this.system.attributes.hd.classes.find(i => {\n        return (i.system.hd.denomination === config.denomination) && i.system.hd.value;\n      });\n\n      // If no class is available, display an error notification\n      if ( !cls ) {\n        ui.notifications.error(game.i18n.format(\"DND5E.HitDiceWarn\", {name: this.name, formula: config.denomination}));\n        return null;\n      }\n    }\n\n    formula ??= `max(0, 1${config.denomination} + @abilities.con.mod)`;\n    const rollConfig = foundry.utils.deepClone(config);\n    rollConfig.hookNames = [...(config.hookNames ?? []), \"hitDie\"];\n    rollConfig.rolls = [{ parts: [formula], data: this.getRollData() }].concat(config.rolls ?? []);\n    rollConfig.subject = this;\n\n    const dialogConfig = foundry.utils.mergeObject({\n      configure: false\n    }, dialog);\n\n    const flavor = game.i18n.localize(\"DND5E.HitDiceRoll\");\n    const messageConfig = foundry.utils.mergeObject({\n      rollMode: game.settings.get(\"core\", \"rollMode\"),\n      data: {\n        speaker: ChatMessage.implementation.getSpeaker({actor: this}),\n        flavor,\n        title: `${flavor}: ${this.name}`,\n        \"flags.dnd5e.roll\": {type: \"hitDie\"}\n      }\n    }, message);\n\n    if ( \"dnd5e.preRollHitDie\" in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `dnd5e.preRollHitDie` hook has been deprecated and replaced with `dnd5e.preRollHitDieV2`.\",\n        { since: \"DnD5e 4.0\", until: \"DnD5e 4.4\" }\n      );\n      const hookData = {\n        formula: rollConfig.rolls[0].parts[0], data: rollConfig.rolls[0].data,\n        chatMessage: messageConfig.create, messageData: messageConfig.data\n      };\n      if ( Hooks.call(\"dnd5e.preRollHitDie\", this, hookData, rollConfig.denomination) === false ) return null;\n      rollConfig.rolls[0].parts[0] = hookData.formula;\n      rollConfig.rolls[0].data = hookData.data;\n      messageConfig.create = hookData.chatMessage;\n      messageConfig.data = hookData.messageData;\n    }\n\n    const rolls = await CONFIG.Dice.BasicRoll.build(rollConfig, dialogConfig, messageConfig);\n    if ( !rolls.length ) return null;\n    const returnValue = oldFormat && rolls?.length ? rolls[0] : rolls;\n\n    const updates = { actor: {}, class: {} };\n    if ( rollConfig.modifyHitDice !== false ) {\n      if ( cls ) updates.class[\"system.hd.spent\"] = cls.system.hd.spent + 1;\n      else updates.actor[\"system.attributes.hd.spent\"] = this.system.attributes.hd.spent + 1;\n    }\n    const hp = this.system.attributes.hp;\n    if ( rollConfig.modifyHitPoints !== false ) {\n      const dhp = Math.min(Math.max(0, hp.effectiveMax) - hp.value, rolls.reduce((t, r) => t + r.total, 0));\n      updates.actor[\"system.attributes.hp.value\"] = hp.value + dhp;\n    }\n\n    /**\nA hook event that fires after a hit die has been rolled for an Actor, but before updates have been performed.\n@function dnd5e.rollHitDieV2\n@memberof hookEvents\n@param {BasicRoll[]} rolls          The resulting rolls.\n@param {object} data\n@param {Actor5e} data.subject       Actor for which the hit die has been rolled.\n@param {object} data.updates\n@param {object} data.updates.actor  Updates that will be applied to the actor.\n@param {object} data.updates.class  Updates that will be applied to the class.\n@returns {boolean}                  Explicitly return `false` to prevent updates from being performed.\n/\n    if ( Hooks.call(\"dnd5e.rollHitDieV2\", rolls, { subject: this, updates }) === false ) return returnValue;\n\n    if ( \"dnd5e.rollHitDie\" in Hooks.events ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `dnd5e.rollHitDie` hook has been deprecated and replaced with `dnd5e.rollHitDieV2`.\",\n        { since: \"DnD5e 4.0\", until: \"DnD5e 4.4\" }\n      );\n      if ( Hooks.call(\"dnd5e.rollHitDie\", this, rolls[0], updates) === false ) return null;\n    }\n\n    // Perform updates\n    if ( !foundry.utils.isEmpty(updates.actor) ) await this.update(updates.actor);\n    if ( !foundry.utils.isEmpty(updates.class) ) await cls.update(updates.class);\n\n    /**\nA hook event that fires after a hit die has been rolled for an Actor and updates have been performed.\n@function dnd5e.postRollHitDie\n@memberof hookEvents\n@param {BasicRoll[]} rolls     The resulting rolls.\n@param {object} data\n@param {Actor5e} data.subject  Actor for which the roll was performed.\n/\n    Hooks.callAll(\"dnd5e.postRollHitDie\", rolls, { subject: this });\n\n    return returnValue;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRoll hit points for a specific class as part of a level-up workflow.\n@param {Item5e} item                         The class item whose hit dice to roll.\n@param {object} options\n@param {boolean} [options.chatMessage=true]  Display the chat message for this roll.\n@returns {Promise<Roll>}                     The completed roll.\n@see {@link dnd5e.preRollClassHitPoints}\n/\n  async rollClassHitPoints(item, { chatMessage=true }={}) {\n    if ( item.type !== \"class\" ) throw new Error(\"Hit points can only be rolled for a class item.\");\n    const rollData = {\n      formula: `1${item.system.hd.denomination}`,\n      data: item.getRollData(),\n      chatMessage\n    };\n    const flavor = game.i18n.format(\"DND5E.ADVANCEMENT.HitPoints.Roll\", { class: item.name });\n    const messageData = {\n      title: `${flavor}: ${this.name}`,\n      flavor,\n      speaker: ChatMessage.implementation.getSpeaker({ actor: this }),\n      \"flags.dnd5e.roll\": { type: \"hitPoints\" }\n    };\n\n    /**\nA hook event that fires before hit points are rolled for a character's class.\n@function dnd5e.preRollClassHitPoints\n@memberof hookEvents\n@param {Actor5e} actor            Actor for which the hit points are being rolled.\n@param {Item5e} item              The class item whose hit dice will be rolled.\n@param {object} rollData\n@param {string} rollData.formula  The string formula to parse.\n@param {object} rollData.data     The data object against which to parse attributes within the formula.\n@param {object} messageData       The data object to use when creating the message.\n/\n    Hooks.callAll(\"dnd5e.preRollClassHitPoints\", this, item, rollData, messageData);\n\n    const roll = new Roll(rollData.formula, rollData.data);\n    await roll.evaluate();\n\n    /**\nA hook event that fires after hit points haven been rolled for a character's class.\n@function dnd5e.rollClassHitPoints\n@memberof hookEvents\n@param {Actor5e} actor  Actor for which the hit points have been rolled.\n@param {Roll} roll      The resulting roll.\n/\n    Hooks.callAll(\"dnd5e.rollClassHitPoints\", this, roll);\n\n    if ( rollData.chatMessage ) await roll.toMessage(messageData);\n    return roll;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRoll hit points for an NPC based on the HP formula.\n@param {object} options\n@param {boolean} [options.chatMessage=true]  Display the chat message for this roll.\n@returns {Promise<Roll>}                     The completed roll.\n@see {@link dnd5e.preRollNPCHitPoints}\n/\n  async rollNPCHitPoints({ chatMessage=true }={}) {\n    if ( this.type !== \"npc\" ) throw new Error(\"NPC hit points can only be rolled for NPCs\");\n    const rollData = {\n      formula: this.system.attributes.hp.formula,\n      data: this.getRollData(),\n      chatMessage\n    };\n    const flavor = game.i18n.format(\"DND5E.HPFormulaRollMessage\");\n    const messageData = {\n      title: `${flavor}: ${this.name}`,\n      flavor,\n      speaker: ChatMessage.getSpeaker({ actor: this }),\n      \"flags.dnd5e.roll\": { type: \"hitPoints\" }\n    };\n\n    /**\nA hook event that fires before hit points are rolled for an NPC.\n@function dnd5e.preRollNPCHitPoints\n@memberof hookEvents\n@param {Actor5e} actor            Actor for which the hit points are being rolled.\n@param {object} rollData\n@param {string} rollData.formula  The string formula to parse.\n@param {object} rollData.data     The data object against which to parse attributes within the formula.\n@param {object} messageData       The data object to use when creating the message.\n/\n    Hooks.callAll(\"dnd5e.preRollNPCHitPoints\", this, rollData, messageData);\n\n    const roll = new Roll(rollData.formula, rollData.data);\n    await roll.evaluate();\n\n    /**\nA hook event that fires after hit points are rolled for an NPC.\n@function dnd5e.rollNPCHitPoints\n@memberof hookEvents\n@param {Actor5e} actor  Actor for which the hit points have been rolled.\n@param {Roll} roll      The resulting roll.\n/\n    Hooks.callAll(\"dnd5e.rollNPCHitPoints\", this, roll);\n\n    if ( rollData.chatMessage ) await roll.toMessage(messageData);\n    return roll;\n  }\n\n  /* -------------------------------------------- */\n  /*  Resting                                     */\n  /* -------------------------------------------- */\n\n  /**\nConfiguration options for a rest.\n@typedef {object} RestConfiguration\n@property {string} type                   Type of rest to perform.\n@property {boolean} dialog                Present a dialog window which allows for rolling hit dice as part of the\n                                          Short Rest and selecting whether a new day has occurred.\n@property {boolean} chat                  Should a chat message be created to summarize the results of the rest?\n@property {number} duration               Amount of time passed during the rest in minutes.\n@property {boolean} newDay                Does this rest carry over to a new day?\n@property {boolean} [advanceBastionTurn]  Should a bastion turn be advanced for all players?\n@property {boolean} [advanceTime]         Should the game clock be advanced by the rest duration?\n@property {boolean} [autoHD]              Should hit dice be spent automatically during a short rest?\n@property {number} [autoHDThreshold]      How many hit points should be missing before hit dice are\n                                          automatically spent during a short rest.\n/\n\n  /**\nResults from a rest operation.\n@typedef {object} RestResult\n@property {string} type              Type of rest performed.\n@property {Actor5e} clone            Clone of the actor before rest is performed.\n@property {object} deltas\n@property {number} deltas.hitPoints  Hit points recovered during the rest.\n@property {number} deltas.hitDice    Hit dice recovered or spent during the rest.\n@property {boolean} newDay           Whether a new day occurred during the rest.\n@property {Roll[]} rolls             Any rolls that occurred during the rest process, not including hit dice.\n@property {object} updateData        Updates applied to the actor.\n@property {object[]} updateItems     Updates applied to actor's items.\n/\n\n  /* -------------------------------------------- */\n\n  /**\nTake a short rest, possibly spending hit dice and recovering resources, item uses, and relevant spell slots.\n@param {RestConfiguration} [config]  Configuration options for a short rest.\n@returns {Promise<RestResult>}       A Promise which resolves once the short rest workflow has completed.\n/\n  async shortRest(config={}) {\n    if ( this.type === \"vehicle\" ) return;\n    const clone = this.clone();\n\n    config = foundry.utils.mergeObject({\n      type: \"short\", dialog: true, chat: true, newDay: false, advanceTime: false, autoHD: false, autoHDThreshold: 3,\n      duration: CONFIG.DND5E.restTypes.short.duration[game.settings.get(\"dnd5e\", \"restVariant\")]\n    }, config);\n\n    /**\nA hook event that fires before a short rest is started.\n@function dnd5e.preShortRest\n@memberof hookEvents\n@param {Actor5e} actor             The actor that is being rested.\n@param {RestConfiguration} config  Configuration options for the rest.\n@returns {boolean}                 Explicitly return `false` to prevent the rest from being started.\n/\n    if ( Hooks.call(\"dnd5e.preShortRest\", this, config) === false ) return;\n\n    // Take note of the initial hit points and number of hit dice the Actor has\n    const hd0 = foundry.utils.getProperty(this, \"system.attributes.hd.value\");\n    const hp0 = foundry.utils.getProperty(this, \"system.attributes.hp.value\");\n\n    // Display a Dialog for rolling hit dice\n    if ( config.dialog ) {\n      try {\n        foundry.utils.mergeObject(config, await ShortRestDialog.configure(this, config));\n      } catch(err) { return; }\n    }\n\n    /**\nA hook event that fires after a short rest has started, after the configuration is complete.\n@function dnd5e.shortRest\n@memberof hookEvents\n@param {Actor5e} actor             The actor that is being rested.\n@param {RestConfiguration} config  Configuration options for the rest.\n@returns {boolean}                 Explicitly return `false` to prevent the rest from being continued.\n/\n    if ( Hooks.call(\"dnd5e.shortRest\", this, config) === false ) return;\n\n    // Automatically spend hit dice\n    if ( config.autoHD ) await this.autoSpendHitDice({ threshold: config.autoHDThreshold });\n\n    // Return the rest result\n    const dhd = foundry.utils.getProperty(this, \"system.attributes.hd.value\") - hd0;\n    const dhp = foundry.utils.getProperty(this, \"system.attributes.hp.value\") - hp0;\n    return this._rest(config, { clone, dhd, dhp });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nTake a long rest, recovering hit points, hit dice, resources, item uses, and spell slots.\n@param {RestConfiguration} [config]  Configuration options for a long rest.\n@returns {Promise<RestResult>}       A Promise which resolves once the long rest workflow has completed.\n/\n  async longRest(config={}) {\n    if ( this.type === \"vehicle\" ) return;\n    const clone = this.clone();\n\n    config = foundry.utils.mergeObject({\n      type: \"long\", dialog: true, chat: true, newDay: true, advanceTime: false,\n      duration: CONFIG.DND5E.restTypes.long.duration[game.settings.get(\"dnd5e\", \"restVariant\")]\n    }, config);\n\n    /**\nA hook event that fires before a long rest is started.\n@function dnd5e.preLongRest\n@memberof hookEvents\n@param {Actor5e} actor             The actor that is being rested.\n@param {RestConfiguration} config  Configuration options for the rest.\n@returns {boolean}                 Explicitly return `false` to prevent the rest from being started.\n/\n    if ( Hooks.call(\"dnd5e.preLongRest\", this, config) === false ) return;\n\n    if ( config.dialog ) {\n      try {\n        foundry.utils.mergeObject(config, await LongRestDialog.configure(this, config));\n      } catch(err) { return; }\n    }\n\n    /**\nA hook event that fires after a long rest has started, after the configuration is complete.\n@function dnd5e.longRest\n@memberof hookEvents\n@param {Actor5e} actor             The actor that is being rested.\n@param {RestConfiguration} config  Configuration options for the rest.\n@returns {boolean}                 Explicitly return `false` to prevent the rest from being continued.\n/\n    if ( Hooks.call(\"dnd5e.longRest\", this, config) === false ) return;\n\n    return this._rest(config, { clone });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPerform all of the changes needed for a short or long rest.\n@param {RestConfiguration} config         Configuration data for the rest occurring.\n@param {Partial<RestResult>} [result={}]  Results of the rest operation being built.\n@returns {Promise<RestResult>}  Consolidated results of the rest workflow.\n@private\n/\n  async _rest(config, result={}) {\n    if ( (foundry.utils.getType(this.system.rest) === \"function\")\n      && (await this.system.rest(config, result) === false) ) return;\n\n    result = foundry.utils.mergeObject({\n      type: config.type,\n      deltas: {\n        hitPoints: 0,\n        hitDice: 0\n      },\n      updateData: {},\n      updateItems: [],\n      newDay: config.newDay === true,\n      rolls: []\n    }, result);\n    result.clone ??= this.clone();\n    if ( \"dhp\" in result ) result.deltas.hitPoints = result.dhp;\n    if ( \"dhd\" in result ) result.deltas.hitDice = result.dhd;\n\n    this._getRestHitDiceRecovery(config, result);\n    this._getRestHitPointRecovery(config, result);\n    this._getRestResourceRecovery(config, result);\n    this._getRestSpellRecovery(config, result);\n    await this._getRestItemUsesRecovery(config, result);\n\n    result.dhp = result.deltas.hitPoints;\n    result.dhd = result.deltas.hitDice;\n    result.longRest = result.type === \"long\";\n\n    /**\nA hook event that fires after rest result is calculated, but before any updates are performed.\n@function dnd5e.preRestCompleted\n@memberof hookEvents\n@param {Actor5e} actor             The actor that is being rested.\n@param {RestResult} result         Details on the rest to be completed.\n@param {RestConfiguration} config  Configuration data for the rest occurring.\n@returns {boolean}                 Explicitly return `false` to prevent the rest updates from being performed.\n/\n    if ( Hooks.call(\"dnd5e.preRestCompleted\", this, result, config) === false ) return result;\n\n    // Perform updates\n    await this.update(result.updateData, { isRest: true });\n    await this.updateEmbeddedDocuments(\"Item\", result.updateItems, { isRest: true });\n\n    // Advance the game clock\n    if ( config.advanceTime && (config.duration > 0) && game.user.isGM ) await game.time.advance(60 * config.duration);\n\n    // Display a Chat Message summarizing the rest effects\n    if ( config.chat ) await this._displayRestResultMessage(config, result);\n\n    /**\nA hook event that fires when the rest process is completed for an actor.\n@function dnd5e.restCompleted\n@memberof hookEvents\n@param {Actor5e} actor             The actor that just completed resting.\n@param {RestResult} result         Details on the rest completed.\n@param {RestConfiguration} config  Configuration data for that occurred.\n/\n    Hooks.callAll(\"dnd5e.restCompleted\", this, result, config);\n\n    if ( config.advanceBastionTurn && game.user.isGM && game.settings.get(\"dnd5e\", \"bastionConfiguration\").enabled\n      && this.itemTypes.facility.length ) await dnd5e.bastion.advanceAllFacilities(this);\n\n    // Return data summarizing the rest effects\n    return result;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDisplay a chat message with the result of a rest.\n@param {RestConfiguration} config  Rest configuration.\n@param {RestResult} result         Result of the rest operation.\n@returns {Promise<ChatMessage>}    Chat message that was created.\n@protected\n/\n  async _displayRestResultMessage(config, result) {\n    let { dhd, dhp, newDay } = result;\n    if ( config.type === \"short\" ) dhd *= -1;\n    const diceRestored = dhd !== 0;\n    const healthRestored = dhp !== 0;\n    const longRest = config.type === \"long\";\n    const length = longRest ? \"Long\" : \"Short\";\n\n    const typeConfig = CONFIG.DND5E.restTypes[config.type] ?? {};\n    const duration = convertTime(config.duration, \"minute\");\n    const parts = [formatTime(duration.value, duration.unit)];\n    if ( newDay ) parts.push(game.i18n.localize(\"DND5E.REST.NewDay.Label\").toLowerCase());\n    const restFlavor = `${typeConfig.label} (${game.i18n.getListFormatter({ type: \"unit\" }).format(parts)})`;\n\n    // Determine the chat message to display\n    let message;\n    if ( diceRestored && healthRestored ) message = `DND5E.REST.${length}.Result.Full`;\n    else if ( longRest && !diceRestored && healthRestored ) message = \"DND5E.REST.Long.Result.HitPoints\";\n    else if ( longRest && diceRestored && !healthRestored ) message = \"DND5E.REST.Long.Result.HitDice\";\n    else message = `DND5E.REST.${length}.Result.Short`;\n\n    // Create a chat message\n    const pr = new Intl.PluralRules(game.i18n.lang);\n    let chatData = {\n      content: game.i18n.format(message, {\n        name: this.name,\n        dice: game.i18n.format(`DND5E.HITDICE.Counted.${pr.select(dhd)}`, { number: formatNumber(dhd) }),\n        health: game.i18n.format(`DND5E.HITPOINTS.Counted.${pr.select(dhp)}`, { number: formatNumber(dhp) })\n      }),\n      flavor: game.i18n.localize(restFlavor),\n      type: \"rest\",\n      rolls: result.rolls,\n      speaker: ChatMessage.getSpeaker({ actor: this, alias: this.name }),\n      system: {\n        activations: ActivationsField.getActivations(this, typeConfig?.activationPeriods ?? []),\n        deltas: ActorDeltasField.getDeltas(result.clone, { actor: result.updateData, item: result.updateItems }),\n        type: result.type\n      }\n    };\n    ChatMessage.applyRollMode(chatData, game.settings.get(\"core\", \"rollMode\"));\n    return ChatMessage.create(chatData);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAutomatically spend hit dice to recover hit points up to a certain threshold.\n@param {object} [options]\n@param {number} [options.threshold=3]  A number of missing hit points which would trigger an automatic HD roll.\n@returns {Promise<number>}             Number of hit dice spent.\n/\n  async autoSpendHitDice({ threshold=3 }={}) {\n    const hp = this.system.attributes.hp;\n    const max = Math.max(0, hp.effectiveMax);\n    let diceRolled = 0;\n    while ( (this.system.attributes.hp.value + threshold) <= max ) {\n      const r = await this.rollHitDie();\n      if ( r === null ) break;\n      diceRolled += 1;\n    }\n    return diceRolled;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRecovers class hit dice during a long rest.\n@param {RestConfiguration} [config]\n@param {number} [config.maxHitDice]  Maximum number of hit dice to recover.\n@param {number} [config.fraction]    Fraction of max hit dice to recover. Used for NPC recovery and for PCs if\n                                     `maxHitDice` isn't specified.\n@param {RestResult} [result={}]      Rest result being constructed.\n@protected\n/\n  _getRestHitDiceRecovery({ maxHitDice, fraction, ...config }={}, result={}) {\n    const restConfig = CONFIG.DND5E.restTypes[config.type];\n    if ( !this.system.attributes.hd || !restConfig?.recoverHitDice ) return;\n    fraction ??= game.settings.get(\"dnd5e\", \"rulesVersion\") === \"modern\" ? 1 : 0.5;\n\n    // Handle simpler HD recovery for NPCs\n    if ( this.type === \"npc\" ) {\n      const hd = this.system.attributes.hd;\n      const recovered = Math.min(\n        Math.max(1, Math.floor(hd.max * fraction)), hd.spent, maxHitDice ?? Infinity\n      );\n      foundry.utils.mergeObject(result, {\n        deltas: {\n          hitDice: (result.deltas?.hitDice ?? 0) + recovered\n        },\n        updateData: {\n          \"system.attributes.hd.spent\": hd.spent - recovered\n        }\n      });\n      return;\n    }\n\n    this.system.attributes.hd.createHitDiceUpdates({ maxHitDice, fraction, ...config }, result);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRecovers actor hit points and eliminates any temp HP.\n@param {RestConfiguration} [config={}]\n@param {boolean} [config.recoverTemp=true]     Reset temp HP to zero.\n@param {boolean} [config.recoverTempMax=true]  Reset temp max HP to zero.\n@param {RestResult} [result={}]                Rest result being constructed.\n@protected\n/\n  _getRestHitPointRecovery({ recoverTemp, recoverTempMax, ...config }={}, result={}) {\n    const restConfig = CONFIG.DND5E.restTypes[config.type ?? \"long\"];\n    const hp = this.system.attributes?.hp;\n    if ( !hp || !restConfig.recoverHitPoints ) return;\n\n    let max = hp.max;\n    result.updateData ??= {};\n    if ( recoverTempMax ) result.updateData[\"system.attributes.hp.tempmax\"] = 0;\n    else max = Math.max(0, hp.effectiveMax);\n    result.updateData[\"system.attributes.hp.value\"] = max;\n    if ( recoverTemp ) result.updateData[\"system.attributes.hp.temp\"] = 0;\n    foundry.utils.setProperty(\n      result, \"deltas.hitPoints\", (result.deltas?.hitPoints ?? 0) + Math.max(0, max - hp.value)\n    );\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRecovers actor resources.\n@param {object} [config={}]\n@param {boolean} [config.recoverShortRestResources]  Recover resources that recharge on a short rest.\n@param {boolean} [config.recoverLongRestResources]   Recover resources that recharge on a long rest.\n@param {RestResult} [result={}]                      Rest result being constructed.\n@protected\n/\n  _getRestResourceRecovery({recoverShortRestResources, recoverLongRestResources, ...config}={}, result={}) {\n    recoverShortRestResources ??= config.type === \"short\";\n    recoverLongRestResources ??= config.type === \"long\";\n    for ( let [k, r] of Object.entries(this.system.resources ?? {}) ) {\n      if ( Number.isNumeric(r.max) && ((recoverShortRestResources && r.sr) || (recoverLongRestResources && r.lr)) ) {\n        result.updateData[`system.resources.${k}.value`] = Number(r.max);\n      }\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRecovers expended spell slots.\n@param {RestConfiguration} [config={}]\n@param {boolean} [config.recoverShort]    Recover slots that return on short rests.\n@param {boolean} [config.recoverLong]     Recover slots that return on long rests.\n@param {RestResult} [result={}]           Rest result being constructed.\n@protected\n/\n  _getRestSpellRecovery({ recoverShort, recoverLong, ...config }={}, result={}) {\n    const restConfig = CONFIG.DND5E.restTypes[config.type];\n    if ( !this.system.spells ) return;\n\n    let types = restConfig.recoverSpellSlotTypes;\n    if ( !types ) {\n      types = new Set();\n      for ( const [key, { shortRest }] of Object.entries(CONFIG.DND5E.spellcastingTypes) ) {\n        if ( recoverLong || (recoverShort && shortRest) ) types.add(key);\n      }\n    }\n    for ( const [key, slot] of Object.entries(this.system.spells) ) {\n      if ( !types.has(slot.type) ) continue;\n      result.updateData[`system.spells.${key}.value`] = slot.max;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRecovers item uses during short or long rests.\n@param {object} [config]\n@param {boolean} [config.recoverShortRestUses=true]  Recover uses for items that recharge after a short rest.\n@param {boolean} [config.recoverLongRestUses=true]   Recover uses for items that recharge after a long rest.\n@param {boolean} [config.recoverDailyUses=true]      Recover uses for items that recharge on a new day.\n@param {RestResult} [result={}]                      Rest result being constructed.\n@protected\n/\n  async _getRestItemUsesRecovery({\n    recoverShortRestUses, recoverLongRestUses, recoverDailyUses, ...config\n  }={}, result={}) {\n    const restConfig = CONFIG.DND5E.restTypes[config.type];\n    const recovery = Array.from(restConfig.recoverPeriods ?? []);\n    if ( recoverShortRestUses ) recovery.unshift(\"sr\");\n    if ( recoverLongRestUses ) recovery.unshift(\"lr\");\n    if ( recoverDailyUses || config.newDay ) recovery.unshift(\"day\", \"dawn\", \"dusk\");\n\n    result.updateItems ??= [];\n    result.rolls ??= [];\n    for ( const item of this.items ) {\n      if ( foundry.utils.getType(item.system.recoverUses) !== \"function\" ) continue;\n      const rollData = item.getRollData();\n      const { updates, rolls } = await item.system.recoverUses(recovery, rollData);\n      if ( !foundry.utils.isEmpty(updates) ) {\n        const updateTarget = result.updateItems.find(i => i._id === item.id);\n        if ( updateTarget ) foundry.utils.mergeObject(updateTarget, updates);\n        else result.updateItems.push({ _id: item.id, ...updates });\n      }\n      result.rolls.push(...rolls);\n    }\n  }\n\n  /* -------------------------------------------- */\n  /*  Property Attribution                        */\n  /* -------------------------------------------- */\n\n  /**\nFormat an HTML breakdown for a given property.\n@param {string} attribution      The property.\n@param {object} [options]\n@param {string} [options.title]  A title for the breakdown.\n@returns {Promise<string>}\n/\n  async getAttributionData(attribution, { title }={}) {\n    switch ( attribution ) {\n      case \"attributes.ac\": return this._prepareArmorClassAttribution({ title });\n      case \"attributes.movement\": return this._prepareMovementAttribution();\n      default: return \"\";\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare a movement breakdown.\n@returns {string}\n@protected\n/\n  _prepareMovementAttribution() {\n    const { movement } = this.system.attributes;\n    const units = movement.units || defaultUnits(\"length\");\n    return Object.entries(CONFIG.DND5E.movementTypes).reduce((html, [k, label]) => {\n      const value = movement[k];\n      if ( value || (k === \"walk\") ) html += `\n        <div class=\"row\">\n          <i class=\"fas ${k}\"></i>\n          <span class=\"value\">${value ?? 0} <span class=\"units\">${units}</span></span>\n          <span class=\"label\">${label}</span>\n        </div>\n      `;\n      return html;\n    }, \"\");\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare an AC breakdown.\n@param {object} [options]\n@param {string} [options.title]  A title for the breakdown.\n@returns {Promise<string>}\n@protected\n/\n  async _prepareArmorClassAttribution({ title }={}) {\n    const rollData = this.getRollData({ deterministic: true });\n    const ac = rollData.attributes.ac;\n    const cfg = CONFIG.DND5E.armorClasses[ac.calc];\n    const attribution = [];\n\n    if ( ac.calc === \"flat\" ) {\n      attribution.push({\n        label: game.i18n.localize(\"DND5E.ArmorClassFlat\"),\n        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n        value: ac.flat\n      });\n      return new PropertyAttribution(this, attribution, \"attributes.ac\", { title }).renderTooltip();\n    }\n\n    // Base AC Attribution\n    switch ( ac.calc ) {\n\n      // Natural armor\n      case \"natural\":\n        attribution.push({\n          label: game.i18n.localize(\"DND5E.ArmorClassNatural\"),\n          mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n          value: ac.flat\n        });\n        break;\n\n      default:\n        const formula = ac.calc === \"custom\" ? ac.formula : cfg.formula;\n        let base = ac.base;\n        const dataRgx = new RegExp(/@([a-z.0-9_-]+)/gi);\n        for ( const [match, term] of formula.matchAll(dataRgx) ) {\n          const value = String(foundry.utils.getProperty(rollData, term));\n          if ( (term === \"attributes.ac.armor\") || (value === \"0\") ) continue;\n          if ( Number.isNumeric(value) ) base -= Number(value);\n          attribution.push({\n            label: match,\n            mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n            value\n          });\n        }\n        const armorInFormula = formula.includes(\"@attributes.ac.armor\");\n        let label = game.i18n.localize(\"DND5E.PropertyBase\");\n        if ( armorInFormula ) label = this.armor?.name ?? game.i18n.localize(\"DND5E.ArmorClassUnarmored\");\n        attribution.unshift({\n          label,\n          mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n          value: base\n        });\n        break;\n    }\n\n    // Shield\n    if ( ac.shield !== 0 ) attribution.push({\n      label: this.shield?.name ?? game.i18n.localize(\"DND5E.EquipmentShield\"),\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      value: ac.shield\n    });\n\n    // Bonus\n    if ( ac.bonus !== 0 ) attribution.push(...this._prepareActiveEffectAttributions(\"system.attributes.ac.bonus\"));\n\n    // Cover\n    if ( ac.cover !== 0 ) attribution.push({\n      label: game.i18n.localize(\"DND5E.Cover\"),\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      value: ac.cover\n    });\n\n    if ( attribution.length ) {\n      return new PropertyAttribution(this, attribution, \"attributes.ac\", { title }).renderTooltip();\n    }\n\n    return \"\";\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nBreak down all of the Active Effects affecting a given target property.\n@param {string} target               The data property being targeted.\n@returns {AttributionDescription[]}  Any active effects that modify that property.\n@protected\n/\n  _prepareActiveEffectAttributions(target) {\n    const rollData = this.getRollData({ deterministic: true });\n    const attributions = [];\n    for ( const e of this.allApplicableEffects() ) {\n      let source = e.sourceName;\n      if ( !e.origin || (e.origin === this.uuid) ) source = e.name;\n      if ( !source || e.disabled || e.isSuppressed ) continue;\n      const value = e.changes.reduce((n, change) => {\n        if ( change.key !== target ) return n;\n        if ( change.mode !== CONST.ACTIVE_EFFECT_MODES.ADD ) return n;\n        return n + simplifyBonus(change.value, rollData);\n      }, 0);\n      if ( value ) attributions.push({ value, label: source, document: e, mode: CONST.ACTIVE_EFFECT_MODES.ADD });\n    }\n    return attributions;\n  }\n\n  /* -------------------------------------------- */\n  /*  Conversion & Transformation                 */\n  /* -------------------------------------------- */\n\n  /**\nFetch stats from the original actor for data preparation.\n@returns {{ originalSaves: object|null, originalSkills: object|null }}\n/\n  getOriginalStats() {\n    // Retrieve data for polymorphed actors\n    let originalSaves = null;\n    let originalSkills = null;\n    if ( this.isPolymorphed ) {\n      const transformOptions = this.flags.dnd5e?.transformOptions;\n      const original = game.actors?.get(this.flags.dnd5e?.originalActor);\n      if ( original ) {\n        if ( transformOptions.mergeSaves ) originalSaves = original.system.abilities;\n        if ( transformOptions.mergeSkills ) originalSkills = original.system.skills;\n      }\n    }\n    return { originalSaves, originalSkills };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nOptions that determine what properties of the original actor are kept and which are replaced with\nthe target actor.\n@typedef {object} TransformationOptions\n@property {boolean} [keepPhysical=false]       Keep physical abilities (str, dex, con)\n@property {boolean} [keepMental=false]         Keep mental abilities (int, wis, cha)\n@property {boolean} [keepSaves=false]          Keep saving throw proficiencies\n@property {boolean} [keepSkills=false]         Keep skill proficiencies\n@property {boolean} [mergeSaves=false]         Take the maximum of the save proficiencies\n@property {boolean} [mergeSkills=false]        Take the maximum of the skill proficiencies\n@property {boolean} [keepClass=false]          Keep proficiency bonus\n@property {boolean} [keepFeats=false]          Keep features\n@property {boolean} [keepSpells=false]         Keep spells and spellcasting ability\n@property {boolean} [keepItems=false]          Keep items\n@property {boolean} [keepBio=false]            Keep biography\n@property {boolean} [keepVision=false]         Keep vision\n@property {boolean} [keepSelf=false]           Keep self\n@property {boolean} [keepAE=false]             Keep all effects\n@property {boolean} [keepOriginAE=true]        Keep effects which originate on this actor\n@property {boolean} [keepOtherOriginAE=true]   Keep effects which originate on another actor\n@property {boolean} [keepSpellAE=true]         Keep effects which originate from actors spells\n@property {boolean} [keepFeatAE=true]          Keep effects which originate from actors features\n@property {boolean} [keepEquipmentAE=true]     Keep effects which originate on actors equipment\n@property {boolean} [keepClassAE=true]         Keep effects which originate from actors class/subclass\n@property {boolean} [keepBackgroundAE=true]    Keep effects which originate from actors background\n@property {boolean} [keepHP=false]             Keep HP & HD\n@property {boolean} [keepType=false]           Keep creature type\n@property {boolean} [addTemp=false]            Add temporary hit points equal to the target's max HP\n@property {boolean} [transformTokens=true]     Transform linked tokens too\n@property {string} [preset]                    The transformation preset used (if any).\n/\n\n  /**\nTransform this Actor into another one.\n@param {Actor5e} target                           The target Actor.\n@param {TransformationOptions} [options={}]       Options that determine how the transformation is performed.\n@param {object} [sheetOptions]\n@param {boolean} [sheetOptions.renderSheet=true]  Render the sheet of the transformed actor after the polymorph\n@returns {Promise<Array<Token>>|null}             Updated token if the transformation was performed.\n/\n  async transformInto(target, { keepPhysical=false, keepMental=false, keepSaves=false, keepSkills=false,\n    mergeSaves=false, mergeSkills=false, keepClass=false, keepFeats=false, keepSpells=false, keepItems=false,\n    keepBio=false, keepVision=false, keepSelf=false, keepAE=false, keepOriginAE=true, keepOtherOriginAE=true,\n    keepSpellAE=true, keepEquipmentAE=true, keepFeatAE=true, keepClassAE=true, keepBackgroundAE=true,\n    keepHP=false, keepType=false, addTemp=false, transformTokens=true, preset}={}, {renderSheet=true}={}) {\n\n    // Ensure the player is allowed to polymorph\n    const allowed = game.settings.get(\"dnd5e\", \"allowPolymorphing\");\n    if ( !allowed && !game.user.isGM ) {\n      ui.notifications.warn(\"DND5E.PolymorphWarn\", {localize: true});\n      return null;\n    }\n\n    // Get the original Actor data and the new source data\n    const o = this.toObject();\n    o.flags.dnd5e = o.flags.dnd5e || {};\n    o.flags.dnd5e.transformOptions = {mergeSkills, mergeSaves};\n    const source = target.toObject();\n\n    if ( keepSelf ) {\n      o.img = source.img;\n      o.name = `${o.name} (${game.i18n.localize(\"DND5E.PolymorphSelf\")})`;\n    }\n\n    // Prepare new data to merge from the source\n    const d = foundry.utils.mergeObject(foundry.utils.deepClone({\n      type: o.type, // Remain the same actor type\n      name: `${o.name} (${source.name})`, // Append the new shape to your old name\n      system: source.system, // Get the systemdata model of your new form\n      items: source.items, // Get the items of your new form\n      effects: o.effects.concat(source.effects), // Combine active effects from both forms\n      img: source.img, // New appearance\n      ownership: o.ownership, // Use the original actor permissions\n      folder: o.folder, // Be displayed in the same sidebar folder\n      flags: o.flags, // Use the original actor flags\n      prototypeToken: { name: `${o.name} (${source.name})`, texture: {}, sight: {}, detectionModes: [] } // Set a new empty token\n    }), keepSelf ? o : {}); // Keeps most of original actor\n\n    // Specifically delete some data attributes\n    delete d.system.resources; // Don't change your resource pools\n    delete d.system.currency; // Don't lose currency\n    delete d.system.bonuses; // Don't lose global bonuses\n    if ( keepSpells ) delete d.system.attributes.spellcasting; // Keep spellcasting ability if retaining spells.\n\n    // Specific additional adjustments\n    d.system.details.alignment = o.system.details.alignment; // Don't change alignment\n    d.system.attributes.exhaustion = o.system.attributes.exhaustion; // Keep your prior exhaustion level\n    d.system.attributes.inspiration = o.system.attributes.inspiration; // Keep inspiration\n    d.system.spells = o.system.spells; // Keep spell slots\n    d.system.attributes.ac.flat = target.system.attributes.ac.value; // Override AC\n\n    // Token appearance updates\n    for ( const k of [\"width\", \"height\", \"alpha\", \"lockRotation\"] ) {\n      d.prototypeToken[k] = source.prototypeToken[k];\n    }\n    for ( const k of [\"offsetX\", \"offsetY\", \"scaleX\", \"scaleY\", \"src\", \"tint\"] ) {\n      d.prototypeToken.texture[k] = source.prototypeToken.texture[k];\n    }\n    d.prototypeToken.ring = source.prototypeToken.ring;\n    for ( const k of [\"bar1\", \"bar2\", \"displayBars\", \"displayName\", \"disposition\", \"rotation\", \"elevation\"] ) {\n      d.prototypeToken[k] = o.prototypeToken[k];\n    }\n\n    if ( !keepSelf ) {\n      const sightSource = keepVision ? o.prototypeToken : source.prototypeToken;\n      for ( const k of [\"range\", \"angle\", \"visionMode\", \"color\", \"attenuation\", \"brightness\", \"saturation\", \"contrast\"] ) {\n        d.prototypeToken.sight[k] = sightSource.sight[k];\n      }\n      d.prototypeToken.sight.enabled = o.prototypeToken.sight.enabled;\n      d.prototypeToken.detectionModes = sightSource.detectionModes;\n\n      // Transfer ability scores\n      const abilities = d.system.abilities;\n      for ( let k of Object.keys(abilities) ) {\n        const oa = o.system.abilities[k];\n        const prof = abilities[k].proficient;\n        const type = CONFIG.DND5E.abilities[k]?.type;\n        if ( keepPhysical && (type === \"physical\") ) abilities[k] = oa;\n        else if ( keepMental && (type === \"mental\") ) abilities[k] = oa;\n\n        // Set saving throw proficiencies.\n        if ( keepSaves && oa ) abilities[k].proficient = oa.proficient;\n        else if ( mergeSaves && oa ) abilities[k].proficient = Math.max(prof, oa.proficient);\n        else abilities[k].proficient = source.system.abilities[k].proficient;\n      }\n\n      // Transfer skills\n      if ( keepSkills ) d.system.skills = o.system.skills;\n      else if ( mergeSkills ) {\n        for ( let [k, s] of Object.entries(d.system.skills) ) {\n          s.value = Math.max(s.value, o.system.skills[k]?.value ?? 0);\n        }\n      }\n\n      // Keep specific items from the original data\n      d.items = d.items.concat(o.items.filter(i => {\n        if ( [\"class\", \"subclass\"].includes(i.type) ) return keepClass || keepHP;\n        else if ( i.type === \"feat\" ) return keepFeats;\n        else if ( i.type === \"spell\" ) return keepSpells;\n        else if ( i.type === \"race\" ) return keepType;\n        else return keepItems;\n      }));\n\n      // Transfer classes for NPCs\n      if ( !keepClass && (\"cr\" in d.system.details) ) {\n        if ( keepHP ) {\n          let profOverride = d.effects.findSplice(e => e._id === staticID(\"dnd5eTransformProf\"));\n          if ( !profOverride ) profOverride = new ActiveEffect.implementation({\n            _id: staticID(\"dnd5eTransformProf\"),\n            name: game.i18n.localize(\"DND5E.Proficiency\"),\n            img: \"icons/skills/social/diplomacy-peace-alliance.webp\",\n            disabled: false\n          }).toObject();\n          profOverride.changes = [{\n            key: \"system.attributes.prof\",\n            mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n            value: target.system.attributes.prof\n          }];\n          d.effects.push(profOverride);\n        } else {\n          const cls = new dnd5e.dataModels.item.ClassData({ levels: d.system.details.cr });\n          d.items.push({\n            type: \"class\",\n            name: game.i18n.localize(\"DND5E.PolymorphTmpClass\"),\n            system: cls.toObject()\n          });\n        }\n      }\n\n      // Keep biography\n      if ( keepBio ) d.system.details.biography = o.system.details.biography;\n\n      // Keep senses\n      if ( keepVision ) d.system.traits.senses = o.system.traits.senses;\n\n      // Keep creature type\n      if ( keepType ) d.system.details.type = o.system.details.type;\n\n      // Keep HP & HD\n      if ( keepHP ) d.system.attributes.hp = { ...this.system.attributes.hp };\n\n      // Add temporary hit points\n      if ( addTemp ) d.system.attributes.hp.temp = target.system.attributes.hp.max;\n\n      // Remove active effects\n      const oEffects = foundry.utils.deepClone(d.effects);\n      const originEffectIds = new Set(oEffects.filter(effect => {\n        return !effect.origin || effect.origin === this.uuid;\n      }).map(e => e._id));\n      d.effects = d.effects.filter(e => {\n        if ( keepAE ) return true;\n        if ( keepHP && !keepClass && (e._id === staticID(\"dnd5eTransformProf\")) ) return true;\n        const origin = e.origin?.startsWith(\"Actor\") || e.origin?.startsWith(\"Item\") ? fromUuidSync(e.origin) : {};\n        const originIsSelf = origin?.parent?.uuid === this.uuid;\n        const isOriginEffect = originEffectIds.has(e._id);\n        if ( isOriginEffect ) return keepOriginAE;\n        if ( !isOriginEffect && !originIsSelf ) return keepOtherOriginAE;\n        if ( origin.type === \"spell\" ) return keepSpellAE;\n        if ( origin.type === \"feat\" ) return keepFeatAE;\n        if ( origin.type === \"background\" ) return keepBackgroundAE;\n        if ( [\"subclass\", \"class\"].includes(origin.type) ) return keepClassAE;\n        if ( [\"equipment\", \"weapon\", \"tool\", \"loot\", \"container\"].includes(origin.type) ) return keepEquipmentAE;\n        return true;\n      });\n    }\n\n    // Set a random image if source is configured that way\n    if ( source.prototypeToken.randomImg ) {\n      const images = await target.getTokenImages();\n      d.prototypeToken.texture.src = images[Math.floor(Math.random() * images.length)];\n    }\n\n    // Set new data flags\n    if ( !this.isPolymorphed || !d.flags.dnd5e.originalActor ) d.flags.dnd5e.originalActor = this.id;\n    d.flags.dnd5e.isPolymorphed = true;\n\n    // Gather previous actor data\n    const previousActorIds = this.getFlag(\"dnd5e\", \"previousActorIds\") || [];\n    previousActorIds.push(this._id);\n    foundry.utils.setProperty(d.flags, \"dnd5e.previousActorIds\", previousActorIds);\n\n    // Update unlinked Tokens, and grab a copy of any actorData adjustments to re-apply\n    if ( this.isToken ) {\n      const tokenData = d.prototypeToken;\n      delete d.prototypeToken;\n      tokenData.delta = d;\n      tokenData.elevation = this.token.elevation;\n      tokenData.rotation = this.token.rotation;\n      const previousActorData = this.token.delta.toObject();\n      foundry.utils.setProperty(tokenData, \"flags.dnd5e.previousActorData\", previousActorData);\n      await this.sheet?.close();\n      const update = await this.token.update(tokenData);\n      if ( renderSheet ) this.sheet?.render(true);\n      return update;\n    }\n\n    // Close sheet for non-transformed Actor\n    await this.sheet?.close();\n\n    /**\nA hook event that fires just before the actor is transformed.\n@function dnd5e.transformActor\n@memberof hookEvents\n@param {Actor5e} actor                  The original actor before transformation.\n@param {Actor5e} target                 The target actor into which to transform.\n@param {object} data                    The data that will be used to create the new transformed actor.\n@param {TransformationOptions} options  Options that determine how the transformation is performed.\n@param {object} [options]\n/\n    Hooks.callAll(\"dnd5e.transformActor\", this, target, d, {\n      keepPhysical, keepMental, keepSaves, keepSkills, mergeSaves, mergeSkills, keepClass, keepFeats, keepSpells,\n      keepItems, keepBio, keepVision, keepSelf, keepAE, keepOriginAE, keepOtherOriginAE, keepSpellAE,\n      keepEquipmentAE, keepFeatAE, keepClassAE, keepBackgroundAE, keepHP, keepType, addTemp, transformTokens, preset\n    }, {renderSheet});\n\n    // Create new Actor with transformed data\n    const newActor = await this.constructor.create(d, {renderSheet});\n\n    // Update placed Token instances\n    if ( !transformTokens ) return;\n    const tokens = this.getActiveTokens(true);\n    const updates = tokens.map(t => {\n      const newTokenData = foundry.utils.deepClone(d.prototypeToken);\n      newTokenData._id = t.id;\n      newTokenData.actorId = newActor.id;\n      newTokenData.actorLink = true;\n      newTokenData.elevation = t.document.elevation;\n      newTokenData.rotation = t.document.rotation;\n\n      const dOriginalActor = foundry.utils.getProperty(d, \"flags.dnd5e.originalActor\");\n      foundry.utils.setProperty(newTokenData, \"flags.dnd5e.originalActor\", dOriginalActor);\n      foundry.utils.setProperty(newTokenData, \"flags.dnd5e.isPolymorphed\", true);\n      return newTokenData;\n    });\n    return canvas.scene?.updateEmbeddedDocuments(\"Token\", updates);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIf this actor was transformed with transformTokens enabled, then its\nactive tokens need to be returned to their original state. If not, then\nwe can safely just delete this actor.\n@param {object} [options]\n@param {boolean} [options.renderSheet=true]  Render Sheet after revert the transformation.\n@returns {Promise<Actor>|null}  Original actor if it was reverted.\n/\n  async revertOriginalForm({renderSheet=true}={}) {\n    if ( !this.isPolymorphed ) return;\n    if ( !this.isOwner ) {\n      ui.notifications.warn(\"DND5E.PolymorphRevertWarn\", {localize: true});\n      return null;\n    }\n\n    /**\nA hook event that fires just before the actor is reverted to original form.\n@function dnd5e.revertOriginalForm\n@memberof hookEvents\n@param {Actor} this                 The original actor before transformation.\n@param {object} [options]\n/\n    Hooks.callAll(\"dnd5e.revertOriginalForm\", this, {renderSheet});\n    const previousActorIds = this.getFlag(\"dnd5e\", \"previousActorIds\") ?? [];\n    const isOriginalActor = !previousActorIds.length;\n    const isRendered = this.sheet.rendered;\n\n    // Obtain a reference to the original actor\n    const original = game.actors.get(this.getFlag(\"dnd5e\", \"originalActor\"));\n\n    // If we are reverting an unlinked token, grab the previous actorData, and create a new token\n    if ( this.isToken ) {\n      const baseActor = original ? original : game.actors.get(this.token.actorId);\n      if ( !baseActor ) {\n        ui.notifications.warn(game.i18n.format(\"DND5E.PolymorphRevertNoOriginalActorWarn\", {\n          reference: this.getFlag(\"dnd5e\", \"originalActor\")\n        }));\n        return;\n      }\n      const prototypeTokenData = (await baseActor.getTokenDocument()).toObject();\n      const actorData = this.token.getFlag(\"dnd5e\", \"previousActorData\");\n      const tokenUpdate = this.token.toObject();\n      actorData._id = tokenUpdate.delta._id;\n      tokenUpdate.delta = actorData;\n\n      for ( const k of [\"width\", \"height\", \"alpha\", \"lockRotation\", \"name\"] ) {\n        tokenUpdate[k] = prototypeTokenData[k];\n      }\n      for ( const k of [\"offsetX\", \"offsetY\", \"scaleX\", \"scaleY\", \"src\", \"tint\"] ) {\n        tokenUpdate.texture[k] = prototypeTokenData.texture[k];\n      }\n      tokenUpdate.ring = prototypeTokenData.ring;\n      tokenUpdate.sight = prototypeTokenData.sight;\n      tokenUpdate.detectionModes = prototypeTokenData.detectionModes;\n\n      await this.sheet.close();\n      await canvas.scene?.deleteEmbeddedDocuments(\"Token\", [this.token._id]);\n      const token = await TokenDocument.implementation.create(tokenUpdate, {\n        parent: canvas.scene, keepId: true, render: true\n      });\n      if ( isOriginalActor ) {\n        await this.unsetFlag(\"dnd5e\", \"isPolymorphed\");\n        await this.unsetFlag(\"dnd5e\", \"previousActorIds\");\n        await this.token.unsetFlag(\"dnd5e\", \"previousActorData\");\n      }\n      if ( isRendered && renderSheet ) token.actor?.sheet?.render(true);\n      return token;\n    }\n\n    if ( !original ) {\n      ui.notifications.warn(game.i18n.format(\"DND5E.PolymorphRevertNoOriginalActorWarn\", {\n        reference: this.getFlag(\"dnd5e\", \"originalActor\")\n      }));\n      return;\n    }\n\n    // Get the Tokens which represent this actor\n    if ( canvas.ready ) {\n      const tokens = this.getActiveTokens(true);\n      const tokenData = (await original.getTokenDocument()).toObject();\n      const tokenUpdates = tokens.map(t => {\n        const update = foundry.utils.deepClone(tokenData);\n        update._id = t.id;\n        update.elevation = t.document.elevation;\n        update.rotation = t.document.rotation;\n        delete update.x;\n        delete update.y;\n        return update;\n      });\n      await canvas.scene.updateEmbeddedDocuments(\"Token\", tokenUpdates, { diff: false, recursive: false });\n    }\n    if ( isOriginalActor ) {\n      await this.unsetFlag(\"dnd5e\", \"isPolymorphed\");\n      await this.unsetFlag(\"dnd5e\", \"previousActorIds\");\n    }\n\n    // Delete the polymorphed version(s) of the actor, if possible\n    if ( game.user.isGM ) {\n      const idsToDelete = previousActorIds.filter(id =>\n        id !== original.id // Is not original Actor Id\n        && game.actors?.get(id) // Actor still exists\n      ).concat([this.id]); // Add this id\n\n      await Actor.implementation.deleteDocuments(idsToDelete);\n    } else if ( isRendered ) {\n      this.sheet?.close();\n    }\n    if ( isRendered && renderSheet ) original.sheet?.render(isRendered);\n    return original;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd additional system-specific sidebar directory context menu options for Actor documents\n@param {jQuery | HTMLElement} html  The sidebar HTML\n@param {Array} entryOptions         The default array of context menu options\n/\n  static addDirectoryContextOptions(html, entryOptions) {\n    entryOptions.push({\n      name: \"DND5E.PolymorphRestoreTransformation\",\n      icon: '<i class=\"fa-solid fa-backward\"></i>',\n      callback: li => {\n        li = li instanceof HTMLElement ? li : li[0];\n        const actor = game.actors.get(li.dataset.documentId ?? li.dataset.entryId);\n        return actor.revertOriginalForm();\n      },\n      condition: li => {\n        li = li instanceof HTMLElement ? li : li[0];\n        const allowed = game.settings.get(\"dnd5e\", \"allowPolymorphing\");\n        if ( !allowed && !game.user.isGM ) return false;\n        const actor = game.actors.get(li.dataset.documentId ?? li.dataset.entryId);\n        return actor && actor.isPolymorphed;\n      },\n      group: \"system\"\n    }, {\n      name: \"DND5E.Group.Primary.Set\",\n      icon: '<i class=\"fa-solid fa-star\"></i>',\n      callback: li => {\n        li = li instanceof HTMLElement ? li : li[0];\n        game.settings.set(\"dnd5e\", \"primaryParty\", { actor: game.actors.get(li.dataset.documentId ?? li.dataset.entryId) });\n      },\n      condition: li => {\n        li = li instanceof HTMLElement ? li : li[0];\n        const actor = game.actors.get(li.dataset.documentId ?? li.dataset.entryId);\n        const primary = game.settings.get(\"dnd5e\", \"primaryParty\")?.actor;\n        return game.user.isGM && (actor?.type === \"group\")\n          && (actor.system.type.value === \"party\") && (actor !== primary);\n      },\n      group: \"system\"\n    }, {\n      name: \"DND5E.Group.Primary.Remove\",\n      icon: '<i class=\"fa-regular fa-star\"></i>',\n      callback: li => {\n        game.settings.set(\"dnd5e\", \"primaryParty\", { actor: null });\n      },\n      condition: li => {\n        li = li instanceof HTMLElement ? li : li[0];\n        const actor = game.actors.get(li.dataset.documentId ?? li.dataset.entryId);\n        const primary = game.settings.get(\"dnd5e\", \"primaryParty\")?.actor;\n        return game.user.isGM && (actor === primary);\n      },\n      group: \"system\"\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd class to actor entry representing the primary group.\n@param {jQuery | HTMLElement} html\n/\n  static onRenderActorDirectory(html) {\n    html = html instanceof HTMLElement ? html : html[0];\n    const primaryParty = game.settings.get(\"dnd5e\", \"primaryParty\")?.actor;\n    if ( primaryParty ) {\n      const element = html?.querySelector(`[data-entry-id=\"${primaryParty.id}\"]`);\n      element?.classList.add(\"primary-party\");\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nFormat a type object into a string.\n@param {object} typeData          The type data to convert to a string.\n@returns {string}\n/\n  static formatCreatureType(typeData) {\n    if ( typeof typeData === \"string\" ) return typeData; // Backwards compatibility\n    let localizedType;\n    if ( typeData.value === \"custom\" ) {\n      localizedType = typeData.custom;\n    } else if ( typeData.value in CONFIG.DND5E.creatureTypes ) {\n      const code = CONFIG.DND5E.creatureTypes[typeData.value];\n      localizedType = game.i18n.localize(typeData.swarm ? code.plural : code.label);\n    }\n    let type = localizedType;\n    if ( typeData.swarm ) {\n      type = game.i18n.format(\"DND5E.CreatureSwarmPhrase\", {\n        size: game.i18n.localize(CONFIG.DND5E.actorSizes[typeData.swarm].label),\n        type: localizedType\n      });\n    }\n    if (typeData.subtype) type = `${type} (${typeData.subtype})`;\n    return type;\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers                */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _onUpdate(data, options, userId) {\n    super._onUpdate(data, options, userId);\n\n    const isHpUpdate = !!data.system?.attributes?.hp;\n\n    if ( userId === game.userId ) {\n      if ( isHpUpdate ) await this.updateBloodied(options);\n      await this.updateEncumbrance(options);\n      this._onUpdateExhaustion(data, options);\n    }\n\n    const hp = options.dnd5e?.hp;\n    if ( isHpUpdate && hp && !options.isRest && !options.isAdvancement ) {\n      const curr = this.system.attributes.hp;\n      const changes = {\n        hp: curr.value - hp.value,\n        temp: curr.temp - hp.temp\n      };\n      changes.total = changes.hp + changes.temp;\n\n      if ( Number.isInteger(changes.total) && (changes.total !== 0) ) {\n        this._displayTokenEffect(changes);\n        if ( !game.settings.get(\"dnd5e\", \"disableConcentration\") && (userId === game.userId) && (changes.total < 0)\n          && (options.dnd5e?.concentrationCheck !== false) && (curr.value < curr.effectiveMax) ) {\n          this.challengeConcentration({ dc: this.getConcentrationDC(-changes.total) });\n        }\n\n        /**\nA hook event that fires when an actor is damaged or healed by any means. The actual name\nof the hook will depend on the change in hit points.\n@function dnd5e.damageActor\n@memberof hookEvents\n@param {Actor5e} actor                                       The actor that had their hit points reduced.\n@param {{hp: number, temp: number, total: number}} changes   The changes to hit points.\n@param {object} update                                       The original update delta.\n@param {string} userId                                       Id of the user that performed the update.\n/\n        Hooks.callAll(`dnd5e.${changes.total > 0 ? \"heal\" : \"damage\"}Actor`, this, changes, data, userId);\n      }\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _onDelete(options, userId) {\n    super._onDelete(options, userId);\n\n    const origin = this.getFlag(\"dnd5e\", \"summon.origin\");\n    // TODO: Replace with parseUuid once V11 support is dropped\n    if ( origin ) dnd5e.registry.summons.untrack(origin.split(\".Item.\")[0], this.uuid);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _onCreateDescendantDocuments(parent, collection, documents, data, options, userId) {\n    if ( (userId === game.userId) && (collection === \"items\") ) await this.updateEncumbrance(options);\n    super._onCreateDescendantDocuments(parent, collection, documents, data, options, userId);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId) {\n    if ( (userId === game.userId) && (collection === \"items\") ) await this.updateEncumbrance(options);\n    super._onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _onDeleteDescendantDocuments(parent, collection, documents, ids, options, userId) {\n    if ( (userId === game.userId) ) {\n      if ( collection === \"items\" ) await this.updateEncumbrance(options);\n      await this._clearFavorites(documents);\n    }\n    super._onDeleteDescendantDocuments(parent, collection, documents, ids, options, userId);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nFlash ring & display changes to health as scrolling combat text.\n@param {object} changes          Object of changes to hit points.\n@param {number} changes.hp       Changes to `hp.value`.\n@param {number} changes.temp     The change to `hp.temp`.\n@param {number} changes.total    The total change to hit points.\n@protected\n/\n  _displayTokenEffect(changes) {\n    let key;\n    let value;\n    if ( changes.hp < 0 ) {\n      key = \"damage\";\n      value = changes.total;\n    } else if ( changes.hp > 0 ) {\n      key = \"healing\";\n      value = changes.total;\n    } else if ( changes.temp ) {\n      key = \"temp\";\n      value = changes.temp;\n    }\n    if ( !key || !value ) return;\n\n    const tokens = this.isToken ? [this.token] : this.getActiveTokens(true, true);\n    if ( !tokens.length ) return;\n\n    const pct = Math.clamp(Math.abs(value) / this.system.attributes.hp.max, 0, 1);\n    const fill = CONFIG.DND5E.tokenHPColors[key];\n\n    for ( const token of tokens ) {\n      if ( !token.object?.visible || token.isSecret ) continue;\n      if ( token.hasDynamicRing ) token.flashRing(key);\n      const t = token.object;\n      canvas.interface.createScrollingText(t.center, value.signedString(), {\n        anchor: CONST.TEXT_ANCHOR_POINTS.TOP,\n        // Adapt the font size relative to the Actor's HP total to emphasize more significant blows\n        fontSize: 16 + (32 * pct), // Range between [16, 48]\n        fill: fill,\n        stroke: 0x000000,\n        strokeThickness: 4,\n        jitter: 0.25\n      });\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async toggleStatusEffect(statusId, options) {\n    const created = await super.toggleStatusEffect(statusId, options);\n    const status = CONFIG.statusEffects.find(e => e.id === statusId);\n    if ( !(created instanceof ActiveEffect) || !status.exclusiveGroup ) return created;\n\n    const others = CONFIG.statusEffects\n      .filter(e => (e.id !== statusId) && (e.exclusiveGroup === status.exclusiveGroup) && this.effects.has(e._id));\n    if ( others.length ) await this.deleteEmbeddedDocuments(\"ActiveEffect\", others.map(e => e._id));\n\n    return created;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nTODO: Perform this as part of Actor._preUpdateOperation instead when it becomes available in v12.\nHandle syncing the Actor's exhaustion level with the ActiveEffect.\n@param {object} data                          The Actor's update delta.\n@param {DocumentModificationContext} options  Additional options supplied with the update.\n@returns {Promise<ActiveEffect|void>}\n@protected\n/\n  async _onUpdateExhaustion(data, options) {\n    const level = foundry.utils.getProperty(data, \"system.attributes.exhaustion\");\n    if ( !Number.isFinite(level) ) return;\n    let effect = this.effects.get(ActiveEffect5e.ID.EXHAUSTION);\n    if ( level < 1 ) return effect?.delete();\n    else if ( effect ) {\n      const originalExhaustion = foundry.utils.getProperty(options, \"dnd5e.originalExhaustion\");\n      return effect.update({ \"flags.dnd5e.exhaustionLevel\": level }, { dnd5e: { originalExhaustion } });\n    } else {\n      effect = await ActiveEffect.implementation.fromStatusEffect(\"exhaustion\", { parent: this });\n      effect.updateSource({ \"flags.dnd5e.exhaustionLevel\": level });\n      return ActiveEffect.implementation.create(effect, { parent: this, keepId: true });\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle applying/removing the bloodied status.\n@param {DocumentModificationContext} options  Additional options supplied with the update.\n@returns {Promise<ActiveEffect>|void}\n/\n  updateBloodied(options) {\n    const hp = this.system.attributes?.hp;\n    if ( !hp?.effectiveMax || (game.settings.get(\"dnd5e\", \"bloodied\") === \"none\") ) return;\n\n    const effect = this.effects.get(ActiveEffect5e.ID.BLOODIED);\n    if ( hp.value > hp.effectiveMax * CONFIG.DND5E.bloodied.threshold ) return effect?.delete();\n    if ( effect ) return;\n\n    return ActiveEffect.implementation.create({\n      _id: ActiveEffect5e.ID.BLOODIED,\n      name: game.i18n.localize(CONFIG.DND5E.bloodied.name),\n      img: CONFIG.DND5E.bloodied.icon,\n      statuses: [\"bloodied\"]\n    }, { parent: this, keepId: true });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle applying/removing encumbrance statuses.\n@param {DocumentModificationContext} options  Additional options supplied with the update.\n@returns {Promise<ActiveEffect>|void}\n/\n  updateEncumbrance(options) {\n    const encumbrance = this.system.attributes?.encumbrance;\n    if ( !encumbrance || (game.settings.get(\"dnd5e\", \"encumbrance\") === \"none\") ) return;\n    const statuses = [];\n    const variant = game.settings.get(\"dnd5e\", \"encumbrance\") === \"variant\";\n    if ( encumbrance.value > encumbrance.thresholds.maximum ) statuses.push(\"exceedingCarryingCapacity\");\n    if ( (encumbrance.value > encumbrance.thresholds.heavilyEncumbered) && variant ) statuses.push(\"heavilyEncumbered\");\n    if ( (encumbrance.value > encumbrance.thresholds.encumbered) && variant ) statuses.push(\"encumbered\");\n\n    const effect = this.effects.get(ActiveEffect5e.ID.ENCUMBERED);\n    if ( !statuses.length ) return effect?.delete();\n\n    const effectData = { ...CONFIG.DND5E.encumbrance.effects[statuses[0]], statuses };\n    if ( effect ) {\n      const originalEncumbrance = effect.statuses.first();\n      return effect.update(effectData, { dnd5e: { originalEncumbrance } });\n    }\n\n    return ActiveEffect.implementation.create(\n      { _id: ActiveEffect5e.ID.ENCUMBERED, ...effectData },\n      { parent: this, keepId: true }\n    );\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle clearing favorited entries that were deleted.\n@param {Document[]} documents  The deleted Documents.\n@returns {Promise<Actor5e>|void}\n@protected\n/\n  _clearFavorites(documents) {\n    if ( !(\"favorites\" in this.system) ) return;\n    const ids = new Set(documents.map(d => d.getRelativeUUID(this)));\n    const favorites = this.system.favorites.filter(f => !ids.has(f.id));\n    return this.update({ \"system.favorites\": favorites });\n  }\n}\n\n/* -------------------------------------------- */\n\n/**\n@extends {Map<string, Set<Item5e>>}"
    },
    {
      "name": "Bastion",
      "extends": null,
      "file": "module\\documents\\actor\\bastion.mjs",
      "jsDoc": ""
    },
    {
      "name": "BastionAttackDialog",
      "extends": "Dialog5e",
      "file": "module\\documents\\actor\\bastion.mjs",
      "jsDoc": "@typedef BastionTurnResult\n@property {string} [order]             The order that was completed, if any.\n@property {number} [gold]              Gold generated.\n@property {BastionTurnItem[]} [items]  Items created.\n/\n\n/**\n@typedef BastionTurnItem\n@property {string} uuid      The UUID of the generated Item.\n@property {number} quantity  The quantity of items generated.\n/\n\n/**\nA singleton class that manages global Bastion activity.\n/\nexport default class Bastion {\n  /**\nThe template for the chat card summary of a bastion attack.\n@type {string}\n/\n  static ATTACK_TEMPLATE = \"systems/dnd5e/templates/chat/bastion-attack-summary.hbs\";\n\n  /**\nThe template for the chat card summary of a bastion turn.\n@type {string}\n/\n  static TURN_TEMPLATE = \"systems/dnd5e/templates/chat/bastion-turn-summary.hbs\";\n\n  /* -------------------------------------------- */\n  /*  Public API                                  */\n  /* -------------------------------------------- */\n\n  /**\nAdvance all bastions by a turn.\n@returns {Promise<void>}\n/\n  async advanceAllBastions() {\n    // TODO: Should this advance game.time?\n    const { duration } = game.settings.get(\"dnd5e\", \"bastionConfiguration\");\n    const haveBastions = game.actors.filter(a => (a.type === \"character\") && a.itemTypes.facility.length);\n    for ( const actor of haveBastions ) await this.advanceAllFacilities(actor, { duration });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdvance all the facilities of a given Actor by one bastion turn.\n@param {Actor5e} actor                   The actor.\n@param {object} [options]\n@param {number} [options.duration=7]     The number of days the bastion turn spanned.\n@param {boolean} [options.summary=true]  Print a chat message summary of the turn.\n@returns {Promise<void>}\n/\n  async advanceAllFacilities(actor, { duration=7, summary=true }={}) {\n    const results = { orders: [], items: [], gold: 0 };\n    for ( const facility of actor.itemTypes.facility ) {\n      const { order, gold, items } = await this.advanceTurn(facility, { duration });\n      if ( !order || (order === \"maintain\") ) continue;\n      if ( gold ) results.gold += gold;\n      if ( items ) results.items.push(...items);\n      results.orders.push({ id: facility.id, order });\n    }\n\n    if ( summary ) {\n      results.gold = { value: results.gold, claimed: false };\n      const content = await this.#renderTurnSummary(actor, results);\n      await ChatMessage.implementation.create({\n        content,\n        speaker: ChatMessage.implementation.getSpeaker({ actor }),\n        flags: { dnd5e: { bastion: results } }\n      });\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdvance the given facility by one bastion turn.\n@param {Item5e} facility              The facility.\n@param {object} [options]\n@param {number} [options.duration=7]  The number of days the bastion turn spanned.\n@returns {Promise<BastionTurnResult>}\n/\n  async advanceTurn(facility, { duration=7 }={}) {\n    const { disabled, progress, type } = facility.system;\n\n    // Case 1 - No order in progress.\n    if ( !progress.max && !disabled ) {\n      await facility.update({ \"system.progress.order\": \"\" });\n      if ( type.value === \"basic\" ) return {}; // Basic facilities do nothing.\n      return { order: \"maintain\" }; // Special facilities are considered to have been issued the maintain order.\n    }\n\n    const newProgress = Math.min(progress.value + duration, progress.max);\n\n    // Case 2 - Order incomplete. Ongoing progress.\n    if ( (newProgress < progress.max) && !disabled ) {\n      await facility.update({ \"system.progress.value\": newProgress });\n      return {};\n    }\n\n    // Case 3 - Order complete.\n    const updates = { \"system.progress\": { value: 0, max: null, order: \"\" } };\n    const { gold, items } = this.#evaluateOrder(facility, progress.order, updates);\n    await facility.update(updates);\n    return { gold, items, order: progress.order };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nResolve a bastion attack against a given Actor's bastion.\n@param {Actor5e} actor   The Actor.\n@param {string} formula  The attack formula.\n@param {object} [options]\n@param {boolean} [options.summary=true]  Print a chat message summary of the attack.\n@param {number} [options.threshold=1]    The maximum number on a die roll that is considered a defender death.\n@returns {Promise<number>}               The number of defenders who died in the attack.\n/\n  async resolveAttack(actor, formula, { summary=true, threshold=1 }={}) {\n    const results = {};\n    const roll = await Roll.create(formula).evaluate();\n    const deaths = roll.dice.reduce((count, die) => {\n      return count + die.results.filter(({ result, active }) => active && (result <= threshold)).length;\n    }, 0);\n    const defenders = this.#getDefenders(actor);\n    if ( defenders.length ) results.deaths = Math.min(deaths, defenders.length);\n    else results.undefended = true;\n    if ( summary ) {\n      const content = await this.#renderAttackSummary(actor, roll, results);\n      await ChatMessage.implementation.create({\n        content,\n        speaker: ChatMessage.implementation.getSpeaker({ actor }),\n        rolls: [roll],\n        flags: { dnd5e: { bastion: results } }\n      });\n    }\n  }\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /**\nAttach interactivity to chat messages.\n@param {ChatMessage5e} message  The chat message.\n@param {HTMLElement} html       The rendered chat card element.\n@internal\n/\n  _activateChatListeners(message, html) {\n    html.addEventListener(\"click\", event => {\n      const target = event.target.closest(\"[data-action]\");\n      if ( target ) this.#onChatAction(event, target, message);\n    }, { passive: true });\n\n    const actor = message.getAssociatedActor();\n    if ( !actor?.isOwner ) return;\n\n    html.querySelectorAll(\".item-summary > li\").forEach(async el => {\n      const { uuid, quantity } = el.dataset;\n      const item = await fromUuid(uuid);\n      if ( !item ) return;\n      el.draggable = true;\n      el.addEventListener(\"dragstart\", event => {\n        this.#onDragItem(event, item, { \"system.quantity\": Number(quantity) });\n      });\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEvaluate the completion of an order.\n@param {Item5e} facility  The facility.\n@param {string} order     The order that was completed.\n@param {object} updates   Facility updates.\n@returns {Omit<BastionTurnResult, \"order\">}\n/\n  #evaluateOrder(facility, order, updates) {\n    switch ( order ) {\n      case \"build\": return this.#evaluateBuildOrder(facility, updates);\n      case \"craft\": return this.#evaluateCraftOrder(facility, updates);\n      case \"enlarge\": return this.#evaluateEnlargeOrder(facility, updates);\n      case \"harvest\": return this.#evaluateHarvestOrder(facility, updates);\n      case \"repair\": return this.#evaluateRepairOrder(facility, updates);\n      case \"trade\": return this.#evaluateTradeOrder(facility, updates);\n    }\n    return {};\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEvaluate the completion of a build order.\n@param {Item5e} facility  The facility.\n@param {object} updates   Facility updates.\n@returns {Omit<BastionTurnResult, \"order\">}\n/\n  #evaluateBuildOrder(facility, updates) {\n    const { building } = facility.system;\n    updates[\"system.building.built\"] = true;\n    updates[\"system.size\"] = building.size;\n    return {};\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEvaluate the completion of a craft order.\n@param {Item5e} facility          The facility.\n@param {object} updates           Facility updates.\n@returns {Omit<BastionTurnResult, \"order\">}\n/\n  #evaluateCraftOrder(facility, updates) {\n    const { craft } = facility.system;\n    updates[\"system.craft.item\"] = null;\n    return { items: [{ uuid: craft.item, quantity: 1 }] };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEvaluate the completion of an enlarge order.\n@param {Item5e} facility  The facility.\n@param {object} updates   Facility updates.\n@returns {Omit<BastionTurnResult, \"order\">}\n/\n  #evaluateEnlargeOrder(facility, updates) {\n    const { size } = facility.system;\n    const sizes = Object.entries(CONFIG.DND5E.facilities.sizes).sort((a, b) => a.value - b.value);\n    const index = sizes.findIndex(([key]) => key === size);\n    const [next] = sizes[index + 1];\n    updates[\"system.size\"] = next;\n    return {};\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEvaluate the completion of a harvest order.\n@param {Item5e} facility  The facility.\n@param {object} updates   Facility updates.\n@returns {Omit<BastionTurnResult, \"order\">}\n/\n  #evaluateHarvestOrder(facility, updates) {\n    const { craft } = facility.system;\n    return { items: [{ uuid: craft.item, quantity: craft.quantity }] };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEvaluate the completion of a repair order.\n@param {Item5e} facility  The facility.\n@param {object} updates   Facility updates.\n@returns {Omit<BastionTurnResult, \"order\">}\n/\n  #evaluateRepairOrder(facility, updates) {\n    updates[\"system.disabled\"] = false;\n    return {};\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEvaluate the completion of a trade order.\n@param {Item5e} facility  The facility.\n@param {object} updates   Facility updates.\n@returns {Omit<BastionTurnResult, \"order\">}\n/\n  #evaluateTradeOrder(facility, updates) {\n    const { trade } = facility.system;\n    updates[\"system.trade.pending.operation\"] = null;\n    updates[\"system.trade.pending.creatures\"] = [];\n    updates[\"system.trade.pending.value\"] = null;\n    if ( !trade.pending.operation ) return {};\n\n    if ( trade.pending.operation === \"buy\" ) {\n      // Stocked facility\n      if ( (trade.pending.value === null) && trade.pending.stocked ) updates[\"system.trade.stock.stocked\"] = true;\n\n      // Bought goods\n      else if ( trade.pending.value !== null && !trade.pending.creatures.length ) {\n        updates[\"system.trade.stock.value\"] = Math.min(trade.stock.value + trade.pending.value, trade.stock.max);\n      }\n    } else if ( trade.pending.value !== null ) {\n      // See OrderActivity#_finalizeTrade for creatures TODO\n      // Sold goods\n      let sold = trade.pending.value;\n      if ( !trade.pending.creatures.length ) {\n        updates[\"system.trade.stock.value\"] = Math.max(0, trade.stock.value - trade.pending.value);\n        sold = trade.stock.value - updates[\"system.trade.stock.value\"];\n      }\n\n      return { gold: Math.floor(sold * ((trade.profit / 100) + 1)) };\n    }\n\n    return {};\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRetrieve a list of defenders for the given Actor's bastion.\n@param {Actor5e} actor  The actor.\n@returns {{ facility: Item5e, uuid: string }[]}\n/\n  #getDefenders(actor) {\n    const allDefenders = [];\n    for ( const facility of actor.itemTypes.facility ) {\n      const { defenders, type } = facility.system;\n      if ( (type.value === \"special\") && defenders.max ) {\n        allDefenders.push(...defenders.value.map(uuid => ({ facility, uuid })));\n      }\n    }\n    return allDefenders;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle clicking action elements in chat cards.\n@param {PointerEvent} event     The triggering event.\n@param {HTMLElement} target     The action element.\n@param {ChatMessage5e} message  The chat message.\n/\n  #onChatAction(event, target, message) {\n    const { action } = target.dataset;\n    switch ( action ) {\n      case \"claim\": this.#onClaimGold(message); break;\n      case \"resolve\": this.#onResolveAttack(message); break;\n      case \"viewItem\": this.#onViewItem(target); break;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle claiming gold from a bastion turn summary message.\n@param {ChatMessage5e} message  The message.\n@returns {Promise<ChatMessage5e|void>}\n/\n  async #onClaimGold(message) {\n    const results = message.getFlag(\"dnd5e\", \"bastion\");\n    const { gold } = results;\n    const actor = message.getAssociatedActor();\n    const { gp } = actor?.system?.currency ?? {};\n    if ( !gold?.value || gold.claimed || (gp === undefined) ) return;\n    await actor.update({ \"system.currency.gp\": gp + gold.value });\n    gold.claimed = true;\n    const content = await this.#renderTurnSummary(actor, results);\n    return message.update({ content, flags: { dnd5e: { bastion: results } } });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle dragging an item created as part of order completion.\n@param {DragEvent} event    The initiating drag event.\n@param {Item5e} item        The created item.\n@param {object} [updates]   Updates to apply to the Item.\n/\n  #onDragItem(event, item, updates={}) {\n    // TODO: Need some way to mark the item as 'claimed' when it is dropped onto an Actor sheet.\n    if ( !foundry.utils.isEmpty(updates) ) item.updateSource(updates);\n    event.dataTransfer.setData(\"text/plain\", JSON.stringify({ data: game.items.fromCompendium(item), type: \"Item\" }));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle automatic resolution of a bastion attack via chat message.\n@param {ChatMessage5e} message  The message.\n@returns {Promise<ChatMessage5e|void>}\n/\n  async #onResolveAttack(message) {\n    const results = message.getFlag(\"dnd5e\", \"bastion\") ?? {};\n    const { deaths, undefended } = results;\n    const actor = message.getAssociatedActor();\n    if ( (!deaths && !undefended) || !actor ) return;\n\n    if ( deaths ) {\n      const defenders = this.#getDefenders(actor);\n      const slain = [];\n      for ( let i = 0; i < deaths; i++ ) {\n        if ( !defenders.length ) break;\n        const roll = await Roll.create(`1d${defenders.length}`).evaluate({ allowInteractive: false });\n        const [defender] = defenders.splice(roll.total - 1, 1);\n        slain.push(defender);\n      }\n      const updates = {};\n      for ( const { facility, uuid } of slain ) {\n        if ( !updates[facility.id] ) updates[facility.id] = [...facility.system.defenders.value];\n        updates[facility.id].findSplice(a => a === uuid);\n      }\n      await actor.updateEmbeddedDocuments(\"Item\", Object.entries(updates).map(([_id, value]) => {\n        return { _id, \"system.defenders.value\": value };\n      }));\n    }\n\n    let damaged;\n    const defenders = this.#getDefenders(actor);\n    if ( !defenders.length ) {\n      const special = actor.itemTypes.facility.filter(f => (f.system.type.value === \"special\") && !f.system.disabled);\n      if ( special.length ) {\n        const roll = await Roll.create(`1d${special.length}`).evaluate({ allowInteractive: false });\n        damaged = special[roll.total - 1];\n        await damaged?.update({ \"system.disabled\": true });\n      }\n    }\n\n    if ( damaged ) results.damaged = damaged.id;\n    results.resolved = true;\n    const content = await this.#renderAttackSummary(actor, message.rolls[0], results);\n    return message.update({ content, flags: { dnd5e: { bastion: results } } });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle viewing a created item.\n@param {HTMLElement} target  The item element.\n@returns {Promise}\n/\n  async #onViewItem(target) {\n    const { uuid } = target.dataset;\n    const item = await fromUuid(uuid);\n    return item?.sheet.render(true);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRender a chat card summary for the bastion attack.\n@param {Actor5e} actor                 The actor whose bastion was attacked.\n@param {Roll} roll                     The bastion attack roll.\n@param {object} [results]\n@param {string} [results.damaged]      The ID of the facility damaged in the attack.\n@param {number} [results.deaths]       The number of bastion defenders slain in the attack.\n@param {boolean} [results.undefended]  If the bastion was undefended during the attack.\n@param {boolean} [results.resolved]    Whether the attack has been automatically resolved.\n@returns {Promise<string>}\n/\n  async #renderAttackSummary(actor, roll, { damaged, deaths, undefended, resolved }={}) {\n    const context = {};\n    const plurals = new Intl.PluralRules(game.i18n.lang);\n    const key = undefended ? \"Undefended\" : deaths ? `Deaths.${plurals.select(deaths)}` : \"NoDeaths\";\n    context.description = game.i18n.format(`DND5E.Bastion.Attack.Result.${key}`, { deaths });\n    context.roll = await roll.render();\n    context.buttons = [];\n    if ( !resolved && (deaths || undefended) ) {\n      context.buttons.push({\n        label: game.i18n.localize(\"DND5E.Bastion.Attack.Automatic\"),\n        icon: '<i class=\"fas fa-bolt\"></i>',\n        dataset: { action: \"resolve\" }\n      });\n    }\n    if ( damaged ) {\n      const facility = actor.items.get(damaged);\n      if ( facility ) context.damaged = game.i18n.format(\"DND5E.Bastion.Attack.Result.Damaged\", {\n        link: facility.toAnchor().outerHTML\n      });\n    }\n    return renderTemplate(this.constructor.ATTACK_TEMPLATE, context);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRender a chat card summary for the bastion turn results.\n@param {Actor5e} actor                                     The actor whose turn it was.\n@param {object} results\n@param {BastionTurnItem[]} results.items                   The items produced during the turn.\n@param {{ value: number, claimed: boolean }} results.gold  Gold generated during the turn.\n@param {{ id: string, order: string }[]} results.orders    Orders completed during the turn.\n@returns {Promise<string>}\n/\n  async #renderTurnSummary(actor, results) {\n    const context = {};\n    context.items = (await Promise.all(results.items.map(async ({ uuid, quantity }) => {\n      const item = await fromUuid(uuid);\n      if ( !item ) return null;\n      const { name, img } = item;\n      return { img, name, quantity, uuid };\n    }))).filter(_ => _);\n    context.orders = results.orders.map(({ id, order }) => {\n      const facility = actor.items.get(id);\n      return {\n        name: facility.name,\n        contentLink: facility.toAnchor().outerHTML,\n        order: CONFIG.DND5E.facilities.orders[order]?.label\n      };\n    });\n    context.supplements = [];\n    if ( results.gold.value ) {\n      context.supplements.push(`\n        <strong>${game.i18n.localize(\"DND5E.CurrencyGP\")}</strong>\n        ${formatNumber(results.gold.value)}\n        (${game.i18n.localize(`DND5E.Bastion.Gold.${results.gold.claimed ? \"Claimed\" : \"Unclaimed\"}`)})\n      `);\n    }\n    context.buttons = [];\n    if ( results.gold.value && !results.gold.claimed ) {\n      context.buttons.push({\n        label: game.i18n.localize(\"DND5E.Bastion.Gold.Claim\"),\n        icon: '<i class=\"fas fa-coins\"></i>',\n        dataset: { action: \"claim\" }\n      });\n    }\n    return renderTemplate(this.constructor.TURN_TEMPLATE, context);\n  }\n\n  /* -------------------------------------------- */\n  /*  Helpers                                     */\n  /* -------------------------------------------- */\n\n  /**\nConfirm the bastion turn should be advanced.\n@returns {Promise<void>}\n/\n  async confirmAdvance() {\n    if ( !game.user.isGM ) return;\n    const proceed = await foundry.applications.api.DialogV2.confirm({\n      content: game.i18n.localize(\"DND5E.Bastion.Confirm\"),\n      rejectClose: false\n    });\n    if ( proceed ) return this.advanceAllBastions();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nInitialize the bastion UI.\n/\n  initializeUI() {\n    const turnButton = document.getElementById(\"bastion-turn\");\n    const { button, enabled } = game.settings.get(\"dnd5e\", \"bastionConfiguration\");\n\n    if ( !enabled || !button || !game.user.isGM) {\n      turnButton?.remove();\n      return;\n    }\n\n    if ( !turnButton ) {\n      const v12 = game.release.generation < 13 ? \"v12\" : \"faded-ui\";\n      document.querySelector(\"#controls, #scene-controls\")?.insertAdjacentHTML(\"afterend\", `\n        <button type=\"button\" id=\"bastion-turn\" data-action=\"bastionTurn\" class=\"dnd5e2 ${v12}\">\n          <i class=\"fas fa-chess-rook\"></i>\n          <span>${game.i18n.localize(\"DND5E.Bastion.Action.BastionTurn\")}</span>\n        </button>\n      `);\n      document.getElementById(\"bastion-turn\")?.addEventListener(\"click\", this.confirmAdvance.bind(this));\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrompt the DM to resolve a bastion attack against a specific Actor.\n@param {Actor5e} [actor]  The Actor.\n@returns {Promise}\n/\n  async promptAttack(actor) {\n    if ( !game.user.isGM ) return;\n\n    // Determine Actor by selected token.\n    if ( !actor ) {\n      const [token] = canvas.tokens.controlled;\n      actor = token?.actor;\n    }\n\n    // Determine Actor by active window.\n    if ( !actor && (ui.activeWindow instanceof ActorSheet) ) actor = ui.activeWindow.actor;\n\n    if ( !actor ) {\n      ui.notifications.warn(\"DND5E.Bastion.Attack.NoActorWarning\", { localize: true });\n      return;\n    }\n\n    const formula = await BastionAttackDialog.prompt(actor);\n    if ( formula ) return this.resolveAttack(actor, formula);\n  }\n}\n\n/* -------------------------------------------- */\n\nconst { StringField } = foundry.data.fields;\n\n/**\nA dialog for resolving bastion attacks."
    },
    {
      "name": "HitDice",
      "extends": null,
      "file": "module\\documents\\actor\\hit-dice.mjs",
      "jsDoc": ""
    },
    {
      "name": "Proficiency",
      "extends": null,
      "file": "module\\documents\\actor\\proficiency.mjs",
      "jsDoc": ""
    },
    {
      "name": "SelectChoices",
      "extends": null,
      "file": "module\\documents\\actor\\select-choices.mjs",
      "jsDoc": ""
    },
    {
      "name": "AbilityScoreImprovementAdvancement",
      "extends": "Advancement",
      "file": "module\\documents\\advancement\\ability-score-improvement.mjs",
      "jsDoc": ""
    },
    {
      "name": "AdvancementError",
      "extends": "Error",
      "file": "module\\documents\\advancement\\advancement.mjs",
      "jsDoc": "@import { PseudoDocumentsMetadata } from \"../mixins/pseudo-document.mjs\";\n/\n\n/**\nError that can be thrown during the advancement update preparation process."
    },
    {
      "name": "HitPointsAdvancement",
      "extends": "Advancement",
      "file": "module\\documents\\advancement\\hit-points.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemChoiceAdvancement",
      "extends": "ItemGrantAdvancement",
      "file": "module\\documents\\advancement\\item-choice.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemGrantAdvancement",
      "extends": "Advancement",
      "file": "module\\documents\\advancement\\item-grant.mjs",
      "jsDoc": ""
    },
    {
      "name": "ScaleValueAdvancement",
      "extends": "Advancement",
      "file": "module\\documents\\advancement\\scale-value.mjs",
      "jsDoc": ""
    },
    {
      "name": "SizeAdvancement",
      "extends": "Advancement",
      "file": "module\\documents\\advancement\\size.mjs",
      "jsDoc": ""
    },
    {
      "name": "SubclassAdvancement",
      "extends": "Advancement",
      "file": "module\\documents\\advancement\\subclass.mjs",
      "jsDoc": ""
    },
    {
      "name": "TraitAdvancement",
      "extends": "Advancement",
      "file": "module\\documents\\advancement\\trait.mjs",
      "jsDoc": ""
    },
    {
      "name": "ChatMessage5e",
      "extends": "ChatMessage",
      "file": "module\\documents\\chat-message.mjs",
      "jsDoc": ""
    },
    {
      "name": "Combat5e",
      "extends": "Combat",
      "file": "module\\documents\\combat.mjs",
      "jsDoc": ""
    },
    {
      "name": "Combatant5e",
      "extends": "Combatant",
      "file": "module\\documents\\combatant.mjs",
      "jsDoc": ""
    },
    {
      "name": "JournalEntryPage5e",
      "extends": "JournalEntryPage",
      "file": "module\\documents\\journal-entry-page.mjs",
      "jsDoc": ""
    },
    {
      "name": "SystemFlags",
      "extends": "Base",
      "file": "module\\documents\\mixins\\flags.mjs",
      "jsDoc": ""
    },
    {
      "name": "PseudoDocument",
      "extends": "Base",
      "file": "module\\documents\\mixins\\pseudo-document.mjs",
      "jsDoc": ""
    },
    {
      "name": "Scaling",
      "extends": null,
      "file": "module\\documents\\scaling.mjs",
      "jsDoc": ""
    },
    {
      "name": "ModuleArt",
      "extends": null,
      "file": "module\\module-art.mjs",
      "jsDoc": ""
    },
    {
      "name": "EnchantmentRegisty",
      "extends": null,
      "file": "module\\registry.mjs",
      "jsDoc": ""
    },
    {
      "name": "ItemRegistry",
      "extends": null,
      "file": "module\\registry.mjs",
      "jsDoc": "Registration of enchanted items mapped to a specific enchantment source. The map is keyed by the UUID of\nenchant activities while the set contains UUID of applied enchantment active effects.\n@type {Map<string, Set<string>>}\n/\n  static #appliedEnchantments = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nFetch the tracked enchanted items.\n@param {string} uuid  UUID of an activity or item.\n@returns {ActiveEffect5e[]}\n/\n  static applied(uuid) {\n    const source = fromUuidSync(uuid);\n    if ( source instanceof Item ) {\n      return source.system.activities?.getByType(\"enchant\")\n        .map(a => EnchantmentRegisty.applied(a.uuid))\n        .flat() ?? [];\n    }\n    return Array.from(EnchantmentRegisty.#appliedEnchantments.get(uuid) ?? [])\n      .map(uuid => fromUuidSync(uuid))\n      .filter(effect => effect?.isAppliedEnchantment);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a new enchantment effect to the list of tracked enchantments. Will not track enchanted items in compendiums.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to track.\n/\n  static track(source, enchanted) {\n    if ( enchanted.startsWith(\"Compendium.\") ) return;\n    if ( !EnchantmentRegisty.#appliedEnchantments.has(source) ) {\n      EnchantmentRegisty.#appliedEnchantments.set(source, new Set());\n    }\n    EnchantmentRegisty.#appliedEnchantments.get(source).add(enchanted);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStop tracking an enchantment.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to stop tracking.\n/\n  static untrack(source, enchanted) {\n    EnchantmentRegisty.#appliedEnchantments.get(source)?.delete(enchanted);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Item Registry                               */\n/* --------------------------------------------"
    },
    {
      "name": "MessageRegistry",
      "extends": null,
      "file": "module\\registry.mjs",
      "jsDoc": "Registration of enchanted items mapped to a specific enchantment source. The map is keyed by the UUID of\nenchant activities while the set contains UUID of applied enchantment active effects.\n@type {Map<string, Set<string>>}\n/\n  static #appliedEnchantments = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nFetch the tracked enchanted items.\n@param {string} uuid  UUID of an activity or item.\n@returns {ActiveEffect5e[]}\n/\n  static applied(uuid) {\n    const source = fromUuidSync(uuid);\n    if ( source instanceof Item ) {\n      return source.system.activities?.getByType(\"enchant\")\n        .map(a => EnchantmentRegisty.applied(a.uuid))\n        .flat() ?? [];\n    }\n    return Array.from(EnchantmentRegisty.#appliedEnchantments.get(uuid) ?? [])\n      .map(uuid => fromUuidSync(uuid))\n      .filter(effect => effect?.isAppliedEnchantment);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a new enchantment effect to the list of tracked enchantments. Will not track enchanted items in compendiums.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to track.\n/\n  static track(source, enchanted) {\n    if ( enchanted.startsWith(\"Compendium.\") ) return;\n    if ( !EnchantmentRegisty.#appliedEnchantments.has(source) ) {\n      EnchantmentRegisty.#appliedEnchantments.set(source, new Set());\n    }\n    EnchantmentRegisty.#appliedEnchantments.get(source).add(enchanted);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStop tracking an enchantment.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to stop tracking.\n/\n  static untrack(source, enchanted) {\n    EnchantmentRegisty.#appliedEnchantments.get(source)?.delete(enchanted);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Item Registry                               */\n/* -------------------------------------------- */\n\nclass ItemRegistry {\n  constructor(itemsType) {\n    this.#itemType = itemsType;\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\n@typedef {object} RegisteredItemData\n@property {string} name        Name of the item.\n@property {string} identifier  Item identifier.\n@property {string} img         Item's icon.\n@property {string[]} sources   UUIDs of different compendium items matching this identifier.\n/\n\n  /**\nItems grouped by identifiers.\n@type {Map<string, RegisteredItemData>}\n/\n  #items = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nType of item represented by this registry.\n@type {string}\n/\n  #itemType;\n\n  /* -------------------------------------------- */\n\n  /**\nHas initial loading been completed?\n@type {number}\n/\n  #status = ItemRegistry.#STATUS_STATES.NONE;\n\n  /**\nPossible preparation states for the item registry.\n@enum {number}\n/\n  static #STATUS_STATES = Object.freeze({\n    NONE: 0,\n    LOADING: 1,\n    READY: 2\n  });\n\n  /* -------------------------------------------- */\n\n  /**\nChoices object.\n@type {Record<string, string>}\n/\n  get choices() {\n    return this.options.reduce((obj, { value, label }) => {\n      obj[value] = label;\n      return obj;\n    }, {});\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAll items formatted for a select input.\n@type {FormSelectOption[]}\n/\n  get options() {\n    return Array.from(this.#items.entries())\n      .map(([value, data]) => ({ value, label: data.name }))\n      .sort((lhs, rhs) => lhs.label.localeCompare(rhs.label, game.i18n.lang));\n  }\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /**\nGet information on a single item based on its identifier.\n@param {string} identifier\n@returns {RegisteredItemData|void}\n/\n  get(identifier) {\n    return this.#items.get(identifier);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nScan compendium packs to register matching items of this type.\n/\n  async initialize() {\n    if ( this.#status > ItemRegistry.#STATUS_STATES.NONE ) return;\n    RegistryStatus.set(this.#itemType, false);\n    if ( game.modules.get(\"babele\")?.active && (game.babele?.initialized === false) ) {\n      Hooks.once(\"babele.ready\", () => this.initialize());\n      return;\n    } else if ( !game.ready ) {\n      Hooks.once(\"ready\", () => this.initialize());\n      return;\n    }\n    this.#status = ItemRegistry.#STATUS_STATES.LOADING;\n\n    const indexes = await CompendiumBrowser.fetch(Item, {\n      types: new Set([this.#itemType]),\n      indexFields: new Set([\"system.identifier\"]),\n      sort: false\n    });\n    for ( const item of indexes ) {\n      const identifier = item.system?.identifier ?? slugify(item.name, { strict: true });\n      if ( !this.#items.has(identifier) ) this.#items.set(identifier, { sources: [] });\n      const itemData = this.#items.get(identifier);\n      itemData.name = item.name;\n      itemData.img = item.img;\n      itemData.identifier = identifier;\n      itemData.sources.push(item.uuid);\n    }\n\n    this.#status = ItemRegistry.#STATUS_STATES.READY;\n    RegistryStatus.set(this.#itemType, true);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Message Rolls                               */\n/* --------------------------------------------"
    },
    {
      "name": "SpellListRegistry",
      "extends": null,
      "file": "module\\registry.mjs",
      "jsDoc": "Registration of enchanted items mapped to a specific enchantment source. The map is keyed by the UUID of\nenchant activities while the set contains UUID of applied enchantment active effects.\n@type {Map<string, Set<string>>}\n/\n  static #appliedEnchantments = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nFetch the tracked enchanted items.\n@param {string} uuid  UUID of an activity or item.\n@returns {ActiveEffect5e[]}\n/\n  static applied(uuid) {\n    const source = fromUuidSync(uuid);\n    if ( source instanceof Item ) {\n      return source.system.activities?.getByType(\"enchant\")\n        .map(a => EnchantmentRegisty.applied(a.uuid))\n        .flat() ?? [];\n    }\n    return Array.from(EnchantmentRegisty.#appliedEnchantments.get(uuid) ?? [])\n      .map(uuid => fromUuidSync(uuid))\n      .filter(effect => effect?.isAppliedEnchantment);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a new enchantment effect to the list of tracked enchantments. Will not track enchanted items in compendiums.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to track.\n/\n  static track(source, enchanted) {\n    if ( enchanted.startsWith(\"Compendium.\") ) return;\n    if ( !EnchantmentRegisty.#appliedEnchantments.has(source) ) {\n      EnchantmentRegisty.#appliedEnchantments.set(source, new Set());\n    }\n    EnchantmentRegisty.#appliedEnchantments.get(source).add(enchanted);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStop tracking an enchantment.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to stop tracking.\n/\n  static untrack(source, enchanted) {\n    EnchantmentRegisty.#appliedEnchantments.get(source)?.delete(enchanted);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Item Registry                               */\n/* -------------------------------------------- */\n\nclass ItemRegistry {\n  constructor(itemsType) {\n    this.#itemType = itemsType;\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\n@typedef {object} RegisteredItemData\n@property {string} name        Name of the item.\n@property {string} identifier  Item identifier.\n@property {string} img         Item's icon.\n@property {string[]} sources   UUIDs of different compendium items matching this identifier.\n/\n\n  /**\nItems grouped by identifiers.\n@type {Map<string, RegisteredItemData>}\n/\n  #items = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nType of item represented by this registry.\n@type {string}\n/\n  #itemType;\n\n  /* -------------------------------------------- */\n\n  /**\nHas initial loading been completed?\n@type {number}\n/\n  #status = ItemRegistry.#STATUS_STATES.NONE;\n\n  /**\nPossible preparation states for the item registry.\n@enum {number}\n/\n  static #STATUS_STATES = Object.freeze({\n    NONE: 0,\n    LOADING: 1,\n    READY: 2\n  });\n\n  /* -------------------------------------------- */\n\n  /**\nChoices object.\n@type {Record<string, string>}\n/\n  get choices() {\n    return this.options.reduce((obj, { value, label }) => {\n      obj[value] = label;\n      return obj;\n    }, {});\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAll items formatted for a select input.\n@type {FormSelectOption[]}\n/\n  get options() {\n    return Array.from(this.#items.entries())\n      .map(([value, data]) => ({ value, label: data.name }))\n      .sort((lhs, rhs) => lhs.label.localeCompare(rhs.label, game.i18n.lang));\n  }\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /**\nGet information on a single item based on its identifier.\n@param {string} identifier\n@returns {RegisteredItemData|void}\n/\n  get(identifier) {\n    return this.#items.get(identifier);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nScan compendium packs to register matching items of this type.\n/\n  async initialize() {\n    if ( this.#status > ItemRegistry.#STATUS_STATES.NONE ) return;\n    RegistryStatus.set(this.#itemType, false);\n    if ( game.modules.get(\"babele\")?.active && (game.babele?.initialized === false) ) {\n      Hooks.once(\"babele.ready\", () => this.initialize());\n      return;\n    } else if ( !game.ready ) {\n      Hooks.once(\"ready\", () => this.initialize());\n      return;\n    }\n    this.#status = ItemRegistry.#STATUS_STATES.LOADING;\n\n    const indexes = await CompendiumBrowser.fetch(Item, {\n      types: new Set([this.#itemType]),\n      indexFields: new Set([\"system.identifier\"]),\n      sort: false\n    });\n    for ( const item of indexes ) {\n      const identifier = item.system?.identifier ?? slugify(item.name, { strict: true });\n      if ( !this.#items.has(identifier) ) this.#items.set(identifier, { sources: [] });\n      const itemData = this.#items.get(identifier);\n      itemData.name = item.name;\n      itemData.img = item.img;\n      itemData.identifier = identifier;\n      itemData.sources.push(item.uuid);\n    }\n\n    this.#status = ItemRegistry.#STATUS_STATES.READY;\n    RegistryStatus.set(this.#itemType, true);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Message Rolls                               */\n/* -------------------------------------------- */\n\nclass MessageRegistry {\n  /**\nRegistration of roll chat messages that originated at a specific message. The map is keyed by the ID of\nthe originating message and contains sets of IDs for each roll type.\n@type {Map<string, Map<string, Set<string>>}\n/\n  static #messages = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nFetch roll messages for an origin message, in chronological order.\n@param {string} origin  ID of the origin message.\n@param {string} [type]  Type of roll messages to fetch.\n@returns {ChatMessage5e[]}\n/\n  static get(origin, type) {\n    const originMap = MessageRegistry.#messages.get(origin);\n    if ( !originMap ) return [];\n    let ids;\n    if ( type ) ids = Array.from(originMap.get(type) ?? []);\n    else ids = Array.from(originMap.values()).map(v => Array.from(v)).flat();\n    return ids\n      .map(id => game.messages.get(id))\n      .filter(m => m)\n      .sort((lhs, rhs) => lhs.timestamp - rhs.timestamp);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a new roll message to the registry.\n@param {ChatMessage5e} message  Message to add to the registry.\n/\n  static track(message) {\n    const origin = message.getFlag(\"dnd5e\", \"originatingMessage\");\n    const type = message.getFlag(\"dnd5e\", \"roll.type\");\n    if ( !origin || !type ) return;\n    if ( !MessageRegistry.#messages.has(origin) ) MessageRegistry.#messages.set(origin, new Map());\n    const originMap = MessageRegistry.#messages.get(origin);\n    if ( !originMap.has(type) ) originMap.set(type, new Set());\n    originMap.get(type).add(message.id);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRemove a roll message to the registry.\n@param {ChatMessage5e} message  Message to remove from the registry.\n/\n  static untrack(message) {\n    const origin = message.getFlag(\"dnd5e\", \"originatingMessage\");\n    const type = message.getFlag(\"dnd5e\", \"roll.type\");\n    MessageRegistry.#messages.get(origin)?.get(type)?.delete(message.id);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Spell Lists                                 */\n/* --------------------------------------------"
    },
    {
      "name": "SpellList",
      "extends": null,
      "file": "module\\registry.mjs",
      "jsDoc": ""
    },
    {
      "name": "SummonRegistry",
      "extends": null,
      "file": "module\\registry.mjs",
      "jsDoc": "Registration of enchanted items mapped to a specific enchantment source. The map is keyed by the UUID of\nenchant activities while the set contains UUID of applied enchantment active effects.\n@type {Map<string, Set<string>>}\n/\n  static #appliedEnchantments = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nFetch the tracked enchanted items.\n@param {string} uuid  UUID of an activity or item.\n@returns {ActiveEffect5e[]}\n/\n  static applied(uuid) {\n    const source = fromUuidSync(uuid);\n    if ( source instanceof Item ) {\n      return source.system.activities?.getByType(\"enchant\")\n        .map(a => EnchantmentRegisty.applied(a.uuid))\n        .flat() ?? [];\n    }\n    return Array.from(EnchantmentRegisty.#appliedEnchantments.get(uuid) ?? [])\n      .map(uuid => fromUuidSync(uuid))\n      .filter(effect => effect?.isAppliedEnchantment);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a new enchantment effect to the list of tracked enchantments. Will not track enchanted items in compendiums.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to track.\n/\n  static track(source, enchanted) {\n    if ( enchanted.startsWith(\"Compendium.\") ) return;\n    if ( !EnchantmentRegisty.#appliedEnchantments.has(source) ) {\n      EnchantmentRegisty.#appliedEnchantments.set(source, new Set());\n    }\n    EnchantmentRegisty.#appliedEnchantments.get(source).add(enchanted);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStop tracking an enchantment.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to stop tracking.\n/\n  static untrack(source, enchanted) {\n    EnchantmentRegisty.#appliedEnchantments.get(source)?.delete(enchanted);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Item Registry                               */\n/* -------------------------------------------- */\n\nclass ItemRegistry {\n  constructor(itemsType) {\n    this.#itemType = itemsType;\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\n@typedef {object} RegisteredItemData\n@property {string} name        Name of the item.\n@property {string} identifier  Item identifier.\n@property {string} img         Item's icon.\n@property {string[]} sources   UUIDs of different compendium items matching this identifier.\n/\n\n  /**\nItems grouped by identifiers.\n@type {Map<string, RegisteredItemData>}\n/\n  #items = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nType of item represented by this registry.\n@type {string}\n/\n  #itemType;\n\n  /* -------------------------------------------- */\n\n  /**\nHas initial loading been completed?\n@type {number}\n/\n  #status = ItemRegistry.#STATUS_STATES.NONE;\n\n  /**\nPossible preparation states for the item registry.\n@enum {number}\n/\n  static #STATUS_STATES = Object.freeze({\n    NONE: 0,\n    LOADING: 1,\n    READY: 2\n  });\n\n  /* -------------------------------------------- */\n\n  /**\nChoices object.\n@type {Record<string, string>}\n/\n  get choices() {\n    return this.options.reduce((obj, { value, label }) => {\n      obj[value] = label;\n      return obj;\n    }, {});\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAll items formatted for a select input.\n@type {FormSelectOption[]}\n/\n  get options() {\n    return Array.from(this.#items.entries())\n      .map(([value, data]) => ({ value, label: data.name }))\n      .sort((lhs, rhs) => lhs.label.localeCompare(rhs.label, game.i18n.lang));\n  }\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /**\nGet information on a single item based on its identifier.\n@param {string} identifier\n@returns {RegisteredItemData|void}\n/\n  get(identifier) {\n    return this.#items.get(identifier);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nScan compendium packs to register matching items of this type.\n/\n  async initialize() {\n    if ( this.#status > ItemRegistry.#STATUS_STATES.NONE ) return;\n    RegistryStatus.set(this.#itemType, false);\n    if ( game.modules.get(\"babele\")?.active && (game.babele?.initialized === false) ) {\n      Hooks.once(\"babele.ready\", () => this.initialize());\n      return;\n    } else if ( !game.ready ) {\n      Hooks.once(\"ready\", () => this.initialize());\n      return;\n    }\n    this.#status = ItemRegistry.#STATUS_STATES.LOADING;\n\n    const indexes = await CompendiumBrowser.fetch(Item, {\n      types: new Set([this.#itemType]),\n      indexFields: new Set([\"system.identifier\"]),\n      sort: false\n    });\n    for ( const item of indexes ) {\n      const identifier = item.system?.identifier ?? slugify(item.name, { strict: true });\n      if ( !this.#items.has(identifier) ) this.#items.set(identifier, { sources: [] });\n      const itemData = this.#items.get(identifier);\n      itemData.name = item.name;\n      itemData.img = item.img;\n      itemData.identifier = identifier;\n      itemData.sources.push(item.uuid);\n    }\n\n    this.#status = ItemRegistry.#STATUS_STATES.READY;\n    RegistryStatus.set(this.#itemType, true);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Message Rolls                               */\n/* -------------------------------------------- */\n\nclass MessageRegistry {\n  /**\nRegistration of roll chat messages that originated at a specific message. The map is keyed by the ID of\nthe originating message and contains sets of IDs for each roll type.\n@type {Map<string, Map<string, Set<string>>}\n/\n  static #messages = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nFetch roll messages for an origin message, in chronological order.\n@param {string} origin  ID of the origin message.\n@param {string} [type]  Type of roll messages to fetch.\n@returns {ChatMessage5e[]}\n/\n  static get(origin, type) {\n    const originMap = MessageRegistry.#messages.get(origin);\n    if ( !originMap ) return [];\n    let ids;\n    if ( type ) ids = Array.from(originMap.get(type) ?? []);\n    else ids = Array.from(originMap.values()).map(v => Array.from(v)).flat();\n    return ids\n      .map(id => game.messages.get(id))\n      .filter(m => m)\n      .sort((lhs, rhs) => lhs.timestamp - rhs.timestamp);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a new roll message to the registry.\n@param {ChatMessage5e} message  Message to add to the registry.\n/\n  static track(message) {\n    const origin = message.getFlag(\"dnd5e\", \"originatingMessage\");\n    const type = message.getFlag(\"dnd5e\", \"roll.type\");\n    if ( !origin || !type ) return;\n    if ( !MessageRegistry.#messages.has(origin) ) MessageRegistry.#messages.set(origin, new Map());\n    const originMap = MessageRegistry.#messages.get(origin);\n    if ( !originMap.has(type) ) originMap.set(type, new Set());\n    originMap.get(type).add(message.id);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRemove a roll message to the registry.\n@param {ChatMessage5e} message  Message to remove from the registry.\n/\n  static untrack(message) {\n    const origin = message.getFlag(\"dnd5e\", \"originatingMessage\");\n    const type = message.getFlag(\"dnd5e\", \"roll.type\");\n    MessageRegistry.#messages.get(origin)?.get(type)?.delete(message.id);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Spell Lists                                 */\n/* -------------------------------------------- */\n\nclass SpellListRegistry {\n  /**\nSpell lists organized by the UUID of a spell they contain.\n@type {Map<string, Set<SpellList>>}\n/\n  static #bySpell = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nRegistration of spell lists grouped by type and identifier.\n@type {Map<string, Map<string, SpellList>>}\n/\n  static #byType = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nUUIDs of spell lists in the process of being loaded.\n@type {Set<string>}\n/\n  static #loading = new Set();\n\n  /* -------------------------------------------- */\n\n  /**\nOptions for each registered spell list, grouped by type.\n@type {FormSelectOption[]}\n/\n  static get options() {\n    return Object.entries(CONFIG.DND5E.spellListTypes).map(([type, group]) => {\n      const lists = this.#byType.get(type);\n      if ( !lists ) return [];\n      return Array.from(lists.entries())\n        .map(([value, list]) => ({ value, label: list.name, group, type }))\n        .sort((lhs, rhs) => lhs.label.localeCompare(rhs.label, game.i18n.lang));\n    }).flat();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHave spell lists finished loading?\n@type {boolean}\n/\n  static get ready() {\n    return this.#loading.size === 0;\n  }\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /**\nRetrieve a list of spell lists a spell belongs to.\n@param {string} uuid  UUID of a spell item.\n@returns {Set<SpellList>}\n/\n  static forSpell(uuid) {\n    return SpellListRegistry.#bySpell.get(uuid) ?? new Set();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRetrieve a specific spell list from the registry.\n@param {string} type        Type of list as defined in `CONFIG.DND5E.spellListTypes`.\n@param {string} identifier  Identifier of the specific spell list.\n@returns {SpellList|null}\n/\n  static forType(type, identifier) {\n    return SpellListRegistry.#byType.get(type)?.get(identifier) ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRegister a spell list journal entry page.\n@param {string} uuid  UUID of a spell list journal entry page.\n/\n  static async register(uuid) {\n    RegistryStatus.set(\"spellLists\", false);\n    this.#loading.add(uuid);\n    if ( !game.ready ) {\n      Hooks.once(\"ready\", () => this.register(uuid));\n      return;\n    }\n\n    const page = await fromUuid(uuid);\n    if ( !page ) throw new Error(`Journal entry page \"${uuid}\" could not be found to register as spell list.`);\n    if ( page.type !== \"spells\" ) throw new Error(`Journal entry page \"${uuid}\" is not a Spell List.`);\n\n    if ( !SpellListRegistry.#byType.has(page.system.type) ) SpellListRegistry.#byType.set(page.system.type, new Map());\n\n    const type = SpellListRegistry.#byType.get(page.system.type);\n    if ( !type.has(page.system.identifier) ) type.set(page.system.identifier, new SpellList({\n      identifier: page.system.identifier, name: page.name, type: page.system.type\n    }));\n\n    const list = type.get(page.system.identifier);\n    list.contribute(page).forEach(uuid => {\n      if ( !SpellListRegistry.#bySpell.has(uuid) ) SpellListRegistry.#bySpell.set(uuid, new Set());\n      SpellListRegistry.#bySpell.get(uuid).add(list);\n    });\n\n    this.#loading.delete(uuid);\n    if ( this.ready ) RegistryStatus.set(\"spellLists\", true);\n  }\n}\n\n/**\nType that represents a unified spell list for a specific class, subclass, species, or something else.\n/\nexport class SpellList {\n  constructor(metadata) {\n    this.#metadata = Object.freeze(metadata);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMapping of spell list types to item registries.\n@enum {string}\n/\n  static #REGISTRIES = {\n    class: \"classes\"\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nIndexes for the available spells sorted by name.\n@returns {object[]}\n/\n  get indexes() {\n    return Array.from(this.#spells.keys())\n      .map(s => fromUuidSync(s))\n      .sort((lhs, rhs) => lhs.name.localeCompare(rhs.name, game.i18n.lang));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nInformation on the spell list.\n@type {{ identifier: string, name: string, type: string }}\n/\n  #metadata;\n\n  get metadata() {\n    return this.#metadata;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDisplay name for the spell list.\n@type {string}\n/\n  get name() {\n    return dnd5e.registry[SpellList.#REGISTRIES[this.metadata.type]]?.get(this.metadata.identifier)?.name\n      ?? this.metadata.name;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n@typedef {SpellData}\n@property {string} page  UUID of the original page.\n/\n\n  /**\nSpells represented by this spell list.\n@type {Map<string, SpellList.SpellData>}\n/\n  #spells = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nUnlinked spell definitions.\n@type {UnlinkedSpellConfiguration[]}\n/\n  #unlinked = [];\n\n  /* -------------------------------------------- */\n\n  /**\nUUIDs of all of the spells in this list.\n@type {Set<string>}\n/\n  get uuids() {\n    return new Set(this.#spells.keys());\n  }\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /**\nAdd a spell list page to this unified spell list.\n@param {JournalEntryPage} page  Spells page to contribute.\n@returns {Set<string>}          Newly added UUIDs.\n/\n  contribute(page) {\n    const added = new Set();\n\n    page.system.spells.forEach(s => {\n      if ( !this.#spells.has(s) ) added.add(s);\n      this.#spells.set(s, { page: page.uuid });\n    });\n\n    for ( const unlinked of page.system.unlinkedSpells ) {\n      if ( fromUuidSync(unlinked.source?.uuid) ) {\n        if ( !this.#spells.has(unlinked.source.uuid) ) added.add(unlinked.source.uuid);\n        this.#spells.set(unlinked.source.uuid, { page: page.uuid });\n      } else {\n        this.#unlinked.push(foundry.utils.mergeObject({ page: page.uuid }, unlinked));\n      }\n    }\n\n    return added;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAll of the spells represented by this list.\n@returns {Promise<Item5e>}\n/\n  async getSpells() {\n    return Promise.all(Array.from(this.#spells.keys()).map(s => fromUuid(s)));\n  }\n}\n\n/* -------------------------------------------- */\n/*  Summons                                     */\n/* --------------------------------------------"
    },
    {
      "name": "Tooltips5e",
      "extends": null,
      "file": "module\\tooltips.mjs",
      "jsDoc": ""
    }
  ],
  "methods": {
    "Accordion": [
      "bind",
      "_onClickHeading",
      "_onExpandSection",
      "_onCollapseSection",
      "_onEnd",
      "cancelOngoing",
      "_saveCollapsedState",
      "_restoreCollapsedState"
    ],
    "ActivityChoiceDialog": [
      "activity",
      "item",
      "title",
      "_configureRenderOptions",
      "_prepareContext",
      "_prepareActivityContext",
      "onChooseActivity",
      "static create",
      "get activity",
      "get item",
      "get title"
    ],
    "ActivitySheet": [
      "activity",
      "expandedSections",
      "title",
      "_prepareContext",
      "_preparePartContext",
      "_prepareActivationContext",
      "_prepareAppliedEffectContext",
      "_prepareDamagePartContext",
      "_prepareEffectContext",
      "_prepareIdentityContext",
      "_getTabs",
      "_markTabs",
      "_onRender",
      "changeTab",
      "toggleNestedTabs",
      "addConsumption",
      "addDamagePart",
      "addEffect",
      "_addEffectData",
      "addRecovery",
      "deleteConsumption",
      "deleteDamagePart",
      "deleteEffect",
      "deleteRecovery",
      "dissociateEffect",
      "toggleCollapsed",
      "_prepareSubmitData",
      "get activity",
      "get expandedSections",
      "get title"
    ],
    "ActivityUsageDialog": [
      "activity",
      "actor",
      "config",
      "item",
      "title",
      "subtitle",
      "used",
      "_configureRenderOptions",
      "_prepareContext",
      "_preparePartContext",
      "_prepareConcentrationContext",
      "_prepareConsumptionContext",
      "_prepareCreationContext",
      "_prepareFooterContext",
      "_prepareScalingContext",
      "_shouldDisplay",
      "onSubmitForm",
      "onUse",
      "_prepareSubmitData",
      "_processSubmitData",
      "create",
      "get activity",
      "get actor",
      "get config",
      "get item",
      "get title",
      "get subtitle",
      "get used"
    ],
    "AttackSheet": [
      "_prepareEffectContext",
      "_prepareIdentityContext"
    ],
    "CastSheet": [
      "_prepareContext",
      "_prepareEffectContext",
      "_prepareIdentityContext",
      "_getTabs",
      "removeSpell"
    ],
    "CheckSheet": [
      "_prepareEffectContext"
    ],
    "DamageSheet": [],
    "EnchantSheet": [
      "_prepareAppliedEffectContext",
      "_prepareEffectContext",
      "_getTabs",
      "_addEffectData"
    ],
    "EnchantUsageDialog": [
      "_prepareCreationContext"
    ],
    "ForwardSheet": [
      "_prepareActivationContext",
      "_prepareEffectContext",
      "_getTabs"
    ],
    "HealSheet": [
      "_prepareEffectContext"
    ],
    "OrderUsageDialog": [
      "_prepareBuildContext",
      "_prepareCostsContext",
      "_prepareCraftContext",
      "_prepareEnlargeContext",
      "_prepareFooterContext",
      "_prepareOrderContext",
      "_preparePartContext",
      "_prepareTradeContext",
      "_attachFrameListeners",
      "_onDrop",
      "_prepareBuildData",
      "_prepareCraftData",
      "_prepareSubmitData",
      "_prepareTradeData",
      "onDeleteOccupant",
      "onRemoveCraft"
    ],
    "SaveSheet": [
      "_prepareAppliedEffectContext",
      "_prepareEffectContext"
    ],
    "SummonSheet": [
      "_prepareEffectContext",
      "_getTabs",
      "_onRender",
      "addProfile",
      "deleteProfile",
      "onDrop"
    ],
    "SummonUsageDialog": [
      "_prepareCreationContext",
      "getProfileLabel"
    ],
    "UtilitySheet": [],
    "BaseConfigSheet": [
      "_prepareContext",
      "defaultOptions",
      "activateListeners",
      "_getActorOverrides",
      "_addOverriddenChoices",
      "static get defaultOptions"
    ],
    "ActorSheet5eCharacter": [
      "defaultOptions",
      "getData",
      "_prepareItems",
      "_prepareItem",
      "activateListeners",
      "_onConfigMenu",
      "_onSheetAction",
      "_onShortRest",
      "_onLongRest",
      "_onDropSingleItem",
      "static get defaultOptions"
    ],
    "AbilityConfig": [
      "propertyConfig",
      "_preparePartContext",
      "get propertyConfig"
    ],
    "ArmorClassConfig": [
      "title",
      "_preparePartContext",
      "get title"
    ],
    "BaseProficiencyConfig": [
      "propertyConfig",
      "propertyLabel",
      "title",
      "_initializeApplicationOptions",
      "_preparePartContext",
      "get propertyConfig",
      "get propertyLabel",
      "get title"
    ],
    "ConcentrationConfig": [
      "title",
      "_preparePartContext",
      "get title"
    ],
    "DamagesConfig": [
      "otherLabel",
      "_preparePartContext",
      "_processChoice",
      "_processFormData",
      "get otherLabel"
    ],
    "DeathConfig": [
      "title",
      "_preparePartContext",
      "get title"
    ],
    "HabitatConfig": [
      "title",
      "_prepareContext",
      "_processFormData",
      "get title"
    ],
    "HitDiceConfig": [
      "title",
      "_preparePartContext",
      "rollDie",
      "stepValue",
      "_processFormData",
      "get title"
    ],
    "HitPointsConfig": [
      "title",
      "_preparePartContext",
      "rollFormula",
      "catch",
      "_processSubmitData",
      "get title",
      "_prepareContext"
    ],
    "InitiativeConfig": [
      "title",
      "_preparePartContext",
      "get title"
    ],
    "LanguagesConfig": [
      "title",
      "_preparePartContext",
      "get title"
    ],
    "SkillToolConfig": [
      "propertyConfig",
      "_preparePartContext",
      "get propertyConfig"
    ],
    "SkillsConfig": [
      "_preparePartContext",
      "_processChoice",
      "_onRender",
      "configureSkill"
    ],
    "SpellSlotsConfig": [
      "title",
      "_preparePartContext",
      "get title"
    ],
    "ToolsConfig": [
      "_processChoice",
      "_onRender",
      "configureTool",
      "_processFormData"
    ],
    "TraitsConfig": [
      "title",
      "otherLabel",
      "_initializeApplicationOptions",
      "_preparePartContext",
      "_processChoices",
      "_processChoice",
      "_processFormData",
      "_filterData",
      "get title",
      "get otherLabel"
    ],
    "TreasureConfig": [
      "title",
      "_prepareContext",
      "_processFormData",
      "get title"
    ],
    "WeaponsConfig": [
      "title",
      "_processChoice",
      "_processFormData",
      "get title"
    ],
    "ActorAbilityConfig": [],
    "ActorArmorConfig": [],
    "ActorConcentrationConfig": [],
    "DamageModificationConfig": [],
    "ActorHitDiceConfig": [],
    "ActorHitPointsConfig": [],
    "ActorInitiativeConfig": [],
    "ActorMovementConfig": [],
    "ProficiencyConfig": [],
    "ActorSensesConfig": [],
    "ActorSkillsConfig": [],
    "ActorSpellSlotsConfig": [],
    "ToolSelector": [],
    "TraitSelector": [],
    "ActorTypeConfig": [],
    "ActorSheet5eNPC": [
      "defaultOptions",
      "getData",
      "_prepareItems",
      "getArmorLabel",
      "_prepareItem",
      "activateListeners",
      "_onConfigMenu",
      "_onSheetAction",
      "_updateObject",
      "static get defaultOptions"
    ],
    "BaseRestDialog": [
      "config",
      "promptNewDay",
      "rested",
      "_prepareContext",
      "handleFormSubmission",
      "configure",
      "get config",
      "get promptNewDay",
      "get rested"
    ],
    "LongRestDialog": [
      "_prepareContext",
      "longRestDialog"
    ],
    "ShortRestDialog": [
      "_prepareContext",
      "rollHitDie",
      "shortRestDialog"
    ],
    "ActorSheetFlags": [
      "defaultOptions",
      "title",
      "getData",
      "_getClasses",
      "_getFlags",
      "_getBonuses",
      "_getNPC",
      "_updateObject",
      "static get defaultOptions",
      "get title"
    ],
    "ActorSheet5eVehicle": [
      "defaultOptions",
      "newCargo",
      "_getMovementSpeed",
      "_prepareCrewedItem",
      "_prepareItems",
      "activateListeners",
      "_onCargoRowChange",
      "_onInventoryEvent",
      "_onDropSingleItem",
      "static get defaultOptions",
      "static get newCargo"
    ],
    "AbilityScoreImprovementConfig": [
      "_prepareContext",
      "adjustValue",
      "lockValue",
      "prepareConfigurationUpdate"
    ],
    "AbilityScoreImprovementFlow": [
      "defaultOptions",
      "retainData",
      "getData",
      "activateListeners",
      "_onChangeInput",
      "_onBrowseCompendium",
      "_onClickButton",
      "_onClickFeature",
      "_onItemDelete",
      "_updateObject",
      "_onDrop",
      "catch",
      "static get defaultOptions"
    ],
    "AdvancementConfig": [
      "advancement",
      "title",
      "_prepareContext",
      "_onRender",
      "deleteDroppedItem",
      "prepareConfigurationUpdate",
      "_processSubmitData",
      "static _cleanedObject",
      "_onDragStart",
      "_onDrop",
      "catch",
      "_validateDroppedItem",
      "get advancement",
      "get title",
      "defaultOptions",
      "close",
      "getData",
      "activateListeners",
      "render",
      "_updateObject",
      "_onItemDelete",
      "_canDragDrop",
      "static get defaultOptions"
    ],
    "AdvancementConfirmationDialog": [
      "defaultOptions",
      "static forDelete",
      "static forLevelDown",
      "static createDialog",
      "static get defaultOptions"
    ],
    "AdvancementFlow": [
      "defaultOptions",
      "id",
      "title",
      "advancement",
      "retainData",
      "getData",
      "_render",
      "getAutomaticApplicationValue",
      "_updateObject",
      "_canDragDrop",
      "static get defaultOptions",
      "get id",
      "get title",
      "get advancement"
    ],
    "AdvancementManager": [
      "subtitle",
      "id",
      "step",
      "previousStep",
      "nextStep",
      "static forNewAdvancement",
      "static forNewItem",
      "static forModifyChoices",
      "static forDeletedAdvancement",
      "static forDeletedItem",
      "static forLevelChange",
      "createLevelChangeSteps",
      "static flowsForLevel",
      "static currentLevel",
      "_configureRenderOptions",
      "_prepareContext",
      "render",
      "_onRender",
      "close",
      "process",
      "forward",
      "catch",
      "synthesizeSteps",
      "backward",
      "clearSyntheticSteps",
      "restart",
      "complete",
      "get subtitle",
      "get id",
      "get step",
      "get previousStep",
      "get nextStep"
    ],
    "AdvancementVisualizer": [
      "manager",
      "_prepareContext",
      "get manager"
    ],
    "AdvancementMigrationDialog": [
      "defaultOptions",
      "static createDialog",
      "static get defaultOptions"
    ],
    "AdvancementSelection": [
      "defaultOptions",
      "id",
      "getData",
      "activateListeners",
      "_onChangeInput",
      "createDialog",
      "static get defaultOptions",
      "get id"
    ],
    "HitPointsFlow": [
      "defaultOptions",
      "getData",
      "activateListeners",
      "_updateRollResult",
      "_updateObject",
      "static get defaultOptions"
    ],
    "ItemChoiceConfig": [
      "_prepareContext",
      "prepareConfigurationUpdate",
      "_validateDroppedItem"
    ],
    "ItemChoiceFlow": [
      "defaultOptions",
      "retainData",
      "getContext",
      "activateListeners",
      "_onChangeInput",
      "_onItemDelete",
      "_onDrop",
      "catch",
      "_maxSpellSlotLevel",
      "static get defaultOptions"
    ],
    "ItemGrantConfig": [
      "_prepareContext",
      "prepareConfigurationUpdate",
      "_validateDroppedItem"
    ],
    "ItemGrantFlow": [
      "defaultOptions",
      "getContext",
      "getData",
      "getSelectAbilities",
      "activateListeners",
      "_onClickFeature",
      "_updateObject",
      "static get defaultOptions"
    ],
    "ScaleValueConfig": [
      "_prepareContext",
      "_prepareLevelData",
      "_mergeScaleValues",
      "activateListeners",
      "_onChangeTitle",
      "prepareConfigurationUpdate",
      "_processSubmitData",
      "static _cleanedObject"
    ],
    "ScaleValueFlow": [
      "defaultOptions",
      "getData",
      "static get defaultOptions"
    ],
    "SizeConfig": [
      "_prepareContext",
      "prepareConfigurationUpdate"
    ],
    "SizeFlow": [
      "defaultOptions",
      "getData",
      "static get defaultOptions"
    ],
    "SubclassFlow": [
      "defaultOptions",
      "retainData",
      "getData",
      "activateListeners",
      "_onBrowseCompendium",
      "_onClickFeature",
      "_onItemDelete",
      "_onDrop",
      "catch",
      "_updateObject",
      "static get defaultOptions"
    ],
    "TraitConfig": [
      "config",
      "types",
      "_prepareContext",
      "_onRender",
      "addChoice",
      "removeChoice",
      "_onChangeForm",
      "prepareConfigurationUpdate",
      "get config",
      "get types"
    ],
    "TraitFlow": [
      "defaultOptions",
      "traitConfig",
      "getData",
      "activateListeners",
      "_onSelectTrait",
      "_onRemoveTrait",
      "_updateObject",
      "prepareInitialValue",
      "prepareTraitSlots",
      "static get defaultOptions",
      "get traitConfig"
    ],
    "Dialog5e": [
      "form",
      "_preparePartContext",
      "_prepareContentContext",
      "_prepareFooterContext",
      "_attachFrameListeners",
      "get form"
    ],
    "PseudoDocumentSheet": [
      "document",
      "isVisible",
      "isEditable",
      "item",
      "_prepareContext",
      "_canRender",
      "_onFirstRender",
      "_onRender",
      "_onClose",
      "_renderFrame",
      "onCopyUuid",
      "onSubmitForm",
      "_prepareSubmitData",
      "_processSubmitData",
      "submit",
      "get document",
      "get isVisible",
      "get isEditable",
      "get item"
    ],
    "Award": [
      "award",
      "origin",
      "transferDestinations",
      "isPartyAward",
      "_prepareContext",
      "static prepareDestinations",
      "_onRender",
      "_onChangeForm",
      "_validateForm",
      "handleFormSubmission",
      "_saveDestinations",
      "displayAwardMessages",
      "static chatMessage",
      "handleAward",
      "catch",
      "static parseAwardCommand",
      "get award",
      "get origin",
      "get transferDestinations",
      "get isPartyAward"
    ],
    "BastionConfig": [],
    "CompendiumBrowserSourceConfig": [
      "static collateSources"
    ],
    "CompendiumBrowser": [
      "displaySelection",
      "currentFilters",
      "selected",
      "selectionLocalizationSuffix",
      "_configureRenderOptions",
      "_prepareContext",
      "_preparePartContext",
      "_prepareFooterContext",
      "_prepareHeaderContext",
      "_prepareSidebarContext",
      "_prepareResultsContext",
      "_prepareTabsContext",
      "_renderFrame",
      "_renderResult",
      "_renderResults",
      "_renderSourceFilters",
      "changeTab",
      "_attachFrameListeners",
      "_attachPartListeners",
      "_applyModeFilters",
      "_applyTabFilters",
      "adjustCheckboxStates",
      "_onChangeForm",
      "_onDragStart",
      "catch",
      "_onKeyAction",
      "_onScrollResults",
      "_onSearchName",
      "onConfigureSources",
      "onClearName",
      "onHandleSubmit",
      "onOpenLink",
      "onSetFilter",
      "onSetType",
      "onToggleCollapse",
      "onToggleMode",
      "select",
      "selectOne",
      "static applyFilters",
      "static injectSidebarButton",
      "static intersectFilters",
      "get displaySelection",
      "get currentFilters",
      "get selected"
    ],
    "AdoptedStyleSheetElement": [
      "adoptedCallback",
      "_getStyleSheet",
      "_adoptStyleSheet"
    ],
    "ChatTrayElement": [
      "open",
      "attributeChangedCallback",
      "_handleClickHeader",
      "_handleToggleOpen",
      "get open",
      "set open"
    ],
    "CopyableTextElement": [
      "connectedCallback",
      "disconnectedCallback",
      "_onClick"
    ],
    "EffectsElement": [
      "connectedCallback",
      "_app",
      "document",
      "static prepareCategories",
      "_getContextOptions",
      "_onAction",
      "_onToggleCondition",
      "_onCreate",
      "_onClickEffectSource",
      "getEffect",
      "get _app",
      "get document"
    ],
    "EnchantmentApplicationElement": [
      "enchantmentActivity",
      "enchantmentItem",
      "connectedCallback",
      "buildItemList",
      "_onDrop",
      "_onRemoveEnchantment",
      "get enchantmentActivity",
      "get enchantmentItem"
    ],
    "InventoryElement": [
      "connectedCallback",
      "_initializeFilterLists",
      "_applyFilters",
      "_app",
      "canUse",
      "actor",
      "document",
      "getItem",
      "_getContextOptions",
      "_onChangeInput",
      "_onChangeInputDelta",
      "_onAdjustInput",
      "_onAction",
      "_onCreate",
      "_onExpand",
      "_onOpenContextMenu",
      "get _app",
      "get canUse",
      "get actor",
      "get document"
    ],
    "ItemListControlsElement": [
      "connectedCallback",
      "app",
      "list",
      "state",
      "tab",
      "prefs",
      "keepEmpty",
      "sortMode",
      "buildHTML",
      "_initFilters",
      "_initGrouping",
      "_initSorting",
      "_applyFilters",
      "_applyGrouping",
      "_applySorting",
      "_onToggleFilterItem",
      "_onToggleMode",
      "_onFilterName",
      "_onClearFilters",
      "get app",
      "get list",
      "get state",
      "get tab",
      "get prefs",
      "get keepEmpty",
      "get sortMode"
    ],
    "SlideToggleElement": [
      "connectedCallback",
      "_buildElements"
    ],
    "TargetedApplicationElement": [
      "targetingMode",
      "buildTargetContainer",
      "buildTargetsList",
      "buildTargetListEntry",
      "_onChangeTargetMode",
      "get targetingMode",
      "set targetingMode"
    ],
    "CurrencyManager": [
      "document",
      "transferDestinations",
      "_prepareContext",
      "_preparePartContext",
      "_getTabs",
      "setTransferValue",
      "_onChangeForm",
      "_validateForm",
      "handleFormSubmission",
      "static convertCurrency",
      "static deductActorCurrency",
      "static getActorCurrencyUpdates",
      "transferCurrency",
      "get document",
      "get transferDestinations"
    ],
    "AttackRollConfigurationDialog": [
      "_prepareConfigurationContext"
    ],
    "D20RollConfigurationDialog": [
      "rollType",
      "_prepareButtonsContext",
      "_finalizeRolls",
      "static get rollType"
    ],
    "DamageRollConfigurationDialog": [
      "rollType",
      "_prepareButtonsContext",
      "_prepareFormulasContext",
      "_buildConfig",
      "_finalizeRolls",
      "static get rollType"
    ],
    "RollConfigurationDialog": [
      "rollType",
      "config",
      "message",
      "rolls",
      "_identifyDiceTerms",
      "_preparePartContext",
      "_prepareButtonsContext",
      "_prepareConfigurationContext",
      "_prepareFormulasContext",
      "buildRolls",
      "_buildConfig",
      "_finalizeRolls",
      "rebuild",
      "handleFormSubmission",
      "_onChangeForm",
      "_onClose",
      "configure",
      "static get rollType",
      "get config",
      "get message",
      "get rolls",
      "get rollType"
    ],
    "SkillToolRollConfigurationDialog": [
      "_prepareConfigurationContext",
      "_onChangeForm"
    ],
    "ContainerSheet": [
      "defaultOptions",
      "template",
      "getData",
      "_onDragStart",
      "_onDrop",
      "_onDropFolder",
      "_onDropItem",
      "_onDropSingleItem",
      "_onSortItem",
      "static get defaultOptions",
      "get template"
    ],
    "CreateScrollDialog": [
      "config",
      "spell",
      "_prepareContentContext",
      "handleFormSubmission",
      "_onChangeForm",
      "_onClose",
      "create",
      "get config",
      "get spell"
    ],
    "EnchantmentConfig": [],
    "StartingEquipmentConfig": [
      "title",
      "_prepareContext",
      "_onRender",
      "_onAction",
      "_onClickAction",
      "_prepareSubmitData",
      "_processSubmitData",
      "_onDragStart",
      "_onDrop",
      "_onSortEntry",
      "get title"
    ],
    "SummoningConfig": [],
    "JournalEditor": [
      "title",
      "_prepareContext",
      "get title"
    ],
    "SpellsUnlinkedConfig": [
      "title",
      "_prepareContext",
      "_processFormData",
      "get title"
    ],
    "DragDropApplication": [
      "_onDragOver",
      "_dropBehavior",
      "_allowedDropBehaviors",
      "_defaultDropBehavior"
    ],
    "PropertyAttribution": [
      "renderTooltip",
      "_insertElement",
      "_prepareContext",
      "getPropertyLabel"
    ],
    "BaseSettingsConfig": [
      "_preparePartContext",
      "createSettingField",
      "onCommitChanges"
    ],
    "BastionSettingsConfig": [
      "_preparePartContext"
    ],
    "CombatSettingsConfig": [
      "_preparePartContext"
    ],
    "CompendiumBrowserSettingsConfig": [
      "_prepareContext",
      "_preparePackageContext",
      "_preparePackGroupContext",
      "_attachFrameListeners",
      "_attachPartListeners",
      "_filterPackages",
      "_onChangeForm",
      "_onFilterPackages",
      "_onTogglePack",
      "_onTogglePackage",
      "_onToggleSource",
      "onClearPackageFilter",
      "onSelectPackage",
      "static collateSources"
    ],
    "ModuleArtSettingsConfig": [
      "defaultOptions",
      "getData",
      "activateListeners",
      "_onAction",
      "_updateObject",
      "static get defaultOptions"
    ],
    "VariantRulesSettingsConfig": [
      "_preparePartContext"
    ],
    "VisibilitySettingsConfig": [
      "_preparePartContext"
    ],
    "CreatureTypeConfig": [
      "title",
      "actor",
      "_preparePartContext",
      "get title",
      "get actor"
    ],
    "MovementSensesConfig": [
      "keyPath",
      "title",
      "types",
      "_initializeApplicationOptions",
      "_preparePartContext",
      "_prepareExtraFields",
      "get keyPath",
      "get title",
      "get types"
    ],
    "SourceConfig": [
      "title",
      "_prepareContext",
      "get title"
    ],
    "TokenPlacement": [
      "static place",
      "place",
      "createPreviews",
      "destroyPreviews",
      "requestPlacement",
      "finishPlacement",
      "onMovePlacement",
      "onRotatePlacement",
      "onConfirmPlacement",
      "onSkipPlacement",
      "static adjustAppendedNumber"
    ],
    "ActorDataModel": [
      "embeddedDescriptionKeyPath",
      "transferDestinations",
      "prepareEmbeddedData",
      "_prepareScaleValues",
      "getRollData",
      "recoverCombatUses",
      "get embeddedDescriptionKeyPath",
      "get transferDestinations"
    ],
    "ItemDataModel": [
      "attackModes",
      "availableAbilities",
      "embeddedDescriptionKeyPath",
      "scalingIncrease",
      "prepareBaseData",
      "richTooltip",
      "getCardData",
      "getCraftCost",
      "getFavoriteData",
      "getSheetData",
      "getRollData",
      "get attackModes",
      "get availableAbilities",
      "get embeddedDescriptionKeyPath",
      "get scalingIncrease"
    ],
    "AttackActivityData": [
      "static defineSchema",
      "ability",
      "actionType",
      "activationLabels",
      "availableAbilities",
      "criticalThreshold",
      "validAttackTypes",
      "static transformTypeData",
      "prepareData",
      "prepareFinalData",
      "getActionLabel",
      "getAttackData",
      "getDamageConfig",
      "getRangeLabel",
      "_processDamagePart",
      "get ability",
      "get actionType",
      "get activationLabels",
      "get availableAbilities",
      "get criticalThreshold",
      "get validAttackTypes"
    ],
    "CastActivityData": [
      "static defineSchema",
      "prepareFinalData"
    ],
    "CheckActivityData": [
      "static defineSchema",
      "ability",
      "static transformTypeData",
      "prepareFinalData",
      "getAbility",
      "get ability"
    ],
    "DamageActivityData": [
      "static defineSchema",
      "static transformTypeData",
      "prepareFinalData",
      "getDamageConfig"
    ],
    "EnchantActivityData": [
      "static defineSchema",
      "actionType",
      "applicableEffects",
      "appliedEnchantments",
      "availableEnchantments",
      "enchantableTypes",
      "static transformEffectsData",
      "static transformTypeData",
      "get actionType",
      "get applicableEffects",
      "get appliedEnchantments",
      "get availableEnchantments",
      "static get enchantableTypes"
    ],
    "AppliedEffectField": [
      "initialize",
      "defineProperty"
    ],
    "ConsumptionTargetsField": [],
    "ConsumptionError": [],
    "ForwardActivityData": [
      "static defineSchema"
    ],
    "HealActivityData": [
      "static defineSchema",
      "static transformTypeData",
      "prepareFinalData",
      "getDamageConfig"
    ],
    "OrderActivityData": [
      "static defineSchema",
      "prepareData"
    ],
    "SaveActivityData": [
      "static defineSchema",
      "ability",
      "static migrateData",
      "static transformTypeData",
      "prepareData",
      "prepareFinalData",
      "getDamageConfig",
      "get ability"
    ],
    "SummonActivityData": [
      "static defineSchema",
      "ability",
      "actionType",
      "applicableEffects",
      "availableProfiles",
      "relevantLevel",
      "summonedCreatures",
      "static transformTypeData",
      "get ability",
      "get actionType",
      "get applicableEffects",
      "get availableProfiles",
      "get relevantLevel",
      "get summonedCreatures"
    ],
    "UtilityActivityData": [
      "static defineSchema",
      "static transformTypeData"
    ],
    "CharacterData": [
      "static defineSchema",
      "static _migrateData",
      "prepareBaseData",
      "prepareEmbeddedData",
      "prepareDerivedData",
      "cantripLevel",
      "hasFavorite",
      "addFavorite",
      "removeFavorite"
    ],
    "DamageTraitField": [],
    "SimpleTraitField": [],
    "NPCData": [
      "static defineSchema",
      "compendiumBrowserFilters",
      "static _migrateData",
      "migrateEnvironment",
      "migrateSource",
      "migrateSpellLevel",
      "migrateTypeData",
      "prepareBaseData",
      "defineProperty",
      "set",
      "prepareEmbeddedData",
      "prepareDerivedData",
      "_preUpdate",
      "cantripLevel",
      "getLegendaryActionsDescription",
      "getGear",
      "recoverCombatUses",
      "resistSave",
      "toEmbed",
      "_prepareEmbedContext",
      "static get compendiumBrowserFilters"
    ],
    "AttributesFields": [
      "armorClass",
      "common",
      "creature",
      "static _migrateInitiative",
      "static prepareBaseArmorClass",
      "static prepareBaseEncumbrance",
      "static prepareArmorClass",
      "catch",
      "static prepareConcentration",
      "static prepareEncumbrance",
      "static prepareExhaustionLevel",
      "static prepareHitPoints",
      "static prepareInitiative",
      "static prepareMovement",
      "static prepareRace",
      "static prepareSpellcastingAbility",
      "defineProperty",
      "static get armorClass",
      "static get common",
      "static get creature"
    ],
    "CreatureTemplate": [
      "static defineSchema",
      "static _initialSkillValue",
      "_spellLevels",
      "static _migrateData",
      "migrateSensesData",
      "migrateToolData",
      "prepareSkills",
      "prepareSkill",
      "prepareTools",
      "getRollData",
      "static get _spellLevels"
    ],
    "DetailsField": [
      "common",
      "creature",
      "static get common",
      "static get creature"
    ],
    "TraitsField": [
      "common",
      "creature",
      "static makeSimpleTrait",
      "static makeDamageTrait",
      "static prepareLanguages",
      "static prepareResistImmune",
      "static get common",
      "static get creature"
    ],
    "VehicleData": [
      "static defineSchema",
      "static _migrateData",
      "migrateSource",
      "prepareBaseData",
      "prepareDerivedData"
    ],
    "AbilityScoreImprovementValueData": [
      "static defineSchema"
    ],
    "BaseAdvancement": [
      "typeName",
      "static defineSchema",
      "static migrateData",
      "static get typeName"
    ],
    "ScaleValueTypeNumber": [
      "static defineSchema",
      "metadata",
      "static convertFrom",
      "static get metadata"
    ],
    "ScaleValueTypeCR": [
      "static defineSchema",
      "metadata",
      "display",
      "static get metadata",
      "get display"
    ],
    "ScaleValueTypeDice": [
      "static defineSchema",
      "metadata",
      "static convertFrom",
      "formula",
      "die",
      "mods",
      "denom",
      "static migrateData",
      "static getFields",
      "static getPlaceholder",
      "static get metadata",
      "get formula",
      "get die",
      "get mods",
      "get denom"
    ],
    "ScaleValueTypeDistance": [
      "metadata",
      "display",
      "static get metadata",
      "get display"
    ],
    "ActivationsField": [
      "static getActivations",
      "static processActivations"
    ],
    "ActorDeltasField": [
      "static getDeltas",
      "static processDeltas"
    ],
    "IndividualDeltaField": [
      "static getDeltas",
      "static processDelta"
    ],
    "RestMessageData": [
      "static defineSchema",
      "actor",
      "_prepareContext",
      "get actor"
    ],
    "TurnMessageData": [
      "static defineSchema",
      "actor",
      "combat",
      "combatant",
      "_prepareContext",
      "get actor",
      "get combat",
      "get combatant"
    ],
    "ActivitiesField": [
      "initialize"
    ],
    "ActivityCollection": [
      "getByType",
      "getByTypes",
      "set",
      "delete",
      "every",
      "toObject"
    ],
    "EnchantmentField": [],
    "EnchantmentError": [],
    "SpellcastingField": [
      "static prepareData"
    ],
    "SummonsField": [],
    "ActionTemplate": [
      "static defineSchema",
      "static _migrateData",
      "migrateAbility",
      "migrateAttack",
      "migrateCritical",
      "migrateSave",
      "abilityMod",
      "_typeAbilityMod",
      "criticalThreshold",
      "_typeCriticalThreshold",
      "hasAbilityCheck",
      "hasAttack",
      "hasDamage",
      "hasSave",
      "hasSummoning",
      "isHealing",
      "isVersatile",
      "getRollData",
      "get abilityMod",
      "get _typeAbilityMod",
      "get criticalThreshold",
      "get _typeCriticalThreshold",
      "get hasAbilityCheck",
      "get hasAttack",
      "get hasDamage",
      "get hasSave",
      "get hasSummoning",
      "get isHealing",
      "get isVersatile"
    ],
    "ActivatedEffectTemplate": [
      "static defineSchema",
      "getUsesData",
      "prepareFinalActivatedEffectData",
      "_prepareFinalFormula",
      "catch",
      "static _migrateData",
      "migrateFormulaFields",
      "migrateRanges",
      "migrateTargets",
      "migrateUses",
      "migrateConsume",
      "activatedEffectCardProperties",
      "hasAreaTarget",
      "hasIndividualTarget",
      "hasLimitedUses",
      "hasResource",
      "hasAmmo",
      "hasScalarDuration",
      "hasScalarRange",
      "hasScalarTarget",
      "hasTarget",
      "isActive",
      "get activatedEffectCardProperties",
      "get hasAreaTarget",
      "get hasIndividualTarget",
      "get hasLimitedUses",
      "get hasResource",
      "get hasAmmo",
      "get hasScalarDuration",
      "get hasScalarRange",
      "get hasScalarTarget",
      "get hasTarget",
      "get isActive"
    ],
    "ItemUsesField": [
      "getUsesData",
      "prepareFinalActivatedEffectData",
      "_prepareFinalFormula",
      "catch",
      "static _migrateData",
      "migrateFormulaFields",
      "migrateRanges",
      "migrateTargets",
      "migrateUses",
      "migrateConsume",
      "activatedEffectCardProperties",
      "hasAreaTarget",
      "hasIndividualTarget",
      "hasLimitedUses",
      "hasResource",
      "hasAmmo",
      "hasScalarDuration",
      "hasScalarRange",
      "hasScalarTarget",
      "hasTarget",
      "isActive",
      "get activatedEffectCardProperties",
      "get hasAreaTarget",
      "get hasIndividualTarget",
      "get hasLimitedUses",
      "get hasResource",
      "get hasAmmo",
      "get hasScalarDuration",
      "get hasScalarRange",
      "get hasScalarTarget",
      "get hasTarget",
      "get isActive"
    ],
    "ActivitiesTemplate": [
      "static defineSchema",
      "abilityMod",
      "_typeAbilityMod",
      "appliedEnchantments",
      "criticalThreshold",
      "hasAttack",
      "hasLimitedUses",
      "hasSave",
      "hasSummoning",
      "isActive",
      "isEnchantment",
      "isHealing",
      "summonedCreatures",
      "static migrateActivities",
      "migrateUses",
      "static initializeActivities",
      "shouldCreateInitialActivity",
      "createInitialActivity",
      "prepareFinalActivityData",
      "getUsesData",
      "recoverUses",
      "onCreateActivities",
      "preUpdateActivities",
      "onUpdateActivities",
      "onDeleteActivities",
      "static _applyActivityShims",
      "get abilityMod",
      "get _typeAbilityMod",
      "get appliedEnchantments",
      "get criticalThreshold",
      "get hasAttack",
      "get hasLimitedUses",
      "get hasSave",
      "get hasSummoning",
      "get isActive",
      "get isEnchantment",
      "get isHealing",
      "get summonedCreatures"
    ],
    "EquippableItemTemplate": [
      "static defineSchema",
      "compendiumBrowserAttunementFilter",
      "static _migrateData",
      "migrateAttunement",
      "migrateEquipped",
      "prepareFinalEquippableData",
      "equippableItemCardProperties",
      "magicAvailable",
      "preCreateEquipped",
      "static get compendiumBrowserAttunementFilter",
      "get equippableItemCardProperties",
      "get magicAvailable"
    ],
    "IdentifiableTemplate": [
      "static defineSchema",
      "static _migrateData",
      "migrateUnidentified",
      "prepareIdentifiable",
      "preUpdateIdentifiable"
    ],
    "ItemDescriptionTemplate": [
      "static defineSchema",
      "static _migrateData",
      "migrateSource",
      "prepareDescriptionData",
      "validProperties",
      "static compendiumBrowserPropertiesFilter",
      "get validProperties"
    ],
    "ItemTypeTemplate": [
      "itemCategories",
      "static _migrateData",
      "migrateType",
      "static get itemCategories",
      "get itemCategories"
    ],
    "MountableTemplate": [
      "static defineSchema"
    ],
    "PhysicalItemTemplate": [
      "static defineSchema",
      "compendiumBrowserPhysicalItemFilters",
      "priceLabel",
      "totalWeight",
      "physicalItemSheetFields",
      "preparePhysicalData",
      "static _migrateData",
      "migratePrice",
      "migrateRarity",
      "migrateWeight",
      "_renderContainers",
      "_preUpdate",
      "_onCreate",
      "_onUpdate",
      "_onDelete",
      "allContainers",
      "totalWeightIn",
      "static get compendiumBrowserPhysicalItemFilters",
      "get priceLabel",
      "get totalWeight",
      "get physicalItemSheetFields"
    ],
    "StartingEquipmentTemplate": [
      "static defineSchema",
      "startingEquipmentDescription",
      "get startingEquipmentDescription"
    ],
    "ActivationField": [
      "static prepareData"
    ],
    "CurrencyTemplate": [
      "static defineSchema",
      "currencyWeight",
      "get currencyWeight"
    ],
    "DamageField": [],
    "DurationField": [
      "static prepareData",
      "static getEffectDuration"
    ],
    "RangeField": [
      "static prepareData"
    ],
    "SourceField": [
      "static prepareData",
      "static getModuleBook",
      "static getPackage",
      "static shimActor",
      "defineProperty"
    ],
    "TargetField": [
      "static prepareData",
      "static templateDimensions"
    ],
    "UsesField": [
      "static prepareData",
      "rechargeOptions",
      "static getStatblockLabel",
      "recoverUses",
      "catch",
      "rollRecharge",
      "static get rechargeOptions"
    ],
    "BasicRoll": [
      "static fromConfig",
      "static constructParts",
      "build",
      "buildConfigure",
      "buildEvaluate",
      "buildPost",
      "static applyKeybindings",
      "isFailure",
      "isSuccess",
      "toMessage",
      "static _prepareMessageData",
      "evaluate",
      "evaluateSync",
      "static replaceFormulaData",
      "preCalculateDiceTerms",
      "static preCalculateTerm",
      "simplify",
      "static mergeConfigs",
      "get isFailure",
      "get isSuccess"
    ],
    "D20Die": [
      "isCriticalSuccess",
      "isCriticalFailure",
      "isValid",
      "applyAdvantage",
      "applyFlag",
      "applyRange",
      "get isCriticalSuccess",
      "get isCriticalFailure",
      "get isValid"
    ],
    "D20Roll": [
      "static fromConfig",
      "static fromRoll",
      "static applyKeybindings",
      "d20",
      "hasAdvantage",
      "hasDisadvantage",
      "isCritical",
      "isFumble",
      "validD20Roll",
      "static _prepareMessageData",
      "configureModifiers",
      "createD20Die",
      "configureDialog",
      "get d20",
      "set d20",
      "get hasAdvantage",
      "get hasDisadvantage",
      "get isCritical",
      "get isFumble",
      "get validD20Roll"
    ],
    "DamageRoll": [
      "static fromConfig",
      "build",
      "static applyKeybindings",
      "isCritical",
      "preprocessFormula",
      "configureDamage",
      "configureDialog",
      "get isCritical"
    ],
    "ActiveEffect5e": [
      "isAppliedEnchantment",
      "isConcealed",
      "isTemporary",
      "getSource",
      "_fromStatusEffect",
      "_initializeSource",
      "apply",
      "applyActivity",
      "static applyField",
      "_applyAdd",
      "_applyLegacy",
      "_applyUpgrade",
      "_prepareFlagChange",
      "determineSuppression",
      "prepareDerivedData",
      "_prepareExhaustionLevel",
      "getFavoriteData",
      "createRiderConditions",
      "createRiderEnchantments",
      "toDragData",
      "_preCreate",
      "_onCreate",
      "_onUpdate",
      "_preDelete",
      "_onDelete",
      "_displayScrollingStatus",
      "static createConcentrationEffectData",
      "static registerHUDListeners",
      "static onRenderActiveEffectConfig",
      "static onTokenHUDRender",
      "static _getExhaustionImage",
      "static getEffectDurationFromItem",
      "static onClickTokenHUD",
      "static _manageExhaustion",
      "static _manageConcentration",
      "addDependent",
      "getDependents",
      "static addOverriddenChoices",
      "richTooltip",
      "deleteDialog",
      "get isAppliedEnchantment",
      "get isConcealed",
      "get isTemporary"
    ],
    "SourcedItemsMap": [
      "get",
      "set",
      "_redirectKeys"
    ],
    "Bastion": [
      "advanceAllBastions",
      "advanceAllFacilities",
      "advanceTurn",
      "resolveAttack",
      "_activateChatListeners",
      "evaluateOrder",
      "evaluateBuildOrder",
      "evaluateCraftOrder",
      "evaluateEnlargeOrder",
      "evaluateHarvestOrder",
      "evaluateRepairOrder",
      "evaluateTradeOrder",
      "getDefenders",
      "onChatAction",
      "onClaimGold",
      "onDragItem",
      "onResolveAttack",
      "onViewItem",
      "renderAttackSummary",
      "renderTurnSummary",
      "confirmAdvance",
      "initializeUI",
      "promptAttack"
    ],
    "BastionAttackDialog": [
      "formula",
      "subtitle",
      "_prepareContentContext",
      "handleFormSubmission",
      "_onClose",
      "static prompt",
      "get formula",
      "get subtitle"
    ],
    "HitDice": [
      "value",
      "max",
      "smallest",
      "smallestAvailable",
      "smallestFace",
      "largest",
      "largestAvailable",
      "largestFace",
      "pct",
      "bySize",
      "toString",
      "createHitDiceUpdates",
      "get value",
      "get max",
      "get smallest",
      "get smallestAvailable",
      "get smallestFace",
      "get largest",
      "get largestAvailable",
      "get largestFace",
      "get pct",
      "get bySize"
    ],
    "Proficiency": [
      "flat",
      "dice",
      "term",
      "hasProficiency",
      "static calculateMod",
      "clone",
      "toString",
      "get flat",
      "get dice",
      "get term",
      "get hasProficiency"
    ],
    "SelectChoices": [
      "asSet",
      "clone",
      "find",
      "forEach",
      "merge",
      "_sort",
      "sort",
      "filter",
      "exclude"
    ],
    "AbilityScoreImprovementAdvancement": [
      "metadata",
      "_preCreate",
      "allowFeat",
      "points",
      "canImprove",
      "titleForLevel",
      "summaryForLevel",
      "apply",
      "restore",
      "reverse",
      "static get metadata",
      "get allowFeat",
      "get points"
    ],
    "AdvancementError": [],
    "HitPointsAdvancement": [
      "metadata",
      "average",
      "levels",
      "hitDie",
      "hitDieValue",
      "configuredForLevel",
      "titleForLevel",
      "valueForLevel",
      "static valueForLevel",
      "total",
      "getAdjustedTotal",
      "static availableForItem",
      "getApplicableValue",
      "apply",
      "automaticApplicationValue",
      "restore",
      "reverse",
      "static get metadata",
      "get average",
      "get levels",
      "get hitDie",
      "get hitDieValue"
    ],
    "ItemChoiceAdvancement": [
      "metadata",
      "levels",
      "configuredForLevel",
      "titleForLevel",
      "summaryForLevel",
      "storagePath",
      "apply",
      "automaticApplicationValue",
      "restore",
      "reverse",
      "_validateItemType",
      "static get metadata",
      "get levels"
    ],
    "ItemGrantAdvancement": [
      "metadata",
      "configuredForLevel",
      "summaryForLevel",
      "storagePath",
      "apply",
      "automaticApplicationValue",
      "restore",
      "reverse",
      "_validateItemType",
      "static get metadata"
    ],
    "ScaleValueAdvancement": [
      "metadata",
      "static localize",
      "levels",
      "identifier",
      "titleForLevel",
      "valueForLevel",
      "testEquality",
      "automaticApplicationValue",
      "getContextMenuOptions",
      "static get metadata",
      "get levels",
      "get identifier"
    ],
    "SizeAdvancement": [
      "metadata",
      "automaticHint",
      "levels",
      "summaryForLevel",
      "static availableForItem",
      "apply",
      "automaticApplicationValue",
      "restore",
      "reverse",
      "static get metadata",
      "get automaticHint",
      "get levels"
    ],
    "SubclassAdvancement": [
      "metadata",
      "configuredForLevel",
      "summaryforLevel",
      "static availableForItem",
      "apply",
      "restore",
      "reverse",
      "static get metadata"
    ],
    "TraitAdvancement": [
      "metadata",
      "static localize",
      "maxTraits",
      "prepareData",
      "configuredForLevel",
      "sortingValueForLevel",
      "summaryForLevel",
      "apply",
      "automaticApplicationValue",
      "restore",
      "reverse",
      "actorSelected",
      "representedTraits",
      "availableChoices",
      "unfulfilledChoices",
      "static get metadata",
      "get maxTraits"
    ],
    "ChatMessage5e": [
      "canApplyDamage",
      "canSelectTargets",
      "isRoll",
      "shouldDisplayChallenge",
      "static migrateData",
      "prepareData",
      "getHTML",
      "_collapseTrays",
      "_displayChatActionButtons",
      "_highlightCriticalSuccessFailure",
      "makeIcon",
      "_enrichChatCard",
      "_enrichRollTooltip",
      "_enrichAttackTargets",
      "_enrichDamageTooltip",
      "_simplifyDamageRoll",
      "_enrichEnchantmentTooltip",
      "_enrichSaveTooltip",
      "_enrichUsageEffects",
      "static addChatMessageContextOptions",
      "_activateActivityListeners",
      "_onTargetMouseDown",
      "_onTargetHoverIn",
      "_onTargetHoverOut",
      "applyChatCardDamage",
      "selectTargets",
      "applyChatCardTemp",
      "_onClickDiceRoll",
      "static onRenderChatPopout",
      "static onRenderChatLog",
      "static activateListeners",
      "static toggleModifiers",
      "_onDelete",
      "getAssociatedActivity",
      "getAssociatedActor",
      "getAssociatedItem",
      "getAssociatedRolls",
      "getOriginatingMessage",
      "_shimFlags",
      "defineProperty",
      "get canApplyDamage",
      "get canSelectTargets",
      "get isRoll",
      "get shouldDisplayChallenge"
    ],
    "Combat5e": [
      "startCombat",
      "endCombat",
      "rollAll",
      "rollNPC",
      "rollInitiative",
      "_sortCombatants",
      "_onUpdate",
      "_onDelete",
      "_onEndTurn",
      "_onStartTurn",
      "createGroups",
      "_recoverUses"
    ],
    "Combatant5e": [
      "createTurnMessage",
      "getGroupingKey",
      "getInitiativeRoll",
      "recoverCombatUses",
      "refreshDynamicRing",
      "_onDelete",
      "_onUpdateOperation"
    ],
    "JournalEntryPage5e": [
      "getRollData"
    ],
    "SystemFlags": [
      "_systemFlagsDataModel",
      "prepareData",
      "setFlag",
      "get _systemFlagsDataModel"
    ],
    "PseudoDocument": [
      "metadata",
      "documentConfig",
      "documentName",
      "id",
      "relativeID",
      "uuid",
      "item",
      "actor",
      "sheet",
      "render",
      "static _registerApp",
      "static _unregisterApp",
      "update",
      "updateSource",
      "delete",
      "deleteDialog",
      "toDragData",
      "createDialog",
      "get metadata",
      "static get documentConfig",
      "get documentConfig",
      "static get documentName",
      "get documentName",
      "get id",
      "get relativeID",
      "get uuid",
      "get item",
      "get actor",
      "get sheet"
    ],
    "Scaling": [
      "increase",
      "value",
      "toString",
      "get increase",
      "get value"
    ],
    "ModuleArt": [
      "registerModuleArt",
      "catch",
      "parseArtMapping",
      "apply",
      "static getModuleArtPath",
      "static getArtModules"
    ],
    "EnchantmentRegisty": [
      "static applied",
      "static track",
      "static untrack"
    ],
    "ItemRegistry": [
      "choices",
      "options",
      "get",
      "initialize",
      "get choices",
      "get options"
    ],
    "MessageRegistry": [
      "static get",
      "static track",
      "static untrack"
    ],
    "SpellListRegistry": [
      "options",
      "ready",
      "static forSpell",
      "static forType",
      "register",
      "static get options",
      "static get ready"
    ],
    "SpellList": [
      "indexes",
      "metadata",
      "name",
      "uuids",
      "contribute",
      "getSpells",
      "get indexes",
      "get metadata",
      "get name",
      "get uuids"
    ],
    "SummonRegistry": [
      "static creatures",
      "static track",
      "static untrack"
    ],
    "Tooltips5e": [
      "tooltip",
      "observe",
      "_onMutation",
      "_onTooltipActivate",
      "_onHoverActor",
      "_onHoverContentLink",
      "_onHoverPassive",
      "_positionItemTooltip",
      "static activateListeners",
      "get tooltip"
    ]
  },
  "methodDocs": {
    "Accordion": {
      "bind": "",
      "_onClickHeading": "",
      "_onExpandSection": "",
      "_onCollapseSection": "",
      "_onEnd": "",
      "cancelOngoing": "",
      "_saveCollapsedState": "",
      "_restoreCollapsedState": ""
    },
    "ActivityChoiceDialog": {
      "activity": "",
      "item": "",
      "title": "",
      "_configureRenderOptions": "",
      "_prepareContext": "",
      "_prepareActivityContext": "",
      "onChooseActivity": "",
      "static create": "",
      "get activity": "",
      "get item": "",
      "get title": ""
    },
    "ActivitySheet": {
      "activity": "",
      "expandedSections": "",
      "title": "",
      "_prepareContext": "",
      "_preparePartContext": "",
      "_prepareActivationContext": "",
      "_prepareAppliedEffectContext": "",
      "_prepareDamagePartContext": "",
      "_prepareEffectContext": "",
      "_prepareIdentityContext": "",
      "_getTabs": "",
      "_markTabs": "",
      "_onRender": "",
      "changeTab": "",
      "toggleNestedTabs": "",
      "addConsumption": "",
      "addDamagePart": "",
      "addEffect": "",
      "_addEffectData": "",
      "addRecovery": "",
      "deleteConsumption": "",
      "deleteDamagePart": "",
      "deleteEffect": "",
      "deleteRecovery": "",
      "dissociateEffect": "",
      "toggleCollapsed": "",
      "_prepareSubmitData": "",
      "get activity": "",
      "get expandedSections": "",
      "get title": ""
    },
    "ActivityUsageDialog": {
      "activity": "",
      "actor": "",
      "config": "",
      "item": "",
      "title": "",
      "subtitle": "",
      "used": "",
      "_configureRenderOptions": "",
      "_prepareContext": "",
      "_preparePartContext": "",
      "_prepareConcentrationContext": "",
      "_prepareConsumptionContext": "",
      "_prepareCreationContext": "",
      "_prepareFooterContext": "",
      "_prepareScalingContext": "",
      "_shouldDisplay": "",
      "onSubmitForm": "",
      "onUse": "",
      "_prepareSubmitData": "",
      "_processSubmitData": "",
      "create": "",
      "get activity": "",
      "get actor": "",
      "get config": "",
      "get item": "",
      "get title": "",
      "get subtitle": "",
      "get used": ""
    },
    "AttackSheet": {
      "_prepareEffectContext": "",
      "_prepareIdentityContext": ""
    },
    "CastSheet": {
      "_prepareContext": "",
      "_prepareEffectContext": "",
      "_prepareIdentityContext": "",
      "_getTabs": "",
      "removeSpell": ""
    },
    "CheckSheet": {
      "_prepareEffectContext": ""
    },
    "DamageSheet": {},
    "EnchantSheet": {
      "_prepareAppliedEffectContext": "",
      "_prepareEffectContext": "",
      "_getTabs": "",
      "_addEffectData": ""
    },
    "EnchantUsageDialog": {
      "_prepareCreationContext": ""
    },
    "ForwardSheet": {
      "_prepareActivationContext": "",
      "_prepareEffectContext": "",
      "_getTabs": ""
    },
    "HealSheet": {
      "_prepareEffectContext": ""
    },
    "OrderUsageDialog": {
      "_prepareBuildContext": "",
      "_prepareCostsContext": "",
      "_prepareCraftContext": "",
      "_prepareEnlargeContext": "",
      "_prepareFooterContext": "",
      "_prepareOrderContext": "",
      "_preparePartContext": "",
      "_prepareTradeContext": "",
      "_attachFrameListeners": "",
      "_onDrop": "",
      "_prepareBuildData": "",
      "_prepareCraftData": "",
      "_prepareSubmitData": "",
      "_prepareTradeData": "",
      "onDeleteOccupant": "",
      "onRemoveCraft": ""
    },
    "SaveSheet": {
      "_prepareAppliedEffectContext": "",
      "_prepareEffectContext": ""
    },
    "SummonSheet": {
      "_prepareEffectContext": "",
      "_getTabs": "",
      "_onRender": "",
      "addProfile": "",
      "deleteProfile": "",
      "onDrop": ""
    },
    "SummonUsageDialog": {
      "_prepareCreationContext": "",
      "getProfileLabel": ""
    },
    "UtilitySheet": {},
    "BaseConfigSheet": {
      "_prepareContext": "",
      "defaultOptions": "",
      "activateListeners": "",
      "_getActorOverrides": "",
      "_addOverriddenChoices": "",
      "static get defaultOptions": ""
    },
    "ActorSheet5eCharacter": {
      "defaultOptions": "",
      "getData": "",
      "_prepareItems": "",
      "_prepareItem": "",
      "activateListeners": "",
      "_onConfigMenu": "",
      "_onSheetAction": "",
      "_onShortRest": "",
      "_onLongRest": "",
      "_onDropSingleItem": "",
      "static get defaultOptions": ""
    },
    "AbilityConfig": {
      "propertyConfig": "",
      "_preparePartContext": "",
      "get propertyConfig": ""
    },
    "ArmorClassConfig": {
      "title": "",
      "_preparePartContext": "",
      "get title": ""
    },
    "BaseProficiencyConfig": {
      "propertyConfig": "",
      "propertyLabel": "",
      "title": "",
      "_initializeApplicationOptions": "",
      "_preparePartContext": "",
      "get propertyConfig": "",
      "get propertyLabel": "",
      "get title": ""
    },
    "ConcentrationConfig": {
      "title": "",
      "_preparePartContext": "",
      "get title": ""
    },
    "DamagesConfig": {
      "otherLabel": "",
      "_preparePartContext": "",
      "_processChoice": "",
      "_processFormData": "",
      "get otherLabel": ""
    },
    "DeathConfig": {
      "title": "",
      "_preparePartContext": "",
      "get title": ""
    },
    "HabitatConfig": {
      "title": "",
      "_prepareContext": "",
      "_processFormData": "",
      "get title": ""
    },
    "HitDiceConfig": {
      "title": "",
      "_preparePartContext": "",
      "rollDie": "",
      "stepValue": "",
      "_processFormData": "",
      "get title": ""
    },
    "HitPointsConfig": {
      "title": "",
      "_preparePartContext": "",
      "rollFormula": "",
      "catch": "",
      "_processSubmitData": "",
      "get title": "",
      "_prepareContext": ""
    },
    "InitiativeConfig": {
      "title": "",
      "_preparePartContext": "",
      "get title": ""
    },
    "LanguagesConfig": {
      "title": "",
      "_preparePartContext": "",
      "get title": ""
    },
    "SkillToolConfig": {
      "propertyConfig": "",
      "_preparePartContext": "",
      "get propertyConfig": ""
    },
    "SkillsConfig": {
      "_preparePartContext": "",
      "_processChoice": "",
      "_onRender": "",
      "configureSkill": ""
    },
    "SpellSlotsConfig": {
      "title": "",
      "_preparePartContext": "",
      "get title": ""
    },
    "ToolsConfig": {
      "_processChoice": "",
      "_onRender": "",
      "configureTool": "",
      "_processFormData": ""
    },
    "TraitsConfig": {
      "title": "",
      "otherLabel": "",
      "_initializeApplicationOptions": "",
      "_preparePartContext": "",
      "_processChoices": "",
      "_processChoice": "",
      "_processFormData": "",
      "_filterData": "",
      "get title": "",
      "get otherLabel": ""
    },
    "TreasureConfig": {
      "title": "",
      "_prepareContext": "",
      "_processFormData": "",
      "get title": ""
    },
    "WeaponsConfig": {
      "title": "",
      "_processChoice": "",
      "_processFormData": "",
      "get title": ""
    },
    "ActorAbilityConfig": {},
    "ActorArmorConfig": {},
    "ActorConcentrationConfig": {},
    "DamageModificationConfig": {},
    "ActorHitDiceConfig": {},
    "ActorHitPointsConfig": {},
    "ActorInitiativeConfig": {},
    "ActorMovementConfig": {},
    "ProficiencyConfig": {},
    "ActorSensesConfig": {},
    "ActorSkillsConfig": {},
    "ActorSpellSlotsConfig": {},
    "ToolSelector": {},
    "TraitSelector": {},
    "ActorTypeConfig": {},
    "ActorSheet5eNPC": {
      "defaultOptions": "",
      "getData": "",
      "_prepareItems": "",
      "getArmorLabel": "",
      "_prepareItem": "",
      "activateListeners": "",
      "_onConfigMenu": "",
      "_onSheetAction": "",
      "_updateObject": "",
      "static get defaultOptions": ""
    },
    "BaseRestDialog": {
      "config": "",
      "promptNewDay": "",
      "rested": "",
      "_prepareContext": "",
      "handleFormSubmission": "",
      "configure": "",
      "get config": "",
      "get promptNewDay": "",
      "get rested": ""
    },
    "LongRestDialog": {
      "_prepareContext": "",
      "longRestDialog": ""
    },
    "ShortRestDialog": {
      "_prepareContext": "",
      "rollHitDie": "",
      "shortRestDialog": ""
    },
    "ActorSheetFlags": {
      "defaultOptions": "",
      "title": "",
      "getData": "",
      "_getClasses": "",
      "_getFlags": "",
      "_getBonuses": "",
      "_getNPC": "",
      "_updateObject": "",
      "static get defaultOptions": "",
      "get title": ""
    },
    "ActorSheet5eVehicle": {
      "defaultOptions": "",
      "newCargo": "",
      "_getMovementSpeed": "",
      "_prepareCrewedItem": "",
      "_prepareItems": "",
      "activateListeners": "",
      "_onCargoRowChange": "",
      "_onInventoryEvent": "",
      "_onDropSingleItem": "",
      "static get defaultOptions": "",
      "static get newCargo": ""
    },
    "AbilityScoreImprovementConfig": {
      "_prepareContext": "",
      "adjustValue": "",
      "lockValue": "",
      "prepareConfigurationUpdate": ""
    },
    "AbilityScoreImprovementFlow": {
      "defaultOptions": "",
      "retainData": "",
      "getData": "",
      "activateListeners": "",
      "_onChangeInput": "",
      "_onBrowseCompendium": "",
      "_onClickButton": "",
      "_onClickFeature": "",
      "_onItemDelete": "",
      "_updateObject": "",
      "_onDrop": "",
      "catch": "",
      "static get defaultOptions": ""
    },
    "AdvancementConfig": {
      "advancement": "",
      "title": "",
      "_prepareContext": "",
      "_onRender": "",
      "deleteDroppedItem": "",
      "prepareConfigurationUpdate": "",
      "_processSubmitData": "",
      "static _cleanedObject": "",
      "_onDragStart": "",
      "_onDrop": "",
      "catch": "",
      "_validateDroppedItem": "",
      "get advancement": "",
      "get title": "",
      "defaultOptions": "",
      "close": "",
      "getData": "",
      "activateListeners": "",
      "render": "",
      "_updateObject": "",
      "_onItemDelete": "",
      "_canDragDrop": "",
      "static get defaultOptions": ""
    },
    "AdvancementConfirmationDialog": {
      "defaultOptions": "",
      "static forDelete": "",
      "static forLevelDown": "",
      "static createDialog": "",
      "static get defaultOptions": ""
    },
    "AdvancementFlow": {
      "defaultOptions": "",
      "id": "",
      "title": "",
      "advancement": "",
      "retainData": "",
      "getData": "",
      "_render": "",
      "getAutomaticApplicationValue": "",
      "_updateObject": "",
      "_canDragDrop": "",
      "static get defaultOptions": "",
      "get id": "",
      "get title": "",
      "get advancement": ""
    },
    "AdvancementManager": {
      "subtitle": "",
      "id": "",
      "step": "",
      "previousStep": "",
      "nextStep": "",
      "static forNewAdvancement": "",
      "static forNewItem": "",
      "static forModifyChoices": "",
      "static forDeletedAdvancement": "",
      "static forDeletedItem": "",
      "static forLevelChange": "",
      "createLevelChangeSteps": "",
      "static flowsForLevel": "",
      "static currentLevel": "",
      "_configureRenderOptions": "",
      "_prepareContext": "",
      "render": "",
      "_onRender": "",
      "close": "",
      "process": "",
      "forward": "",
      "catch": "",
      "synthesizeSteps": "",
      "backward": "",
      "clearSyntheticSteps": "",
      "restart": "",
      "complete": "",
      "get subtitle": "",
      "get id": "",
      "get step": "",
      "get previousStep": "",
      "get nextStep": ""
    },
    "AdvancementVisualizer": {
      "manager": "",
      "_prepareContext": "",
      "get manager": ""
    },
    "AdvancementMigrationDialog": {
      "defaultOptions": "",
      "static createDialog": "",
      "static get defaultOptions": ""
    },
    "AdvancementSelection": {
      "defaultOptions": "",
      "id": "",
      "getData": "",
      "activateListeners": "",
      "_onChangeInput": "",
      "createDialog": "",
      "static get defaultOptions": "",
      "get id": ""
    },
    "HitPointsFlow": {
      "defaultOptions": "",
      "getData": "",
      "activateListeners": "",
      "_updateRollResult": "",
      "_updateObject": "",
      "static get defaultOptions": ""
    },
    "ItemChoiceConfig": {
      "_prepareContext": "",
      "prepareConfigurationUpdate": "",
      "_validateDroppedItem": ""
    },
    "ItemChoiceFlow": {
      "defaultOptions": "",
      "retainData": "",
      "getContext": "",
      "activateListeners": "",
      "_onChangeInput": "",
      "_onItemDelete": "",
      "_onDrop": "",
      "catch": "",
      "_maxSpellSlotLevel": "",
      "static get defaultOptions": ""
    },
    "ItemGrantConfig": {
      "_prepareContext": "",
      "prepareConfigurationUpdate": "",
      "_validateDroppedItem": ""
    },
    "ItemGrantFlow": {
      "defaultOptions": "",
      "getContext": "",
      "getData": "",
      "getSelectAbilities": "",
      "activateListeners": "",
      "_onClickFeature": "",
      "_updateObject": "",
      "static get defaultOptions": ""
    },
    "ScaleValueConfig": {
      "_prepareContext": "",
      "_prepareLevelData": "",
      "_mergeScaleValues": "",
      "activateListeners": "",
      "_onChangeTitle": "",
      "prepareConfigurationUpdate": "",
      "_processSubmitData": "",
      "static _cleanedObject": ""
    },
    "ScaleValueFlow": {
      "defaultOptions": "",
      "getData": "",
      "static get defaultOptions": ""
    },
    "SizeConfig": {
      "_prepareContext": "",
      "prepareConfigurationUpdate": ""
    },
    "SizeFlow": {
      "defaultOptions": "",
      "getData": "",
      "static get defaultOptions": ""
    },
    "SubclassFlow": {
      "defaultOptions": "",
      "retainData": "",
      "getData": "",
      "activateListeners": "",
      "_onBrowseCompendium": "",
      "_onClickFeature": "",
      "_onItemDelete": "",
      "_onDrop": "",
      "catch": "",
      "_updateObject": "",
      "static get defaultOptions": ""
    },
    "TraitConfig": {
      "config": "",
      "types": "",
      "_prepareContext": "",
      "_onRender": "",
      "addChoice": "",
      "removeChoice": "",
      "_onChangeForm": "",
      "prepareConfigurationUpdate": "",
      "get config": "",
      "get types": ""
    },
    "TraitFlow": {
      "defaultOptions": "",
      "traitConfig": "",
      "getData": "",
      "activateListeners": "",
      "_onSelectTrait": "",
      "_onRemoveTrait": "",
      "_updateObject": "",
      "prepareInitialValue": "",
      "prepareTraitSlots": "",
      "static get defaultOptions": "",
      "get traitConfig": ""
    },
    "Dialog5e": {
      "form": "",
      "_preparePartContext": "",
      "_prepareContentContext": "",
      "_prepareFooterContext": "",
      "_attachFrameListeners": "",
      "get form": ""
    },
    "PseudoDocumentSheet": {
      "document": "",
      "isVisible": "",
      "isEditable": "",
      "item": "",
      "_prepareContext": "",
      "_canRender": "",
      "_onFirstRender": "",
      "_onRender": "",
      "_onClose": "",
      "_renderFrame": "",
      "onCopyUuid": "",
      "onSubmitForm": "",
      "_prepareSubmitData": "",
      "_processSubmitData": "",
      "submit": "",
      "get document": "",
      "get isVisible": "",
      "get isEditable": "",
      "get item": ""
    },
    "Award": {
      "award": "",
      "origin": "",
      "transferDestinations": "",
      "isPartyAward": "",
      "_prepareContext": "",
      "static prepareDestinations": "",
      "_onRender": "",
      "_onChangeForm": "",
      "_validateForm": "",
      "handleFormSubmission": "",
      "_saveDestinations": "",
      "displayAwardMessages": "",
      "static chatMessage": "",
      "handleAward": "",
      "catch": "",
      "static parseAwardCommand": "",
      "get award": "",
      "get origin": "",
      "get transferDestinations": "",
      "get isPartyAward": ""
    },
    "BastionConfig": {},
    "CompendiumBrowserSourceConfig": {
      "static collateSources": ""
    },
    "CompendiumBrowser": {
      "displaySelection": "",
      "currentFilters": "",
      "selected": "",
      "selectionLocalizationSuffix": "",
      "_configureRenderOptions": "",
      "_prepareContext": "",
      "_preparePartContext": "",
      "_prepareFooterContext": "",
      "_prepareHeaderContext": "",
      "_prepareSidebarContext": "",
      "_prepareResultsContext": "",
      "_prepareTabsContext": "",
      "_renderFrame": "",
      "_renderResult": "",
      "_renderResults": "",
      "_renderSourceFilters": "",
      "changeTab": "",
      "_attachFrameListeners": "",
      "_attachPartListeners": "",
      "_applyModeFilters": "",
      "_applyTabFilters": "",
      "adjustCheckboxStates": "",
      "_onChangeForm": "",
      "_onDragStart": "",
      "catch": "",
      "_onKeyAction": "",
      "_onScrollResults": "",
      "_onSearchName": "",
      "onConfigureSources": "",
      "onClearName": "",
      "onHandleSubmit": "",
      "onOpenLink": "",
      "onSetFilter": "",
      "onSetType": "",
      "onToggleCollapse": "",
      "onToggleMode": "",
      "select": "",
      "selectOne": "",
      "static applyFilters": "",
      "static injectSidebarButton": "",
      "static intersectFilters": "",
      "get displaySelection": "",
      "get currentFilters": "",
      "get selected": ""
    },
    "AdoptedStyleSheetElement": {
      "adoptedCallback": "",
      "_getStyleSheet": "",
      "_adoptStyleSheet": ""
    },
    "ChatTrayElement": {
      "open": "",
      "attributeChangedCallback": "",
      "_handleClickHeader": "",
      "_handleToggleOpen": "",
      "get open": "",
      "set open": ""
    },
    "CopyableTextElement": {
      "connectedCallback": "",
      "disconnectedCallback": "",
      "_onClick": ""
    },
    "EffectsElement": {
      "connectedCallback": "",
      "_app": "",
      "document": "",
      "static prepareCategories": "",
      "_getContextOptions": "",
      "_onAction": "",
      "_onToggleCondition": "",
      "_onCreate": "",
      "_onClickEffectSource": "",
      "getEffect": "",
      "get _app": "",
      "get document": ""
    },
    "EnchantmentApplicationElement": {
      "enchantmentActivity": "",
      "enchantmentItem": "",
      "connectedCallback": "Application to handle applying enchantments to items from a chat card.\n/\nexport default class EnchantmentApplicationElement extends HTMLElement {\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nThe chat message with which this enchantment is associated.\n@type {ChatMessage5e}\n/\n  chatMessage;\n\n  /* -------------------------------------------- */\n\n  /**\nArea where the enchantment limit & current count is displayed.\n@type {HTMLElement}\n/\n  countArea;\n\n  /* -------------------------------------------- */\n\n  /**\nArea where items can be dropped to enchant.\n@type {HTMLElement}\n/\n  dropArea;\n\n  /* -------------------------------------------- */\n\n  /**\nActivity providing the enchantment that will be applied.\n@type {Item5e}\n/\n  get enchantmentActivity() {\n    return this.chatMessage.getAssociatedActivity();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nItem providing the enchantment that will be applied.\n@type {Item5e}\n/\n  get enchantmentItem() {\n    return this.chatMessage.getAssociatedItem();\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering",
      "buildItemList": "",
      "_onDrop": "",
      "_onRemoveEnchantment": "",
      "get enchantmentActivity": "",
      "get enchantmentItem": ""
    },
    "InventoryElement": {
      "connectedCallback": "",
      "_initializeFilterLists": "",
      "_applyFilters": "",
      "_app": "",
      "canUse": "",
      "actor": "",
      "document": "",
      "getItem": "",
      "_getContextOptions": "",
      "_onChangeInput": "",
      "_onChangeInputDelta": "",
      "_onAdjustInput": "",
      "_onAction": "",
      "_onCreate": "",
      "_onExpand": "",
      "_onOpenContextMenu": "",
      "get _app": "",
      "get canUse": "",
      "get actor": "",
      "get document": ""
    },
    "ItemListControlsElement": {
      "connectedCallback": "",
      "app": "",
      "list": "",
      "state": "",
      "tab": "",
      "prefs": "",
      "keepEmpty": "",
      "sortMode": "",
      "buildHTML": "",
      "_initFilters": "",
      "_initGrouping": "",
      "_initSorting": "",
      "_applyFilters": "",
      "_applyGrouping": "",
      "_applySorting": "",
      "_onToggleFilterItem": "",
      "_onToggleMode": "",
      "_onFilterName": "",
      "_onClearFilters": "",
      "get app": "",
      "get list": "",
      "get state": "",
      "get tab": "",
      "get prefs": "",
      "get keepEmpty": "",
      "get sortMode": ""
    },
    "SlideToggleElement": {
      "connectedCallback": "",
      "_buildElements": ""
    },
    "TargetedApplicationElement": {
      "targetingMode": "",
      "buildTargetContainer": "",
      "buildTargetsList": "",
      "buildTargetListEntry": "",
      "_onChangeTargetMode": "",
      "get targetingMode": "",
      "set targetingMode": ""
    },
    "CurrencyManager": {
      "document": "",
      "transferDestinations": "",
      "_prepareContext": "",
      "_preparePartContext": "",
      "_getTabs": "",
      "setTransferValue": "",
      "_onChangeForm": "",
      "_validateForm": "",
      "handleFormSubmission": "",
      "static convertCurrency": "",
      "static deductActorCurrency": "",
      "static getActorCurrencyUpdates": "",
      "transferCurrency": "",
      "get document": "",
      "get transferDestinations": ""
    },
    "AttackRollConfigurationDialog": {
      "_prepareConfigurationContext": ""
    },
    "D20RollConfigurationDialog": {
      "rollType": "",
      "_prepareButtonsContext": "",
      "_finalizeRolls": "",
      "static get rollType": ""
    },
    "DamageRollConfigurationDialog": {
      "rollType": "",
      "_prepareButtonsContext": "",
      "_prepareFormulasContext": "",
      "_buildConfig": "",
      "_finalizeRolls": "",
      "static get rollType": ""
    },
    "RollConfigurationDialog": {
      "rollType": "",
      "config": "",
      "message": "",
      "rolls": "",
      "_identifyDiceTerms": "",
      "_preparePartContext": "",
      "_prepareButtonsContext": "",
      "_prepareConfigurationContext": "",
      "_prepareFormulasContext": "",
      "buildRolls": "",
      "_buildConfig": "",
      "_finalizeRolls": "",
      "rebuild": "",
      "handleFormSubmission": "",
      "_onChangeForm": "",
      "_onClose": "",
      "configure": "",
      "static get rollType": "",
      "get config": "",
      "get message": "",
      "get rolls": "",
      "get rollType": ""
    },
    "SkillToolRollConfigurationDialog": {
      "_prepareConfigurationContext": "",
      "_onChangeForm": "@typedef {BasicRollConfigurationDialogOptions} SkillToolRollConfigurationDialogOptions\n@property {boolean} chooseAbility  Should the ability be selectable?\n/\n\n/**\nExtended roll configuration dialog that allows selecting abilities.\n/\nexport default class SkillToolRollConfigurationDialog extends D20RollConfigurationDialog {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    chooseAbility: true\n  };\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _prepareConfigurationContext(context, options) {\n    context = await super._prepareConfigurationContext(context, options);\n    if ( this.options.chooseAbility ) context.fields.unshift({\n      field: new foundry.data.fields.StringField({ label: game.i18n.localize(\"DND5E.Abilities\") }),\n      name: \"ability\",\n      options: Object.entries(CONFIG.DND5E.abilities).map(([value, { label }]) => ({ value, label })),\n      value: this.config.ability\n    });\n    return context;\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers"
    },
    "ContainerSheet": {
      "defaultOptions": "",
      "template": "",
      "getData": "",
      "_onDragStart": "",
      "_onDrop": "",
      "_onDropFolder": "",
      "_onDropItem": "",
      "_onDropSingleItem": "",
      "_onSortItem": "",
      "static get defaultOptions": "",
      "get template": ""
    },
    "CreateScrollDialog": {
      "config": "",
      "spell": "",
      "_prepareContentContext": "",
      "handleFormSubmission": "",
      "_onChangeForm": "",
      "_onClose": "",
      "create": "",
      "get config": "",
      "get spell": ""
    },
    "EnchantmentConfig": {},
    "StartingEquipmentConfig": {
      "title": "",
      "_prepareContext": "",
      "_onRender": "",
      "_onAction": "",
      "_onClickAction": "",
      "_prepareSubmitData": "",
      "_processSubmitData": "",
      "_onDragStart": "",
      "_onDrop": "",
      "_onSortEntry": "",
      "get title": ""
    },
    "SummoningConfig": {},
    "JournalEditor": {
      "title": "",
      "_prepareContext": "",
      "get title": ""
    },
    "SpellsUnlinkedConfig": {
      "title": "",
      "_prepareContext": "",
      "_processFormData": "",
      "get title": ""
    },
    "DragDropApplication": {
      "_onDragOver": "",
      "_dropBehavior": "",
      "_allowedDropBehaviors": "",
      "_defaultDropBehavior": ""
    },
    "PropertyAttribution": {
      "renderTooltip": "",
      "_insertElement": "",
      "_prepareContext": "",
      "getPropertyLabel": ""
    },
    "BaseSettingsConfig": {
      "_preparePartContext": "",
      "createSettingField": "",
      "onCommitChanges": ""
    },
    "BastionSettingsConfig": {
      "_preparePartContext": ""
    },
    "CombatSettingsConfig": {
      "_preparePartContext": ""
    },
    "CompendiumBrowserSettingsConfig": {
      "_prepareContext": "",
      "_preparePackageContext": "",
      "_preparePackGroupContext": "",
      "_attachFrameListeners": "",
      "_attachPartListeners": "",
      "_filterPackages": "",
      "_onChangeForm": "",
      "_onFilterPackages": "",
      "_onTogglePack": "",
      "_onTogglePackage": "",
      "_onToggleSource": "",
      "onClearPackageFilter": "",
      "onSelectPackage": "",
      "static collateSources": ""
    },
    "ModuleArtSettingsConfig": {
      "defaultOptions": "",
      "getData": "",
      "activateListeners": "",
      "_onAction": "",
      "_updateObject": "",
      "static get defaultOptions": ""
    },
    "VariantRulesSettingsConfig": {
      "_preparePartContext": ""
    },
    "VisibilitySettingsConfig": {
      "_preparePartContext": ""
    },
    "CreatureTypeConfig": {
      "title": "",
      "actor": "",
      "_preparePartContext": "",
      "get title": "",
      "get actor": ""
    },
    "MovementSensesConfig": {
      "keyPath": "",
      "title": "",
      "types": "",
      "_initializeApplicationOptions": "",
      "_preparePartContext": "",
      "_prepareExtraFields": "",
      "get keyPath": "",
      "get title": "",
      "get types": ""
    },
    "SourceConfig": {
      "title": "",
      "_prepareContext": "",
      "get title": ""
    },
    "TokenPlacement": {
      "static place": "",
      "place": "",
      "createPreviews": "",
      "destroyPreviews": "",
      "requestPlacement": "",
      "finishPlacement": "",
      "onMovePlacement": "",
      "onRotatePlacement": "",
      "onConfirmPlacement": "",
      "onSkipPlacement": "",
      "static adjustAppendedNumber": ""
    },
    "ActorDataModel": {
      "embeddedDescriptionKeyPath": "",
      "transferDestinations": "",
      "prepareEmbeddedData": "",
      "_prepareScaleValues": "",
      "getRollData": "",
      "recoverCombatUses": "",
      "get embeddedDescriptionKeyPath": "",
      "get transferDestinations": ""
    },
    "ItemDataModel": {
      "attackModes": "",
      "availableAbilities": "",
      "embeddedDescriptionKeyPath": "",
      "scalingIncrease": "",
      "prepareBaseData": "",
      "richTooltip": "",
      "getCardData": "",
      "getCraftCost": "",
      "getFavoriteData": "",
      "getSheetData": "",
      "getRollData": "",
      "get attackModes": "",
      "get availableAbilities": "",
      "get embeddedDescriptionKeyPath": "",
      "get scalingIncrease": ""
    },
    "AttackActivityData": {
      "static defineSchema": "",
      "ability": "",
      "actionType": "",
      "activationLabels": "",
      "availableAbilities": "",
      "criticalThreshold": "",
      "validAttackTypes": "",
      "static transformTypeData": "",
      "prepareData": "",
      "prepareFinalData": "",
      "getActionLabel": "",
      "getAttackData": "",
      "getDamageConfig": "",
      "getRangeLabel": "",
      "_processDamagePart": "",
      "get ability": "",
      "get actionType": "",
      "get activationLabels": "",
      "get availableAbilities": "",
      "get criticalThreshold": "",
      "get validAttackTypes": ""
    },
    "CastActivityData": {
      "static defineSchema": "",
      "prepareFinalData": ""
    },
    "CheckActivityData": {
      "static defineSchema": "",
      "ability": "",
      "static transformTypeData": "",
      "prepareFinalData": "",
      "getAbility": "",
      "get ability": ""
    },
    "DamageActivityData": {
      "static defineSchema": "",
      "static transformTypeData": "",
      "prepareFinalData": "",
      "getDamageConfig": ""
    },
    "EnchantActivityData": {
      "static defineSchema": "",
      "actionType": "",
      "applicableEffects": "",
      "appliedEnchantments": "",
      "availableEnchantments": "",
      "enchantableTypes": "",
      "static transformEffectsData": "",
      "static transformTypeData": "",
      "get actionType": "",
      "get applicableEffects": "",
      "get appliedEnchantments": "",
      "get availableEnchantments": "",
      "static get enchantableTypes": ""
    },
    "AppliedEffectField": {
      "initialize": "",
      "defineProperty": ""
    },
    "ConsumptionTargetsField": {},
    "ConsumptionError": {},
    "ForwardActivityData": {
      "static defineSchema": ""
    },
    "HealActivityData": {
      "static defineSchema": "",
      "static transformTypeData": "",
      "prepareFinalData": "",
      "getDamageConfig": ""
    },
    "OrderActivityData": {
      "static defineSchema": "",
      "prepareData": ""
    },
    "SaveActivityData": {
      "static defineSchema": "",
      "ability": "",
      "static migrateData": "",
      "static transformTypeData": "",
      "prepareData": "",
      "prepareFinalData": "",
      "getDamageConfig": "",
      "get ability": ""
    },
    "SummonActivityData": {
      "static defineSchema": "",
      "ability": "",
      "actionType": "",
      "applicableEffects": "",
      "availableProfiles": "",
      "relevantLevel": "",
      "summonedCreatures": "",
      "static transformTypeData": "",
      "get ability": "",
      "get actionType": "",
      "get applicableEffects": "",
      "get availableProfiles": "",
      "get relevantLevel": "",
      "get summonedCreatures": ""
    },
    "UtilityActivityData": {
      "static defineSchema": "",
      "static transformTypeData": ""
    },
    "CharacterData": {
      "static defineSchema": "",
      "static _migrateData": "",
      "prepareBaseData": "",
      "prepareEmbeddedData": "",
      "prepareDerivedData": "",
      "cantripLevel": "",
      "hasFavorite": "",
      "addFavorite": "",
      "removeFavorite": ""
    },
    "DamageTraitField": {},
    "SimpleTraitField": {},
    "NPCData": {
      "static defineSchema": "",
      "compendiumBrowserFilters": "",
      "static _migrateData": "",
      "migrateEnvironment": "",
      "migrateSource": "",
      "migrateSpellLevel": "",
      "migrateTypeData": "",
      "prepareBaseData": "",
      "defineProperty": "",
      "set": "",
      "prepareEmbeddedData": "",
      "prepareDerivedData": "",
      "_preUpdate": "",
      "cantripLevel": "",
      "getLegendaryActionsDescription": "",
      "getGear": "",
      "recoverCombatUses": "",
      "resistSave": "",
      "toEmbed": "",
      "_prepareEmbedContext": "",
      "static get compendiumBrowserFilters": ""
    },
    "AttributesFields": {
      "armorClass": "",
      "common": "",
      "creature": "",
      "static _migrateInitiative": "",
      "static prepareBaseArmorClass": "",
      "static prepareBaseEncumbrance": "",
      "static prepareArmorClass": "",
      "catch": "",
      "static prepareConcentration": "",
      "static prepareEncumbrance": "",
      "static prepareExhaustionLevel": "",
      "static prepareHitPoints": "",
      "static prepareInitiative": "",
      "static prepareMovement": "",
      "static prepareRace": "",
      "static prepareSpellcastingAbility": "",
      "defineProperty": "",
      "static get armorClass": "",
      "static get common": "",
      "static get creature": ""
    },
    "CreatureTemplate": {
      "static defineSchema": "",
      "static _initialSkillValue": "",
      "_spellLevels": "",
      "static _migrateData": "",
      "migrateSensesData": "",
      "migrateToolData": "",
      "prepareSkills": "",
      "prepareSkill": "",
      "prepareTools": "",
      "getRollData": "",
      "static get _spellLevels": ""
    },
    "DetailsField": {
      "common": "",
      "creature": "",
      "static get common": "",
      "static get creature": ""
    },
    "TraitsField": {
      "common": "",
      "creature": "",
      "static makeSimpleTrait": "",
      "static makeDamageTrait": "",
      "static prepareLanguages": "",
      "static prepareResistImmune": "",
      "static get common": "",
      "static get creature": ""
    },
    "VehicleData": {
      "static defineSchema": "",
      "static _migrateData": "",
      "migrateSource": "",
      "prepareBaseData": "",
      "prepareDerivedData": ""
    },
    "AbilityScoreImprovementValueData": {
      "static defineSchema": ""
    },
    "BaseAdvancement": {
      "typeName": "",
      "static defineSchema": "",
      "static migrateData": "",
      "static get typeName": ""
    },
    "ScaleValueTypeNumber": {
      "static defineSchema": "",
      "metadata": "",
      "static convertFrom": "",
      "static get metadata": ""
    },
    "ScaleValueTypeCR": {
      "static defineSchema": "",
      "metadata": "",
      "display": "",
      "static get metadata": "",
      "get display": ""
    },
    "ScaleValueTypeDice": {
      "static defineSchema": "",
      "metadata": "",
      "static convertFrom": "",
      "formula": "",
      "die": "",
      "mods": "",
      "denom": "",
      "static migrateData": "",
      "static getFields": "",
      "static getPlaceholder": "",
      "static get metadata": "",
      "get formula": "",
      "get die": "",
      "get mods": "",
      "get denom": ""
    },
    "ScaleValueTypeDistance": {
      "metadata": "",
      "display": "",
      "static get metadata": "",
      "get display": ""
    },
    "ActivationsField": {
      "static getActivations": "",
      "static processActivations": ""
    },
    "ActorDeltasField": {
      "static getDeltas": "",
      "static processDeltas": ""
    },
    "IndividualDeltaField": {
      "static getDeltas": "",
      "static processDelta": ""
    },
    "RestMessageData": {
      "static defineSchema": "",
      "actor": "",
      "_prepareContext": "",
      "get actor": ""
    },
    "TurnMessageData": {
      "static defineSchema": "",
      "actor": "",
      "combat": "",
      "combatant": "",
      "_prepareContext": "",
      "get actor": "",
      "get combat": "",
      "get combatant": ""
    },
    "ActivitiesField": {
      "initialize": ""
    },
    "ActivityCollection": {
      "getByType": "",
      "getByTypes": "",
      "set": "",
      "delete": "",
      "every": "",
      "toObject": ""
    },
    "EnchantmentField": {},
    "EnchantmentError": {},
    "SpellcastingField": {
      "static prepareData": ""
    },
    "SummonsField": {},
    "ActionTemplate": {
      "static defineSchema": "",
      "static _migrateData": "",
      "migrateAbility": "",
      "migrateAttack": "",
      "migrateCritical": "",
      "migrateSave": "",
      "abilityMod": "",
      "_typeAbilityMod": "",
      "criticalThreshold": "",
      "_typeCriticalThreshold": "",
      "hasAbilityCheck": "",
      "hasAttack": "",
      "hasDamage": "",
      "hasSave": "",
      "hasSummoning": "",
      "isHealing": "",
      "isVersatile": "",
      "getRollData": "",
      "get abilityMod": "",
      "get _typeAbilityMod": "",
      "get criticalThreshold": "",
      "get _typeCriticalThreshold": "",
      "get hasAbilityCheck": "",
      "get hasAttack": "",
      "get hasDamage": "",
      "get hasSave": "",
      "get hasSummoning": "",
      "get isHealing": "",
      "get isVersatile": ""
    },
    "ActivatedEffectTemplate": {
      "static defineSchema": "",
      "getUsesData": "",
      "prepareFinalActivatedEffectData": "",
      "_prepareFinalFormula": "",
      "catch": "",
      "static _migrateData": "",
      "migrateFormulaFields": "",
      "migrateRanges": "",
      "migrateTargets": "",
      "migrateUses": "",
      "migrateConsume": "",
      "activatedEffectCardProperties": "",
      "hasAreaTarget": "",
      "hasIndividualTarget": "",
      "hasLimitedUses": "",
      "hasResource": "",
      "hasAmmo": "",
      "hasScalarDuration": "",
      "hasScalarRange": "",
      "hasScalarTarget": "",
      "hasTarget": "",
      "isActive": "",
      "get activatedEffectCardProperties": "",
      "get hasAreaTarget": "",
      "get hasIndividualTarget": "",
      "get hasLimitedUses": "",
      "get hasResource": "",
      "get hasAmmo": "",
      "get hasScalarDuration": "",
      "get hasScalarRange": "",
      "get hasScalarTarget": "",
      "get hasTarget": "",
      "get isActive": ""
    },
    "ItemUsesField": {
      "getUsesData": "",
      "prepareFinalActivatedEffectData": "",
      "_prepareFinalFormula": "",
      "catch": "",
      "static _migrateData": "",
      "migrateFormulaFields": "",
      "migrateRanges": "",
      "migrateTargets": "",
      "migrateUses": "",
      "migrateConsume": "",
      "activatedEffectCardProperties": "",
      "hasAreaTarget": "",
      "hasIndividualTarget": "",
      "hasLimitedUses": "",
      "hasResource": "",
      "hasAmmo": "",
      "hasScalarDuration": "",
      "hasScalarRange": "",
      "hasScalarTarget": "",
      "hasTarget": "",
      "isActive": "",
      "get activatedEffectCardProperties": "",
      "get hasAreaTarget": "",
      "get hasIndividualTarget": "",
      "get hasLimitedUses": "",
      "get hasResource": "",
      "get hasAmmo": "",
      "get hasScalarDuration": "",
      "get hasScalarRange": "",
      "get hasScalarTarget": "",
      "get hasTarget": "",
      "get isActive": ""
    },
    "ActivitiesTemplate": {
      "static defineSchema": "",
      "abilityMod": "",
      "_typeAbilityMod": "",
      "appliedEnchantments": "",
      "criticalThreshold": "",
      "hasAttack": "",
      "hasLimitedUses": "",
      "hasSave": "",
      "hasSummoning": "",
      "isActive": "",
      "isEnchantment": "",
      "isHealing": "",
      "summonedCreatures": "",
      "static migrateActivities": "",
      "migrateUses": "",
      "static initializeActivities": "",
      "shouldCreateInitialActivity": "",
      "createInitialActivity": "",
      "prepareFinalActivityData": "",
      "getUsesData": "",
      "recoverUses": "",
      "onCreateActivities": "",
      "preUpdateActivities": "",
      "onUpdateActivities": "",
      "onDeleteActivities": "",
      "static _applyActivityShims": "",
      "get abilityMod": "",
      "get _typeAbilityMod": "",
      "get appliedEnchantments": "",
      "get criticalThreshold": "",
      "get hasAttack": "",
      "get hasLimitedUses": "",
      "get hasSave": "",
      "get hasSummoning": "",
      "get isActive": "",
      "get isEnchantment": "",
      "get isHealing": "",
      "get summonedCreatures": ""
    },
    "EquippableItemTemplate": {
      "static defineSchema": "",
      "compendiumBrowserAttunementFilter": "",
      "static _migrateData": "",
      "migrateAttunement": "",
      "migrateEquipped": "",
      "prepareFinalEquippableData": "",
      "equippableItemCardProperties": "",
      "magicAvailable": "",
      "preCreateEquipped": "",
      "static get compendiumBrowserAttunementFilter": "",
      "get equippableItemCardProperties": "",
      "get magicAvailable": ""
    },
    "IdentifiableTemplate": {
      "static defineSchema": "",
      "static _migrateData": "",
      "migrateUnidentified": "",
      "prepareIdentifiable": "",
      "preUpdateIdentifiable": ""
    },
    "ItemDescriptionTemplate": {
      "static defineSchema": "",
      "static _migrateData": "",
      "migrateSource": "",
      "prepareDescriptionData": "",
      "validProperties": "",
      "static compendiumBrowserPropertiesFilter": "",
      "get validProperties": ""
    },
    "ItemTypeTemplate": {
      "itemCategories": "",
      "static _migrateData": "",
      "migrateType": "",
      "static get itemCategories": "",
      "get itemCategories": ""
    },
    "MountableTemplate": {
      "static defineSchema": ""
    },
    "PhysicalItemTemplate": {
      "static defineSchema": "",
      "compendiumBrowserPhysicalItemFilters": "",
      "priceLabel": "",
      "totalWeight": "",
      "physicalItemSheetFields": "",
      "preparePhysicalData": "Data model template with information on physical items.\n@property {string} container           Container within which this item is located.\n@property {number} quantity            Number of items in a stack.\n@property {object} weight\n@property {number} weight.value        Item's weight.\n@property {string} weight.units        Units used to measure the weight.\n@property {object} price\n@property {number} price.value         Item's cost in the specified denomination.\n@property {string} price.denomination  Currency denomination used to determine price.\n@property {string} rarity              Item rarity as defined in `DND5E.itemRarity`.\n@mixin\n/\nexport default class PhysicalItemTemplate extends SystemDataModel {\n  /** @inheritDoc */\n  static defineSchema() {\n    return {\n      container: new ForeignDocumentField(foundry.documents.BaseItem, {\n        idOnly: true, label: \"DND5E.Container\"\n      }),\n      quantity: new NumberField({\n        required: true, nullable: false, integer: true, initial: 1, min: 0, label: \"DND5E.Quantity\"\n      }),\n      weight: new SchemaField({\n        value: new NumberField({\n          required: true, nullable: false, initial: 0, min: 0, label: \"DND5E.Weight\"\n        }),\n        units: new StringField({\n          required: true, blank: false, label: \"DND5E.UNITS.WEIGHT.Label\", initial: () => defaultUnits(\"weight\")\n        })\n      }, {label: \"DND5E.Weight\"}),\n      price: new SchemaField({\n        value: new NumberField({\n          required: true, nullable: false, initial: 0, min: 0, label: \"DND5E.Price\"\n        }),\n        denomination: new StringField({\n          required: true, blank: false, initial: \"gp\", label: \"DND5E.Currency\"\n        })\n      }, {label: \"DND5E.Price\"}),\n      rarity: new StringField({required: true, blank: true, label: \"DND5E.Rarity\"})\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMaximum depth items can be nested in containers.\n@type {number}\n/\n  static MAX_DEPTH = 5;\n\n  /* -------------------------------------------- */\n\n  /**\nCreate filter configurations shared by all physical items.\n@returns {[string, CompendiumBrowserFilterDefinitionEntry][]}\n/\n  static get compendiumBrowserPhysicalItemFilters() {\n    return [\n      [\"price\", {\n        label: \"DND5E.Price\",\n        type: \"range\",\n        config: {\n          keyPath: \"system.price.value\"\n        }\n      }],\n      [\"rarity\", {\n        label: \"DND5E.Rarity\",\n        type: \"set\",\n        config: {\n          blank: game.i18n.localize(\"DND5E.ItemRarityMundane\").capitalize(),\n          choices: Object.entries(CONFIG.DND5E.itemRarity).reduce((obj, [key, label]) => {\n            obj[key] = { label: label.capitalize() };\n            return obj;\n          }, {}),\n          keyPath: \"system.rarity\"\n        }\n      }]\n    ];\n  }\n\n  /* -------------------------------------------- */\n  /*  Getters                                     */\n  /* -------------------------------------------- */\n\n  /**\nGet a human-readable label for the price and denomination.\n@type {string}\n/\n  get priceLabel() {\n    const { value, denomination } = this.price;\n    const hasPrice = value && (denomination in CONFIG.DND5E.currencies);\n    return hasPrice ? `${value} ${CONFIG.DND5E.currencies[denomination].label}` : null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe weight of all of the items in an item stack.\n@type {number}\n/\n  get totalWeight() {\n    return this.quantity * this.weight.value;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nField specifications for physical items.\n@type {object[]}\n/\n  get physicalItemSheetFields() {\n    return [{\n      label: CONFIG.DND5E.itemRarity[this.rarity],\n      value: this._source.rarity,\n      requiresIdentification: true,\n      field: this.schema.getField(\"rarity\"),\n      choices: CONFIG.DND5E.itemRarity,\n      blank: \"DND5E.Rarity\",\n      classes: \"item-rarity\"\n    }];\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* --------------------------------------------",
      "static _migrateData": "",
      "migratePrice": "",
      "migrateRarity": "",
      "migrateWeight": "",
      "_renderContainers": "",
      "_preUpdate": "",
      "_onCreate": "",
      "_onUpdate": "",
      "_onDelete": "",
      "allContainers": "",
      "totalWeightIn": "",
      "static get compendiumBrowserPhysicalItemFilters": "",
      "get priceLabel": "",
      "get totalWeight": "",
      "get physicalItemSheetFields": ""
    },
    "StartingEquipmentTemplate": {
      "static defineSchema": "",
      "startingEquipmentDescription": "",
      "get startingEquipmentDescription": ""
    },
    "ActivationField": {
      "static prepareData": ""
    },
    "CurrencyTemplate": {
      "static defineSchema": "",
      "currencyWeight": "",
      "get currencyWeight": ""
    },
    "DamageField": {},
    "DurationField": {
      "static prepareData": "",
      "static getEffectDuration": ""
    },
    "RangeField": {
      "static prepareData": ""
    },
    "SourceField": {
      "static prepareData": "",
      "static getModuleBook": "",
      "static getPackage": "",
      "static shimActor": "",
      "defineProperty": ""
    },
    "TargetField": {
      "static prepareData": "",
      "static templateDimensions": ""
    },
    "UsesField": {
      "static prepareData": "",
      "rechargeOptions": "",
      "static getStatblockLabel": "",
      "recoverUses": "",
      "catch": "",
      "rollRecharge": "",
      "static get rechargeOptions": ""
    },
    "BasicRoll": {
      "static fromConfig": "",
      "static constructParts": "",
      "build": "",
      "buildConfigure": "",
      "buildEvaluate": "",
      "buildPost": "",
      "static applyKeybindings": "",
      "isFailure": "",
      "isSuccess": "",
      "toMessage": "",
      "static _prepareMessageData": "",
      "evaluate": "Configuration data for the process of creating one or more basic rolls.\n@typedef {object} BasicRollProcessConfiguration\n@property {BasicRollConfiguration[]} rolls  Configuration data for individual rolls.\n@property {boolean} [evaluate=true]         Should the rolls be evaluated? If set to `false`, then no chat message\n                                            will be created regardless of message configuration.\n@property {Event} [event]                   Event that triggered the rolls.\n@property {string[]} [hookNames]            Name suffixes for configuration hooks called.\n@property {Document} [subject]              Document that initiated this roll.\n@property {number} [target]                 Default target value for all rolls.\n/\n\n/**\nConfiguration data for an individual roll.\n@typedef {object} BasicRollConfiguration\n@property {string[]} [parts=[]]         Parts used to construct the roll formula.\n@property {object} [data={}]            Data used to resolve placeholders in the formula.\n@property {boolean} [situational=true]  Whether the situational bonus can be added to this roll in the prompt.\n@property {BasicRollOptions} [options]  Additional options passed through to the created roll.\n/\n\n/**\nOptions allowed on a basic roll.\n@typedef {object} BasicRollOptions\n@property {number} [target]  The total roll result that must be met for the roll to be considered a success.\n/\n\n/* -------------------------------------------- */\n\n/**\nConfiguration data for the roll prompt.\n@typedef {object} BasicRollDialogConfiguration\n@property {boolean} [configure=true]  Display a configuration dialog for the rolling process.\n@property {typeof RollConfigurationDialog} [applicationClass]  Alternate configuration application to use.\n@property {BasicRollConfigurationDialogOptions} [options]      Additional options passed to the dialog.\n/\n\n/* -------------------------------------------- */\n\n/**\nConfiguration data for creating a roll message.\n@typedef {object} BasicRollMessageConfiguration\n@property {boolean} [create=true]     Create a message when the rolling is complete.\n@property {ChatMessage5e} [document]  Final created chat message document once process is completed.\n@property {string} [rollMode]         The roll mode to apply to this message from `CONFIG.Dice.rollModes`.\n@property {object} [data={}]          Additional data used when creating the message.\n/\n\n/* -------------------------------------------- */\n\n/**\nCustom base roll type with methods for building rolls, presenting prompts, and creating messages.\n/\nexport default class BasicRoll extends Roll {\n\n  /**\nDefault application used for the roll configuration prompt.\n@type {typeof RollConfigurationDialog}\n/\n  static DefaultConfigurationDialog = RollConfigurationDialog;\n\n  /* -------------------------------------------- */\n  /*  Static Construction                         */\n  /* -------------------------------------------- */\n\n  /**\nCreate a roll instance from a roll config.\n@param {BasicRollConfiguration} config          Configuration info for the roll.\n@param {BasicRollProcessConfiguration} process  Configuration info for the whole rolling process.\n@returns {BasicRoll}\n/\n  static fromConfig(config, process) {\n    const formula = (config.parts ?? []).join(\" + \");\n    config.options ??= {};\n    config.options.target ??= process.target;\n    return new this(formula, config.data, config.options);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct roll parts and populate its data object.\n@param {object} parts   Information on the parts to be constructed.\n@param {object} [data]  Roll data to use and populate while constructing the parts.\n@returns {{ parts: string[], data: object }}\n/\n  static constructParts(parts, data={}) {\n    const finalParts = [];\n    for ( const [key, value] of Object.entries(parts) ) {\n      if ( !value && (value !== 0) ) continue;\n      finalParts.push(`@${key}`);\n      foundry.utils.setProperty(\n        data, key, foundry.utils.getType(value) === \"string\" ? Roll.replaceFormulaData(value, data) : value\n      );\n    }\n    return { parts: finalParts, data };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct and perform a roll through the standard workflow.\n@param {BasicRollProcessConfiguration} [config={}]   Configuration for the rolls.\n@param {BasicRollDialogConfiguration} [dialog={}]    Configuration for roll prompt.\n@param {BasicRollMessageConfiguration} [message={}]  Configuration for message creation.\n@returns {BasicRoll[]}\n/\n  static async build(config={}, dialog={}, message={}) {\n    const rolls = await this.buildConfigure(config, dialog, message);\n    await this.buildEvaluate(rolls, config, message);\n    await this.buildPost(rolls, config, message);\n    return rolls;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStage one of the standard rolling workflow, configuring the roll.\n@param {BasicRollProcessConfiguration} [config={}]   Configuration for the rolls.\n@param {BasicRollDialogConfiguration} [dialog={}]    Configuration for roll prompt.\n@param {BasicRollMessageConfiguration} [message={}]  Configuration for message creation.\n@returns {Promise<BasicRoll[]>}\n/\n  static async buildConfigure(config={}, dialog={}, message={}) {\n    config.hookNames = [...(config.hookNames ?? []), \"\"];\n\n    /**\nA hook event that fires before a roll is performed. Multiple hooks may be called depending on the rolling\nmethod (e.g. `dnd5e.preRollSkillV2`, `dnd5e.preRollAbilityCheckV2`, `dnd5e.preRollV2`). Exact contents of the\nconfiguration object will also change based on the roll type, but the same objects will always be present.\n@function dnd5e.preRollV2\n@memberof hookEvents\n@param {BasicRollProcessConfiguration} config   Configuration data for the pending roll.\n@param {BasicRollDialogConfiguration} dialog    Presentation data for the roll configuration dialog.\n@param {BasicRollMessageConfiguration} message  Configuration data for the roll's message.\n@returns {boolean}                              Explicitly return `false` to prevent the roll.\n/\n    for ( const hookName of config.hookNames ) {\n      if ( Hooks.call(`dnd5e.preRoll${hookName.capitalize()}V2`, config, dialog, message) === false ) return [];\n    }\n\n    this.applyKeybindings(config, dialog, message);\n\n    let rolls;\n    if ( dialog.configure === false ) {\n      rolls = config.rolls?.map((r, index) => {\n        dialog.options?.buildConfig?.(config, r, null, index);\n        return this.fromConfig(r, config);\n      }) ?? [];\n    } else {\n      const DialogClass = dialog.applicationClass ?? this.DefaultConfigurationDialog;\n      rolls = await DialogClass.configure(config, dialog, message);\n    }\n\n    // Store the roll type in roll.options so it can be accessed from only the roll\n    const rollType = foundry.utils.getProperty(message, \"data.flags.dnd5e.roll.type\");\n    if ( rollType ) rolls.forEach(roll => roll.options.rollType ??= rollType);\n\n    /**\nA hook event that fires after roll configuration is complete, but before the roll is evaluated.\nMultiple hooks may be called depending on the rolling method (e.g. `dnd5e.postSkillCheckRollConfiguration`,\n`dnd5e.postAbilityTestRollConfiguration`, and `dnd5e.postRollConfiguration` for skill checks). Exact contents of\nthe configuration object will also change based on the roll type, but the same objects will always be present.\n@function dnd5e.postRollConfiguration\n@memberof hookEvents\n@param {BasicRoll[]} rolls                      Rolls that have been constructed but not evaluated.\n@param {BasicRollProcessConfiguration} config   Configuration information for the roll.\n@param {BasicRollDialogConfiguration} dialog    Configuration for the roll dialog.\n@param {BasicRollMessageConfiguration} message  Configuration for the roll message.\n@returns {boolean}                              Explicitly return `false` to prevent rolls.\n/\n    for ( const hookName of config.hookNames ) {\n      const name = `dnd5e.post${hookName.capitalize()}RollConfiguration`;\n      if ( Hooks.call(name, rolls, config, dialog, message) === false ) return [];\n    }\n\n    return rolls;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStage two of the standard rolling workflow, evaluating the rolls.\n@param {BasicRoll[]} rolls                           Rolls to evaluate.\n@param {BasicRollProcessConfiguration} [config={}]   Configuration for the rolls.\n@param {BasicRollMessageConfiguration} [message={}]  Configuration for message creation.\n/\n  static async buildEvaluate(rolls, config={}, message={}) {\n    if ( config.evaluate !== false ) {\n      for ( const roll of rolls ) await roll.evaluate();\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStage three of the standard rolling workflow, posting a message to chat.\n@param {BasicRoll[]} rolls                      Rolls to evaluate.\n@param {BasicRollProcessConfiguration} config   Configuration for the rolls.\n@param {BasicRollMessageConfiguration} message  Configuration for message creation.\n@returns {ChatMessage5e|void}\n/\n  static async buildPost(rolls, config, message) {\n    message.data = foundry.utils.expandObject(message.data ?? {});\n    const messageId = config.event?.target.closest(\"[data-message-id]\")?.dataset.messageId;\n    if ( messageId ) foundry.utils.setProperty(message.data, \"flags.dnd5e.originatingMessage\", messageId);\n\n    if ( rolls?.length && (config.evaluate !== false) && (message.create !== false) ) {\n      message.document = await this.toMessage(rolls, message.data, { rollMode: message.rollMode });\n    }\n\n    return message.document;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDetermines whether the roll process should be fast forwarded.\n@param {BasicRollProcessConfiguration} config   Roll configuration data.\n@param {BasicRollDialogConfiguration} dialog    Data for the roll configuration dialog.\n@param {BasicRollMessageConfiguration} message  Message configuration data.\n/\n  static applyKeybindings(config, dialog, message) {\n    dialog.configure ??= true;\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nIs the result of this roll a failure? Returns `undefined` if roll isn't evaluated.\n@type {boolean|void}\n/\n  get isFailure() {\n    if ( !this._evaluated ) return;\n    if ( !Number.isNumeric(this.options.target) ) return false;\n    return this.total < this.options.target;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs the result of this roll a success? Returns `undefined` if roll isn't evaluated.\n@type {boolean|void}\n/\n  get isSuccess() {\n    if ( !this._evaluated ) return;\n    if ( !Number.isNumeric(this.options.target) ) return false;\n    return this.total >= this.options.target;\n  }\n\n  /* -------------------------------------------- */\n  /*  Chat Messages                               */\n  /* -------------------------------------------- */\n\n  /**\nTransform a Roll instance into a ChatMessage, displaying the roll result.\nThis function can either create the ChatMessage directly, or return the data object that will be used to create it.\n@param {BasicRoll[]} rolls              Rolls to add to the message.\n@param {object} messageData             The data object to use when creating the message.\n@param {options} [options]              Additional options which modify the created message.\n@param {string} [options.rollMode]      The template roll mode to use for the message from CONFIG.Dice.rollModes\n@param {boolean} [options.create=true]  Whether to automatically create the chat message, or only return the\n                                        prepared chatData object.\n@returns {Promise<ChatMessage|object>}  A promise which resolves to the created ChatMessage document if create is\n                                        true, or the Object of prepared chatData otherwise.\n/\n  static async toMessage(rolls, messageData={}, { rollMode, create=true }={}) {\n    for ( const roll of rolls ) {\n      if ( !roll._evaluated ) await roll.evaluate({ allowInteractive: rollMode !== CONST.DICE_ROLL_MODES.BLIND });\n      rollMode ??= roll.options.rollMode;\n    }\n\n    // Prepare chat data\n    messageData = foundry.utils.mergeObject({ sound: CONFIG.sounds.dice }, messageData);\n    messageData.rolls = rolls;\n    this._prepareMessageData(rolls, messageData);\n\n    // Process the chat data\n    const cls = getDocumentClass(\"ChatMessage\");\n    const msg = new cls(messageData);\n\n    // Either create or return the data\n    if ( create ) return cls.create(msg.toObject(), { rollMode });\n    else {\n      if ( rollMode ) msg.applyRollMode(rollMode);\n      return msg.toObject();\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPerform specific changes to message data before creating message.\n@param {BasicRoll[]} rolls   Rolls to add to the message.\n@param {object} messageData  The data object to use when creating the message.\n@protected\n/\n  static _prepareMessageData(rolls, messageData) {}\n\n  /* -------------------------------------------- */\n  /*  Evaluate Methods                            */\n  /* --------------------------------------------",
      "evaluateSync": "",
      "static replaceFormulaData": "",
      "preCalculateDiceTerms": "",
      "static preCalculateTerm": "",
      "simplify": "",
      "static mergeConfigs": "",
      "get isFailure": "",
      "get isSuccess": ""
    },
    "D20Die": {
      "isCriticalSuccess": "",
      "isCriticalFailure": "",
      "isValid": "",
      "applyAdvantage": "",
      "applyFlag": "",
      "applyRange": "",
      "get isCriticalSuccess": "",
      "get isCriticalFailure": "",
      "get isValid": ""
    },
    "D20Roll": {
      "static fromConfig": "",
      "static fromRoll": "",
      "static applyKeybindings": "",
      "d20": "",
      "hasAdvantage": "",
      "hasDisadvantage": "",
      "isCritical": "",
      "isFumble": "",
      "validD20Roll": "",
      "static _prepareMessageData": "",
      "configureModifiers": "",
      "createD20Die": "",
      "configureDialog": "",
      "get d20": "",
      "set d20": "",
      "get hasAdvantage": "",
      "get hasDisadvantage": "",
      "get isCritical": "",
      "get isFumble": "",
      "get validD20Roll": ""
    },
    "DamageRoll": {
      "static fromConfig": "",
      "build": "Configuration data for the process of rolling a damage roll.\n@typedef {BasicRollProcessConfiguration} DamageRollProcessConfiguration\n@property {DamageRollConfiguration[]} rolls         Configuration data for individual rolls.\n@property {CriticalDamageConfiguration} [critical]  Critical configuration for all rolls.\n@property {boolean} [isCritical]                    Treat each roll as a critical unless otherwise specified.\n@property {number} [scaling=0]                      Scale increase above base damage.\n/\n\n/**\nDamage roll configuration data.\n@typedef {BasicRollConfiguration} DamageRollConfiguration\n@property {DamageRollOptions} [options] - Options passed through to the roll.\n/\n\n/**\nOptions that describe a damage roll.\n@typedef {BasicRollOptions} DamageRollOptions\n@property {boolean} [isCritical]                    Should critical damage be calculated for this roll?\n@property {CriticalDamageConfiguration} [critical]  Critical configuration for this roll.\n@property {string[]} [properties]                   Physical properties of the source (e.g. magical, silvered).\n@property {string} [type]                           Type of damage represented.\n@property {string[]} [types]                        List of damage types selectable in the configuration app. If no\n                                                    type is provided, then the first of these types will be used.\n/\n\n/**\nCritical effects configuration data.\n@typedef {object} CriticalDamageConfiguration\n@property {boolean} [allow=true]       Should critical damage be allowed?\n@property {number} [multiplier=2]      Amount by which to multiply critical damage.\n@property {number} [bonusDice=0]       Additional dice added to first term when calculating critical damage.\n@property {string} [bonusDamage]       Additional, unmodified, damage formula added when calculating a critical.\n@property {boolean} [multiplyDice]     Should dice result be multiplied rather than number of dice rolled increased?\n@property {boolean} [multiplyNumeric]  Should numeric terms be multiplied along side dice during criticals?\n@property {string} [powerfulCritical]  Maximize result of extra dice added by critical, rather than rolling.\n/\n\n/* -------------------------------------------- */\n\n/**\nA type of Roll specific to a damage (or healing) roll in the 5e system.\n@param {string} formula                  The string formula to parse.\n@param {object} data                     The data object against which to parse attributes within the formula.\n@param {DamageRollOptions} [options={}]  Extra optional arguments which describe or modify the DamageRoll.\n/\nexport default class DamageRoll extends BasicRoll {\n  constructor(formula, data, options) {\n    super(formula, data, options);\n    if ( !this.options.preprocessed ) this.preprocessFormula();\n    if ( !this.options.configured ) this.configureDamage();\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static DefaultConfigurationDialog = DamageRollConfigurationDialog;\n\n  /* -------------------------------------------- */\n  /*  Static Construction                         */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static fromConfig(config, process) {\n    if ( process.critical ) {\n      config = foundry.utils.deepClone(config);\n      config.options ??= {};\n      config.options.critical = foundry.utils.mergeObject(\n        process.critical, config.options.critical ?? {}, { inplace: false }\n      );\n    }\n    return super.fromConfig(config, process);\n  }\n\n  /* --------------------------------------------",
      "static applyKeybindings": "",
      "isCritical": "",
      "preprocessFormula": "",
      "configureDamage": "",
      "configureDialog": "",
      "get isCritical": ""
    },
    "ActiveEffect5e": {
      "isAppliedEnchantment": "",
      "isConcealed": "",
      "isTemporary": "",
      "getSource": "",
      "_fromStatusEffect": "",
      "_initializeSource": "",
      "apply": "",
      "applyActivity": "",
      "static applyField": "",
      "_applyAdd": "",
      "_applyLegacy": "",
      "_applyUpgrade": "",
      "_prepareFlagChange": "",
      "determineSuppression": "",
      "prepareDerivedData": "",
      "_prepareExhaustionLevel": "",
      "getFavoriteData": "",
      "createRiderConditions": "",
      "createRiderEnchantments": "",
      "toDragData": "",
      "_preCreate": "",
      "_onCreate": "",
      "_onUpdate": "",
      "_preDelete": "",
      "_onDelete": "",
      "_displayScrollingStatus": "",
      "static createConcentrationEffectData": "",
      "static registerHUDListeners": "",
      "static onRenderActiveEffectConfig": "",
      "static onTokenHUDRender": "",
      "static _getExhaustionImage": "",
      "static getEffectDurationFromItem": "",
      "static onClickTokenHUD": "",
      "static _manageExhaustion": "",
      "static _manageConcentration": "",
      "addDependent": "",
      "getDependents": "",
      "static addOverriddenChoices": "",
      "richTooltip": "",
      "deleteDialog": "",
      "get isAppliedEnchantment": "",
      "get isConcealed": "",
      "get isTemporary": ""
    },
    "SourcedItemsMap": {
      "get": "",
      "set": "",
      "_redirectKeys": ""
    },
    "Bastion": {
      "advanceAllBastions": "",
      "advanceAllFacilities": "",
      "advanceTurn": "",
      "resolveAttack": "",
      "_activateChatListeners": "",
      "evaluateOrder": "",
      "evaluateBuildOrder": "",
      "evaluateCraftOrder": "",
      "evaluateEnlargeOrder": "",
      "evaluateHarvestOrder": "",
      "evaluateRepairOrder": "",
      "evaluateTradeOrder": "",
      "getDefenders": "",
      "onChatAction": "",
      "onClaimGold": "",
      "onDragItem": "",
      "onResolveAttack": "",
      "onViewItem": "",
      "renderAttackSummary": "",
      "renderTurnSummary": "",
      "confirmAdvance": "",
      "initializeUI": "",
      "promptAttack": ""
    },
    "BastionAttackDialog": {
      "formula": "",
      "subtitle": "",
      "_prepareContentContext": "",
      "handleFormSubmission": "",
      "_onClose": "",
      "static prompt": "",
      "get formula": "",
      "get subtitle": ""
    },
    "HitDice": {
      "value": "",
      "max": "",
      "smallest": "",
      "smallestAvailable": "",
      "smallestFace": "",
      "largest": "",
      "largestAvailable": "",
      "largestFace": "",
      "pct": "",
      "bySize": "",
      "toString": "",
      "createHitDiceUpdates": "",
      "get value": "",
      "get max": "",
      "get smallest": "",
      "get smallestAvailable": "",
      "get smallestFace": "",
      "get largest": "",
      "get largestAvailable": "",
      "get largestFace": "",
      "get pct": "",
      "get bySize": ""
    },
    "Proficiency": {
      "flat": "",
      "dice": "",
      "term": "",
      "hasProficiency": "",
      "static calculateMod": "",
      "clone": "",
      "toString": "",
      "get flat": "",
      "get dice": "",
      "get term": "",
      "get hasProficiency": ""
    },
    "SelectChoices": {
      "asSet": "",
      "clone": "",
      "find": "",
      "forEach": "",
      "merge": "",
      "_sort": "",
      "sort": "",
      "filter": "",
      "exclude": ""
    },
    "AbilityScoreImprovementAdvancement": {
      "metadata": "",
      "_preCreate": "",
      "allowFeat": "",
      "points": "",
      "canImprove": "",
      "titleForLevel": "",
      "summaryForLevel": "",
      "apply": "",
      "restore": "",
      "reverse": "",
      "static get metadata": "",
      "get allowFeat": "",
      "get points": ""
    },
    "AdvancementError": {},
    "HitPointsAdvancement": {
      "metadata": "",
      "average": "",
      "levels": "",
      "hitDie": "",
      "hitDieValue": "",
      "configuredForLevel": "",
      "titleForLevel": "",
      "valueForLevel": "",
      "static valueForLevel": "",
      "total": "",
      "getAdjustedTotal": "",
      "static availableForItem": "",
      "getApplicableValue": "",
      "apply": "",
      "automaticApplicationValue": "",
      "restore": "",
      "reverse": "",
      "static get metadata": "",
      "get average": "",
      "get levels": "",
      "get hitDie": "",
      "get hitDieValue": ""
    },
    "ItemChoiceAdvancement": {
      "metadata": "",
      "levels": "",
      "configuredForLevel": "",
      "titleForLevel": "",
      "summaryForLevel": "",
      "storagePath": "",
      "apply": "",
      "automaticApplicationValue": "",
      "restore": "",
      "reverse": "",
      "_validateItemType": "",
      "static get metadata": "",
      "get levels": ""
    },
    "ItemGrantAdvancement": {
      "metadata": "",
      "configuredForLevel": "",
      "summaryForLevel": "",
      "storagePath": "",
      "apply": "",
      "automaticApplicationValue": "",
      "restore": "",
      "reverse": "",
      "_validateItemType": "",
      "static get metadata": ""
    },
    "ScaleValueAdvancement": {
      "metadata": "",
      "static localize": "",
      "levels": "",
      "identifier": "",
      "titleForLevel": "",
      "valueForLevel": "",
      "testEquality": "",
      "automaticApplicationValue": "",
      "getContextMenuOptions": "",
      "static get metadata": "",
      "get levels": "",
      "get identifier": ""
    },
    "SizeAdvancement": {
      "metadata": "",
      "automaticHint": "",
      "levels": "",
      "summaryForLevel": "",
      "static availableForItem": "",
      "apply": "",
      "automaticApplicationValue": "",
      "restore": "",
      "reverse": "",
      "static get metadata": "",
      "get automaticHint": "",
      "get levels": ""
    },
    "SubclassAdvancement": {
      "metadata": "",
      "configuredForLevel": "",
      "summaryforLevel": "",
      "static availableForItem": "",
      "apply": "",
      "restore": "",
      "reverse": "",
      "static get metadata": ""
    },
    "TraitAdvancement": {
      "metadata": "",
      "static localize": "",
      "maxTraits": "",
      "prepareData": "",
      "configuredForLevel": "",
      "sortingValueForLevel": "",
      "summaryForLevel": "",
      "apply": "",
      "automaticApplicationValue": "",
      "restore": "",
      "reverse": "",
      "actorSelected": "",
      "representedTraits": "",
      "availableChoices": "",
      "unfulfilledChoices": "",
      "static get metadata": "",
      "get maxTraits": ""
    },
    "ChatMessage5e": {
      "canApplyDamage": "",
      "canSelectTargets": "",
      "isRoll": "",
      "shouldDisplayChallenge": "",
      "static migrateData": "",
      "prepareData": "",
      "getHTML": "",
      "_collapseTrays": "",
      "_displayChatActionButtons": "",
      "_highlightCriticalSuccessFailure": "",
      "makeIcon": "",
      "_enrichChatCard": "",
      "_enrichRollTooltip": "",
      "_enrichAttackTargets": "",
      "_enrichDamageTooltip": "",
      "_simplifyDamageRoll": "",
      "_enrichEnchantmentTooltip": "",
      "_enrichSaveTooltip": "",
      "_enrichUsageEffects": "",
      "static addChatMessageContextOptions": "",
      "_activateActivityListeners": "",
      "_onTargetMouseDown": "",
      "_onTargetHoverIn": "",
      "_onTargetHoverOut": "",
      "applyChatCardDamage": "",
      "selectTargets": "",
      "applyChatCardTemp": "",
      "_onClickDiceRoll": "",
      "static onRenderChatPopout": "",
      "static onRenderChatLog": "",
      "static activateListeners": "",
      "static toggleModifiers": "",
      "_onDelete": "",
      "getAssociatedActivity": "",
      "getAssociatedActor": "",
      "getAssociatedItem": "",
      "getAssociatedRolls": "",
      "getOriginatingMessage": "",
      "_shimFlags": "",
      "defineProperty": "",
      "get canApplyDamage": "",
      "get canSelectTargets": "",
      "get isRoll": "",
      "get shouldDisplayChallenge": ""
    },
    "Combat5e": {
      "startCombat": "Extended version of Combat to trigger events on combat start & turn changes.\n/\nexport default class Combat5e extends Combat {\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nExpansion state for groups within this combat.\n@type {Set<string>}\n/\n  expandedGroups = new Set();\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* --------------------------------------------",
      "endCombat": "Extended version of Combat to trigger events on combat start & turn changes.\n/\nexport default class Combat5e extends Combat {\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nExpansion state for groups within this combat.\n@type {Set<string>}\n/\n  expandedGroups = new Set();\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async startCombat() {\n    await super.startCombat();\n    this._recoverUses({ encounter: true });\n    return this;\n  }\n\n  /* --------------------------------------------",
      "rollAll": "",
      "rollNPC": "",
      "rollInitiative": "Extended version of Combat to trigger events on combat start & turn changes.\n/\nexport default class Combat5e extends Combat {\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nExpansion state for groups within this combat.\n@type {Set<string>}\n/\n  expandedGroups = new Set();\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async startCombat() {\n    await super.startCombat();\n    this._recoverUses({ encounter: true });\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async endCombat() {\n    await super.endCombat();\n    this._recoverUses({ turn: true, turnEnd: true, turnStart: true });\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  async rollAll(options) {\n    const ids = new Set();\n    for ( let combatant of this.combatants ) {\n      if ( combatant.group ) combatant = combatant.group.activeCombatant;\n      if ( combatant.isOwner && (combatant.initiative === null) ) ids.add(combatant.id);\n    }\n    return this.rollInitiative(Array.from(ids), options);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  async rollNPC(options={}) {\n    const ids = new Set();\n    for ( let combatant of this.combatants ) {\n      if ( combatant.group ) combatant = combatant.group.activeCombatant;\n      if ( combatant.isOwner && combatant.isNPC && (combatant.initiative === null) ) ids.add(combatant.id);\n    }\n    return this.rollInitiative(Array.from(ids), options);\n  }\n\n  /* --------------------------------------------",
      "_sortCombatants": "",
      "_onUpdate": "",
      "_onDelete": "",
      "_onEndTurn": "Extended version of Combat to trigger events on combat start & turn changes.\n/\nexport default class Combat5e extends Combat {\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nExpansion state for groups within this combat.\n@type {Set<string>}\n/\n  expandedGroups = new Set();\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async startCombat() {\n    await super.startCombat();\n    this._recoverUses({ encounter: true });\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async endCombat() {\n    await super.endCombat();\n    this._recoverUses({ turn: true, turnEnd: true, turnStart: true });\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  async rollAll(options) {\n    const ids = new Set();\n    for ( let combatant of this.combatants ) {\n      if ( combatant.group ) combatant = combatant.group.activeCombatant;\n      if ( combatant.isOwner && (combatant.initiative === null) ) ids.add(combatant.id);\n    }\n    return this.rollInitiative(Array.from(ids), options);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  async rollNPC(options={}) {\n    const ids = new Set();\n    for ( let combatant of this.combatants ) {\n      if ( combatant.group ) combatant = combatant.group.activeCombatant;\n      if ( combatant.isOwner && combatant.isNPC && (combatant.initiative === null) ) ids.add(combatant.id);\n    }\n    return this.rollInitiative(Array.from(ids), options);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async rollInitiative(ids, options={}) {\n    await super.rollInitiative(ids, options);\n    for ( const id of ids ) await this._recoverUses({ initiative: this.combatants.get(id) });\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  _sortCombatants(a, b) {\n    // Initiative takes top priority\n    if ( a.initiative !== b.initiative ) return super._sortCombatants(a, b);\n\n    // Separate out combatants with different base actors\n    if ( !a.token?.baseActor || !b.token?.baseActor || (a.token?.baseActor !== b.token?.baseActor) ) {\n      const name = c => `${c.token?.baseActor?.name ?? \"\"}.${c.token?.baseActor?.id ?? \"\"}`;\n      return name(a).localeCompare(name(b), game.i18n.lang);\n    }\n\n    // Otherwise sort based on combatant name\n    return a.name.localeCompare(b.name, game.i18n.lang);\n  }\n\n  /* -------------------------------------------- */\n  /*  Socket Event Handlers                       */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _onUpdate(changed, options, userId) {\n    super._onUpdate(changed, options, userId);\n    if ( this.current.combatantId !== this.previous.combatantId ) {\n      this.combatants.get(this.previous.combatantId)?.refreshDynamicRing();\n      this.combatants.get(this.current.combatantId)?.refreshDynamicRing();\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _onDelete(options, userId) {\n    super._onDelete(options, userId);\n    this.combatants.get(this.current.combatantId)?.refreshDynamicRing();\n  }\n\n  /* --------------------------------------------",
      "_onStartTurn": "Extended version of Combat to trigger events on combat start & turn changes.\n/\nexport default class Combat5e extends Combat {\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nExpansion state for groups within this combat.\n@type {Set<string>}\n/\n  expandedGroups = new Set();\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async startCombat() {\n    await super.startCombat();\n    this._recoverUses({ encounter: true });\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async endCombat() {\n    await super.endCombat();\n    this._recoverUses({ turn: true, turnEnd: true, turnStart: true });\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  async rollAll(options) {\n    const ids = new Set();\n    for ( let combatant of this.combatants ) {\n      if ( combatant.group ) combatant = combatant.group.activeCombatant;\n      if ( combatant.isOwner && (combatant.initiative === null) ) ids.add(combatant.id);\n    }\n    return this.rollInitiative(Array.from(ids), options);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  async rollNPC(options={}) {\n    const ids = new Set();\n    for ( let combatant of this.combatants ) {\n      if ( combatant.group ) combatant = combatant.group.activeCombatant;\n      if ( combatant.isOwner && combatant.isNPC && (combatant.initiative === null) ) ids.add(combatant.id);\n    }\n    return this.rollInitiative(Array.from(ids), options);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async rollInitiative(ids, options={}) {\n    await super.rollInitiative(ids, options);\n    for ( const id of ids ) await this._recoverUses({ initiative: this.combatants.get(id) });\n    return this;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  _sortCombatants(a, b) {\n    // Initiative takes top priority\n    if ( a.initiative !== b.initiative ) return super._sortCombatants(a, b);\n\n    // Separate out combatants with different base actors\n    if ( !a.token?.baseActor || !b.token?.baseActor || (a.token?.baseActor !== b.token?.baseActor) ) {\n      const name = c => `${c.token?.baseActor?.name ?? \"\"}.${c.token?.baseActor?.id ?? \"\"}`;\n      return name(a).localeCompare(name(b), game.i18n.lang);\n    }\n\n    // Otherwise sort based on combatant name\n    return a.name.localeCompare(b.name, game.i18n.lang);\n  }\n\n  /* -------------------------------------------- */\n  /*  Socket Event Handlers                       */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _onUpdate(changed, options, userId) {\n    super._onUpdate(changed, options, userId);\n    if ( this.current.combatantId !== this.previous.combatantId ) {\n      this.combatants.get(this.previous.combatantId)?.refreshDynamicRing();\n      this.combatants.get(this.current.combatantId)?.refreshDynamicRing();\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _onDelete(options, userId) {\n    super._onDelete(options, userId);\n    this.combatants.get(this.current.combatantId)?.refreshDynamicRing();\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _onEndTurn(combatant) {\n    await super._onEndTurn(combatant);\n    this._recoverUses({ turnEnd: combatant });\n  }\n\n  /* --------------------------------------------",
      "createGroups": "",
      "_recoverUses": ""
    },
    "Combatant5e": {
      "createTurnMessage": "",
      "getGroupingKey": "",
      "getInitiativeRoll": "",
      "recoverCombatUses": "",
      "refreshDynamicRing": "",
      "_onDelete": "",
      "_onUpdateOperation": "@import { ActorDeltasData } from \"../data/chat-message/fields/deltas-field.mjs\";\n/\n\n/**\n@typedef CombatRecoveryResults\n@property {object} actor       Updates to be applied to the actor.\n@property {object[]} item      Updates to be applied to the actor's items.\n@property {BasicRoll[]} rolls  Any recovery rolls performed.\n/\n\n/**\nCustom combatant with custom initiative roll handling.\n/\nexport default class Combatant5e extends Combatant {\n  /**\nCreate a chat message representing actor changes and displaying possible actions for this turn.\n@param {object} [data={}]\n@param {ActorDeltasData} [data.deltas]\n@param {string[]} [data.periods]\n@param {BasicRoll[]} [data.rolls]\n@returns {ChatMessage5e|void}\n/\n  async createTurnMessage({ deltas, periods, rolls }={}) {\n    const messageConfig = {\n      create: false,\n      data: {\n        rolls,\n        speaker: ChatMessage.getSpeaker({ actor: this.actor, token: this.token }),\n        system: {\n          deltas, periods,\n          activations: ActivationsField.getActivations(this.actor, periods),\n          origin: {\n            combat: this.combat.id,\n            combatant: this.id\n          }\n        },\n        type: \"turn\",\n        whisper: game.users.filter(u => this.actor.testUserPermission(u, \"OWNER\"))\n      }\n    };\n\n    if ( !foundry.utils.isEmpty(messageConfig.data.system.deltas?.actor)\n      || !foundry.utils.isEmpty(messageConfig.data.system.deltas?.item)\n      || !foundry.utils.isEmpty(messageConfig.data.system.activations) ) messageConfig.create = true;\n\n    /**\nA hook event that fires before a combat state change chat message is created.\n@function dnd5e.preCreateCombatMessage\n@memberof hookEvents\n@param {Combatant5e} combatant         Combatant for which the message will be created.\n@param {object} messageConfig\n@param {boolean} messageConfig.create  Should the chat message be posted?\n@param {object} messageConfig.data     Data for the created chat message.\n/\n    Hooks.callAll(\"dnd5e.preCreateCombatMessage\", this, messageConfig);\n\n    if ( messageConfig.create ) return ChatMessage.implementation.create(messageConfig.data);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nKey for the group to which this combatant should belong, or `null` if it can't be grouped.\n@returns {string|null}\n/\n  getGroupingKey() {\n    if ( this.group ) return this.group.id;\n    if ( this.token?.actorLink || !this.token?.baseActor || (this.initiative === null) ) return null;\n    return `${Math.floor(this.initiative).paddedString(4)}:${this.token.disposition}:${this.token.baseActor.id}`;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  getInitiativeRoll(formula) {\n    if ( !this.actor ) return new CONFIG.Dice.D20Roll(formula ?? \"1d20\", {});\n    return this.actor.getInitiativeRoll();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nReset combat-related uses.\n@param {string[]} periods  Which recovery periods should be considered.\n/\n  async recoverCombatUses(periods) {\n    /**\nA hook event that fires before combat-related recovery changes.\n@function dnd5e.preCombatRecovery\n@memberof hookEvents\n@param {Combatant5e} combatant  Combatant that is being recovered.\n@param {string[]} periods       Periods to be recovered.\n@returns {boolean}              Explicitly return `false` to prevent recovery from being performed.\n/\n    if ( Hooks.call(\"dnd5e.preCombatRecovery\", this, periods) === false ) return;\n\n    const results = { actor: {}, item: [], rolls: [] };\n    await this.actor?.system.recoverCombatUses?.(periods, results);\n\n    for ( const item of this.actor?.items ?? [] ) {\n      if ( foundry.utils.getType(item.system.recoverUses) !== \"function\" ) continue;\n      const rollData = item.getRollData();\n      const { updates, rolls } = await item.system.recoverUses(Array.from(periods), rollData);\n      if ( !foundry.utils.isEmpty(updates) ) {\n        const updateTarget = results.item.find(i => i._id === item.id);\n        if ( updateTarget ) foundry.utils.mergeObject(updateTarget, updates);\n        else results.item.push({ _id: item.id, ...updates });\n      }\n      results.rolls.push(...rolls);\n    }\n\n    /**\nA hook event that fires after combat-related recovery changes have been prepared, but before they have been\napplied to the actor.\n@function dnd5e.combatRecovery\n@memberof hookEvents\n@param {Combatant5e} combatant          Combatant that is being recovered.\n@param {string[]} periods               Periods that were recovered.\n@param {CombatRecoveryResults} results  Update that will be applied to the actor and its items.\n@returns {boolean}  Explicitly return `false` to prevent updates from being performed.\n/\n    if ( Hooks.call(\"dnd5e.combatRecovery\", this, periods, results) === false ) return;\n\n    const deltas = ActorDeltasField.getDeltas(this.actor, results);\n\n    if ( !foundry.utils.isEmpty(results.actor) ) await this.actor.update(results.actor);\n    if ( results.item.length ) await this.actor.updateEmbeddedDocuments(\"Item\", results.item);\n\n    const message = await this.createTurnMessage({ deltas, periods, rolls: results.rolls });\n\n    /**\nA hook event that fires after combat-related recovery changes have been applied.\n@function dnd5e.postCombatRecovery\n@memberof hookEvents\n@param {Combatant5e} combatant       Combatant that is being recovered.\n@param {string[]} periods            Periods that were recovered.\n@param {ChatMessage5e|void} message  Chat message created, if any.\n/\n    Hooks.callAll(\"dnd5e.postCombatRecovery\", this, periods, message);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nTrigger this combatant's dynamic token to refresh.\n/\n  refreshDynamicRing() {\n    if ( !this.token?.hasDynamicRing ) return;\n    this.token.object?.renderFlags.set({ refreshRingVisuals: true });\n  }\n\n  /* -------------------------------------------- */\n  /*  Socket Event Handlers                       */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _onDelete(options, userId) {\n    requestAnimationFrame(() => this.refreshDynamicRing());\n  }\n\n  /* --------------------------------------------"
    },
    "JournalEntryPage5e": {
      "getRollData": ""
    },
    "SystemFlags": {
      "_systemFlagsDataModel": "",
      "prepareData": "",
      "setFlag": "Mixin used to add system flags enforcement to types.\n@template {foundry.abstract.Document} T\n@param {typeof T} Base  The base document class to wrap.\n@returns {typeof SystemFlags}\n@mixin\n/\nexport default function SystemFlagsMixin(Base) {\n  class SystemFlags extends Base {\n    /**\nGet the data model that represents system flags.\n@type {typeof DataModel|null}\n@abstract\n/\n    get _systemFlagsDataModel() {\n      return null;\n    }\n\n    /* -------------------------------------------- */\n\n    /** @inheritDoc */\n    prepareData() {\n      super.prepareData();\n      if ( (\"dnd5e\" in this.flags) && this._systemFlagsDataModel ) {\n        this.flags.dnd5e = new this._systemFlagsDataModel(this._source.flags.dnd5e, { parent: this });\n      }\n    }\n\n    /* --------------------------------------------",
      "get _systemFlagsDataModel": ""
    },
    "PseudoDocument": {
      "metadata": "",
      "documentConfig": "",
      "documentName": "",
      "id": "",
      "relativeID": "",
      "uuid": "",
      "item": "",
      "actor": "",
      "sheet": "",
      "render": "",
      "static _registerApp": "",
      "static _unregisterApp": "",
      "update": "",
      "updateSource": "",
      "delete": "",
      "deleteDialog": "",
      "toDragData": "",
      "createDialog": "",
      "get metadata": "",
      "static get documentConfig": "",
      "get documentConfig": "",
      "static get documentName": "",
      "get documentName": "",
      "get id": "",
      "get relativeID": "",
      "get uuid": "",
      "get item": "",
      "get actor": "",
      "get sheet": ""
    },
    "Scaling": {
      "increase": "",
      "value": "",
      "toString": "",
      "get increase": "Lightweight class containing scaling information for an item that is used in roll data to ensure it is available\nin the correct format in roll formulas: `@scaling` is the scaling value, and `@scaling.increase` as the scaling\nsteps above baseline.\n@param {number} increase  Scaling steps above baseline.\n/\nexport default class Scaling {\n  constructor(increase) {\n    this.#increase = increase;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nScaling steps above baseline.\n@type {number}",
      "get value": ""
    },
    "ModuleArt": {
      "registerModuleArt": "",
      "catch": "",
      "parseArtMapping": "",
      "apply": "",
      "static getModuleArtPath": "",
      "static getArtModules": ""
    },
    "EnchantmentRegisty": {
      "static applied": "",
      "static track": "",
      "static untrack": ""
    },
    "ItemRegistry": {
      "choices": "",
      "options": "",
      "get": "",
      "initialize": "",
      "get choices": "",
      "get options": ""
    },
    "MessageRegistry": {
      "static get": "",
      "static track": "",
      "static untrack": ""
    },
    "SpellListRegistry": {
      "options": "",
      "ready": "",
      "static forSpell": "",
      "static forType": "",
      "register": "",
      "static get options": "",
      "static get ready": ""
    },
    "SpellList": {
      "indexes": "",
      "metadata": "",
      "name": "",
      "uuids": "",
      "contribute": "",
      "getSpells": "",
      "get indexes": "",
      "get metadata": "Registration of enchanted items mapped to a specific enchantment source. The map is keyed by the UUID of\nenchant activities while the set contains UUID of applied enchantment active effects.\n@type {Map<string, Set<string>>}\n/\n  static #appliedEnchantments = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nFetch the tracked enchanted items.\n@param {string} uuid  UUID of an activity or item.\n@returns {ActiveEffect5e[]}\n/\n  static applied(uuid) {\n    const source = fromUuidSync(uuid);\n    if ( source instanceof Item ) {\n      return source.system.activities?.getByType(\"enchant\")\n        .map(a => EnchantmentRegisty.applied(a.uuid))\n        .flat() ?? [];\n    }\n    return Array.from(EnchantmentRegisty.#appliedEnchantments.get(uuid) ?? [])\n      .map(uuid => fromUuidSync(uuid))\n      .filter(effect => effect?.isAppliedEnchantment);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a new enchantment effect to the list of tracked enchantments. Will not track enchanted items in compendiums.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to track.\n/\n  static track(source, enchanted) {\n    if ( enchanted.startsWith(\"Compendium.\") ) return;\n    if ( !EnchantmentRegisty.#appliedEnchantments.has(source) ) {\n      EnchantmentRegisty.#appliedEnchantments.set(source, new Set());\n    }\n    EnchantmentRegisty.#appliedEnchantments.get(source).add(enchanted);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStop tracking an enchantment.\n@param {string} source     UUID of the active effect origin for the enchantment.\n@param {string} enchanted  UUID of the enchantment to stop tracking.\n/\n  static untrack(source, enchanted) {\n    EnchantmentRegisty.#appliedEnchantments.get(source)?.delete(enchanted);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Item Registry                               */\n/* -------------------------------------------- */\n\nclass ItemRegistry {\n  constructor(itemsType) {\n    this.#itemType = itemsType;\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\n@typedef {object} RegisteredItemData\n@property {string} name        Name of the item.\n@property {string} identifier  Item identifier.\n@property {string} img         Item's icon.\n@property {string[]} sources   UUIDs of different compendium items matching this identifier.\n/\n\n  /**\nItems grouped by identifiers.\n@type {Map<string, RegisteredItemData>}\n/\n  #items = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nType of item represented by this registry.\n@type {string}\n/\n  #itemType;\n\n  /* -------------------------------------------- */\n\n  /**\nHas initial loading been completed?\n@type {number}\n/\n  #status = ItemRegistry.#STATUS_STATES.NONE;\n\n  /**\nPossible preparation states for the item registry.\n@enum {number}\n/\n  static #STATUS_STATES = Object.freeze({\n    NONE: 0,\n    LOADING: 1,\n    READY: 2\n  });\n\n  /* -------------------------------------------- */\n\n  /**\nChoices object.\n@type {Record<string, string>}\n/\n  get choices() {\n    return this.options.reduce((obj, { value, label }) => {\n      obj[value] = label;\n      return obj;\n    }, {});\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAll items formatted for a select input.\n@type {FormSelectOption[]}\n/\n  get options() {\n    return Array.from(this.#items.entries())\n      .map(([value, data]) => ({ value, label: data.name }))\n      .sort((lhs, rhs) => lhs.label.localeCompare(rhs.label, game.i18n.lang));\n  }\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /**\nGet information on a single item based on its identifier.\n@param {string} identifier\n@returns {RegisteredItemData|void}\n/\n  get(identifier) {\n    return this.#items.get(identifier);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nScan compendium packs to register matching items of this type.\n/\n  async initialize() {\n    if ( this.#status > ItemRegistry.#STATUS_STATES.NONE ) return;\n    RegistryStatus.set(this.#itemType, false);\n    if ( game.modules.get(\"babele\")?.active && (game.babele?.initialized === false) ) {\n      Hooks.once(\"babele.ready\", () => this.initialize());\n      return;\n    } else if ( !game.ready ) {\n      Hooks.once(\"ready\", () => this.initialize());\n      return;\n    }\n    this.#status = ItemRegistry.#STATUS_STATES.LOADING;\n\n    const indexes = await CompendiumBrowser.fetch(Item, {\n      types: new Set([this.#itemType]),\n      indexFields: new Set([\"system.identifier\"]),\n      sort: false\n    });\n    for ( const item of indexes ) {\n      const identifier = item.system?.identifier ?? slugify(item.name, { strict: true });\n      if ( !this.#items.has(identifier) ) this.#items.set(identifier, { sources: [] });\n      const itemData = this.#items.get(identifier);\n      itemData.name = item.name;\n      itemData.img = item.img;\n      itemData.identifier = identifier;\n      itemData.sources.push(item.uuid);\n    }\n\n    this.#status = ItemRegistry.#STATUS_STATES.READY;\n    RegistryStatus.set(this.#itemType, true);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Message Rolls                               */\n/* -------------------------------------------- */\n\nclass MessageRegistry {\n  /**\nRegistration of roll chat messages that originated at a specific message. The map is keyed by the ID of\nthe originating message and contains sets of IDs for each roll type.\n@type {Map<string, Map<string, Set<string>>}\n/\n  static #messages = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nFetch roll messages for an origin message, in chronological order.\n@param {string} origin  ID of the origin message.\n@param {string} [type]  Type of roll messages to fetch.\n@returns {ChatMessage5e[]}\n/\n  static get(origin, type) {\n    const originMap = MessageRegistry.#messages.get(origin);\n    if ( !originMap ) return [];\n    let ids;\n    if ( type ) ids = Array.from(originMap.get(type) ?? []);\n    else ids = Array.from(originMap.values()).map(v => Array.from(v)).flat();\n    return ids\n      .map(id => game.messages.get(id))\n      .filter(m => m)\n      .sort((lhs, rhs) => lhs.timestamp - rhs.timestamp);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a new roll message to the registry.\n@param {ChatMessage5e} message  Message to add to the registry.\n/\n  static track(message) {\n    const origin = message.getFlag(\"dnd5e\", \"originatingMessage\");\n    const type = message.getFlag(\"dnd5e\", \"roll.type\");\n    if ( !origin || !type ) return;\n    if ( !MessageRegistry.#messages.has(origin) ) MessageRegistry.#messages.set(origin, new Map());\n    const originMap = MessageRegistry.#messages.get(origin);\n    if ( !originMap.has(type) ) originMap.set(type, new Set());\n    originMap.get(type).add(message.id);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRemove a roll message to the registry.\n@param {ChatMessage5e} message  Message to remove from the registry.\n/\n  static untrack(message) {\n    const origin = message.getFlag(\"dnd5e\", \"originatingMessage\");\n    const type = message.getFlag(\"dnd5e\", \"roll.type\");\n    MessageRegistry.#messages.get(origin)?.get(type)?.delete(message.id);\n  }\n}\n\n/* -------------------------------------------- */\n/*  Spell Lists                                 */\n/* -------------------------------------------- */\n\nclass SpellListRegistry {\n  /**\nSpell lists organized by the UUID of a spell they contain.\n@type {Map<string, Set<SpellList>>}\n/\n  static #bySpell = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nRegistration of spell lists grouped by type and identifier.\n@type {Map<string, Map<string, SpellList>>}\n/\n  static #byType = new Map();\n\n  /* -------------------------------------------- */\n\n  /**\nUUIDs of spell lists in the process of being loaded.\n@type {Set<string>}\n/\n  static #loading = new Set();\n\n  /* -------------------------------------------- */\n\n  /**\nOptions for each registered spell list, grouped by type.\n@type {FormSelectOption[]}\n/\n  static get options() {\n    return Object.entries(CONFIG.DND5E.spellListTypes).map(([type, group]) => {\n      const lists = this.#byType.get(type);\n      if ( !lists ) return [];\n      return Array.from(lists.entries())\n        .map(([value, list]) => ({ value, label: list.name, group, type }))\n        .sort((lhs, rhs) => lhs.label.localeCompare(rhs.label, game.i18n.lang));\n    }).flat();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHave spell lists finished loading?\n@type {boolean}\n/\n  static get ready() {\n    return this.#loading.size === 0;\n  }\n\n  /* -------------------------------------------- */\n  /*  Methods                                     */\n  /* -------------------------------------------- */\n\n  /**\nRetrieve a list of spell lists a spell belongs to.\n@param {string} uuid  UUID of a spell item.\n@returns {Set<SpellList>}\n/\n  static forSpell(uuid) {\n    return SpellListRegistry.#bySpell.get(uuid) ?? new Set();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRetrieve a specific spell list from the registry.\n@param {string} type        Type of list as defined in `CONFIG.DND5E.spellListTypes`.\n@param {string} identifier  Identifier of the specific spell list.\n@returns {SpellList|null}\n/\n  static forType(type, identifier) {\n    return SpellListRegistry.#byType.get(type)?.get(identifier) ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRegister a spell list journal entry page.\n@param {string} uuid  UUID of a spell list journal entry page.\n/\n  static async register(uuid) {\n    RegistryStatus.set(\"spellLists\", false);\n    this.#loading.add(uuid);\n    if ( !game.ready ) {\n      Hooks.once(\"ready\", () => this.register(uuid));\n      return;\n    }\n\n    const page = await fromUuid(uuid);\n    if ( !page ) throw new Error(`Journal entry page \"${uuid}\" could not be found to register as spell list.`);\n    if ( page.type !== \"spells\" ) throw new Error(`Journal entry page \"${uuid}\" is not a Spell List.`);\n\n    if ( !SpellListRegistry.#byType.has(page.system.type) ) SpellListRegistry.#byType.set(page.system.type, new Map());\n\n    const type = SpellListRegistry.#byType.get(page.system.type);\n    if ( !type.has(page.system.identifier) ) type.set(page.system.identifier, new SpellList({\n      identifier: page.system.identifier, name: page.name, type: page.system.type\n    }));\n\n    const list = type.get(page.system.identifier);\n    list.contribute(page).forEach(uuid => {\n      if ( !SpellListRegistry.#bySpell.has(uuid) ) SpellListRegistry.#bySpell.set(uuid, new Set());\n      SpellListRegistry.#bySpell.get(uuid).add(list);\n    });\n\n    this.#loading.delete(uuid);\n    if ( this.ready ) RegistryStatus.set(\"spellLists\", true);\n  }\n}\n\n/**\nType that represents a unified spell list for a specific class, subclass, species, or something else.\n/\nexport class SpellList {\n  constructor(metadata) {\n    this.#metadata = Object.freeze(metadata);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMapping of spell list types to item registries.\n@enum {string}\n/\n  static #REGISTRIES = {\n    class: \"classes\"\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nIndexes for the available spells sorted by name.\n@returns {object[]}\n/\n  get indexes() {\n    return Array.from(this.#spells.keys())\n      .map(s => fromUuidSync(s))\n      .sort((lhs, rhs) => lhs.name.localeCompare(rhs.name, game.i18n.lang));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nInformation on the spell list.\n@type {{ identifier: string, name: string, type: string }}",
      "get name": "",
      "get uuids": ""
    },
    "SummonRegistry": {
      "static creatures": "",
      "static track": "",
      "static untrack": ""
    },
    "Tooltips5e": {
      "tooltip": "",
      "observe": "",
      "_onMutation": "",
      "_onTooltipActivate": "",
      "_onHoverActor": "",
      "_onHoverContentLink": "",
      "_onHoverPassive": "",
      "_positionItemTooltip": "",
      "static activateListeners": "",
      "get tooltip": ""
    }
  },
  "methodTypes": {
    "Accordion": {
      "bind": {
        "returnType": "number",
        "params": [
          {
            "name": "root",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClickHeading": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onExpandSection": {
        "returnType": "any",
        "params": [
          {
            "name": "heading",
            "type": "any",
            "optional": false
          },
          {
            "name": "content",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ animate",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_onCollapseSection": {
        "returnType": "string",
        "params": [
          {
            "name": "heading",
            "type": "any",
            "optional": false
          },
          {
            "name": "content",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ animate",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_onEnd": {
        "returnType": "string",
        "params": [
          {
            "name": "heading",
            "type": "any",
            "optional": false
          },
          {
            "name": "content",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "cancelOngoing": {
        "returnType": "any",
        "params": [
          {
            "name": "heading",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_saveCollapsedState": {
        "returnType": "any[]",
        "params": [],
        "isStatic": false
      },
      "_restoreCollapsedState": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      }
    },
    "ActivityChoiceDialog": {
      "activity": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "item": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "title": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_configureRenderOptions": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareActivityContext": {
        "returnType": "any",
        "params": [
          {
            "name": "activity",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onChooseActivity": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static create": {
        "returnType": "Promise<any>",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "get activity": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get item": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get title": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActivitySheet": {
      "activity": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "expandedSections": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "title": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "this",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareActivationContext": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareAppliedEffectContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "effect",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareDamagePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "part",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareEffectContext": {
        "returnType": "string",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareIdentityContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_getTabs": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_markTabs": {
        "returnType": "any",
        "params": [
          {
            "name": "tabs",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onRender": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "changeTab": {
        "returnType": "string",
        "params": [
          {
            "name": "tab",
            "type": "any",
            "optional": false
          },
          {
            "name": "group",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "toggleNestedTabs": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "addConsumption": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "addDamagePart": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "addEffect": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_addEffectData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "addRecovery": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "deleteConsumption": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "deleteDamagePart": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "deleteEffect": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "deleteRecovery": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "dissociateEffect": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "toggleCollapsed": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get activity": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get expandedSections": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get title": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActivityUsageDialog": {
      "activity": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "config": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "item": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "title": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "subtitle": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "used": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_configureRenderOptions": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "this",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareConcentrationContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareConsumptionContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareCreationContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareFooterContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareScalingContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_shouldDisplay": {
        "returnType": "this",
        "params": [
          {
            "name": "section",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onSubmitForm": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onUse": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "create": {
        "returnType": "Promise<any>",
        "params": [
          {
            "name": "activity",
            "type": "any",
            "optional": false
          },
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get activity": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get config": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get item": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get title": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get subtitle": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get used": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AttackSheet": {
      "_prepareEffectContext": {
        "returnType": "string",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareIdentityContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "CastSheet": {
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareEffectContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareIdentityContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_getTabs": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "removeSpell": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "CheckSheet": {
      "_prepareEffectContext": {
        "returnType": "string",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "DamageSheet": {},
    "EnchantSheet": {
      "_prepareAppliedEffectContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "effect",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareEffectContext": {
        "returnType": "string",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_getTabs": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_addEffectData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      }
    },
    "EnchantUsageDialog": {
      "_prepareCreationContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "ForwardSheet": {
      "_prepareActivationContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareEffectContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_getTabs": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      }
    },
    "HealSheet": {
      "_prepareEffectContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "OrderUsageDialog": {
      "_prepareBuildContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareCostsContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ days",
            "type": "any",
            "optional": false
          },
          {
            "name": "gold }",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareCraftContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareEnlargeContext": {
        "returnType": "string",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareFooterContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareOrderContext": {
        "returnType": "string",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareTradeContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_attachFrameListeners": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_onDrop": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareBuildData": {
        "returnType": "any",
        "params": [
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareCraftData": {
        "returnType": "string",
        "params": [
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareTradeData": {
        "returnType": "number",
        "params": [
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onDeleteOccupant": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onRemoveCraft": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      }
    },
    "SaveSheet": {
      "_prepareAppliedEffectContext": {
        "returnType": "string",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "effect",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareEffectContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "SummonSheet": {
      "_prepareEffectContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_getTabs": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_onRender": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "addProfile": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "deleteProfile": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onDrop": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "SummonUsageDialog": {
      "_prepareCreationContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getProfileLabel": {
        "returnType": "any",
        "params": [
          {
            "name": "profile",
            "type": "any",
            "optional": false
          },
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "UtilitySheet": {},
    "BaseConfigSheet": {
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "boolean",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_getActorOverrides": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_addOverriddenChoices": {
        "returnType": "any",
        "params": [
          {
            "name": "prefix",
            "type": "any",
            "optional": false
          },
          {
            "name": "path",
            "type": "any",
            "optional": false
          },
          {
            "name": "overrides",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActorSheet5eCharacter": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_prepareItems": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareItem": {
        "returnType": "string",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onConfigMenu": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onSheetAction": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onShortRest": {
        "returnType": "this",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onLongRest": {
        "returnType": "this",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDropSingleItem": {
        "returnType": "boolean",
        "params": [
          {
            "name": "itemData",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AbilityConfig": {
      "propertyConfig": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get propertyConfig": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ArmorClassConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "string",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "BaseProficiencyConfig": {
      "propertyConfig": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "propertyLabel": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_initializeApplicationOptions": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get propertyConfig": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get propertyLabel": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ConcentrationConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "DamagesConfig": {
      "otherLabel": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processChoice": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "choice",
            "type": "any",
            "optional": false
          },
          {
            "name": "categoryChosen",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_processFormData": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get otherLabel": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "DeathConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "HabitatConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "string",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processFormData": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "HitDiceConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "rollDie": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "stepValue": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processFormData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "HitPointsConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "rollFormula": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "any",
        "params": [
          {
            "name": "error",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "InitiativeConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "LanguagesConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SkillToolConfig": {
      "propertyConfig": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "string",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get propertyConfig": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SkillsConfig": {
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processChoice": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "choice",
            "type": "any",
            "optional": false
          },
          {
            "name": "categoryChosen",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_onRender": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "configureSkill": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "SpellSlotsConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ToolsConfig": {
      "_processChoice": {
        "returnType": "boolean",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "choice",
            "type": "any",
            "optional": false
          },
          {
            "name": "categoryChosen",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_onRender": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "configureTool": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processFormData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "TraitsConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "otherLabel": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_initializeApplicationOptions": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processChoices": {
        "returnType": "string",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "choices",
            "type": "any",
            "optional": false
          },
          {
            "name": "categoryChosen",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_processChoice": {
        "returnType": "boolean",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "choice",
            "type": "any",
            "optional": false
          },
          {
            "name": "categoryChosen",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_processFormData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_filterData": {
        "returnType": "any",
        "params": [
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          },
          {
            "name": "keyPath",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get otherLabel": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "TreasureConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "string",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processFormData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "WeaponsConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_processChoice": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "choice",
            "type": "any",
            "optional": false
          },
          {
            "name": "categoryChosen",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_processFormData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActorAbilityConfig": {},
    "ActorArmorConfig": {},
    "ActorConcentrationConfig": {},
    "DamageModificationConfig": {},
    "ActorHitDiceConfig": {},
    "ActorHitPointsConfig": {},
    "ActorInitiativeConfig": {},
    "ActorMovementConfig": {},
    "ProficiencyConfig": {},
    "ActorSensesConfig": {},
    "ActorSkillsConfig": {},
    "ActorSpellSlotsConfig": {},
    "ToolSelector": {},
    "TraitSelector": {},
    "ActorTypeConfig": {},
    "ActorSheet5eNPC": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "number",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareItems": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getArmorLabel": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_prepareItem": {
        "returnType": "any",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onConfigMenu": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onSheetAction": {
        "returnType": "this",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "BaseRestDialog": {
      "config": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "promptNewDay": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "rested": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "string",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "handleFormSubmission": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "configure": {
        "returnType": "Promise<any>",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "config",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get config": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get promptNewDay": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get rested": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "LongRestDialog": {
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "longRestDialog": {
        "returnType": "this",
        "params": [
          {
            "name": "{ actor }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      }
    },
    "ShortRestDialog": {
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "rollHitDie": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "shortRestDialog": {
        "returnType": "this",
        "params": [
          {
            "name": "{ actor }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      }
    },
    "ActorSheetFlags": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_getClasses": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_getFlags": {
        "returnType": "Record<string, any>",
        "params": [],
        "isStatic": false
      },
      "_getBonuses": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_getNPC": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActorSheet5eVehicle": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "newCargo": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_getMovementSpeed": {
        "returnType": "any",
        "params": [
          {
            "name": "actorData",
            "type": "any",
            "optional": false
          },
          {
            "name": "largestPrimary",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_prepareCrewedItem": {
        "returnType": "string",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareItems": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onCargoRowChange": {
        "returnType": "this",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onInventoryEvent": {
        "returnType": "this",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDropSingleItem": {
        "returnType": "string",
        "params": [
          {
            "name": "itemData",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "static get newCargo": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AbilityScoreImprovementConfig": {
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "adjustValue": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "lockValue": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareConfigurationUpdate": {
        "returnType": "any",
        "params": [
          {
            "name": "configuration",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "AbilityScoreImprovementFlow": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "retainData": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeInput": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onBrowseCompendium": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClickButton": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClickFeature": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onItemDelete": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDrop": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "boolean",
        "params": [
          {
            "name": "err",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AdvancementConfig": {
      "advancement": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "title": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onRender": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "deleteDroppedItem": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareConfigurationUpdate": {
        "returnType": "any",
        "params": [
          {
            "name": "configuration",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processSubmitData": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static _cleanedObject": {
        "returnType": "boolean",
        "params": [
          {
            "name": "object",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "_onDragStart": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDrop": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "any",
        "params": [
          {
            "name": "err",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_validateDroppedItem": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get advancement": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get title": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "close": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "render": {
        "returnType": "any",
        "params": [
          {
            "name": "force",
            "type": "any",
            "optional": true
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onItemDelete": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_canDragDrop": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AdvancementConfirmationDialog": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static forDelete": {
        "returnType": "this",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static forLevelDown": {
        "returnType": "this",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static createDialog": {
        "returnType": "Promise<any>",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "title",
            "type": "any",
            "optional": false
          },
          {
            "name": "message",
            "type": "any",
            "optional": false
          },
          {
            "name": "continueButton",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AdvancementFlow": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "id": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "title": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "advancement": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "retainData": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_render": {
        "returnType": "any",
        "params": [
          {
            "name": "...args",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getAutomaticApplicationValue": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_canDragDrop": {
        "returnType": "boolean",
        "params": [
          {
            "name": "selector",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get id": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get title": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get advancement": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AdvancementManager": {
      "subtitle": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "id": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "step": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "previousStep": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "nextStep": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "static forNewAdvancement": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "itemId",
            "type": "any",
            "optional": false
          },
          {
            "name": "advancements",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static forNewItem": {
        "returnType": "string",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "itemData",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static forModifyChoices": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "itemId",
            "type": "any",
            "optional": false
          },
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static forDeletedAdvancement": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "itemId",
            "type": "any",
            "optional": false
          },
          {
            "name": "advancementId",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static forDeletedItem": {
        "returnType": "string",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "itemId",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static forLevelChange": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "classId",
            "type": "any",
            "optional": false
          },
          {
            "name": "levelDelta",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "createLevelChangeSteps": {
        "returnType": "this",
        "params": [
          {
            "name": "classItem",
            "type": "any",
            "optional": false
          },
          {
            "name": "levelDelta",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static flowsForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ findExisting }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static currentLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "actor",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "_configureRenderOptions": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "render": {
        "returnType": "string",
        "params": [
          {
            "name": "forced",
            "type": "any",
            "optional": true
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_onRender": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "close": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "process": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "forward": {
        "returnType": "boolean",
        "params": [
          {
            "name": "{ automaticData",
            "type": "any",
            "optional": false
          },
          {
            "name": "event }",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "boolean",
        "params": [
          {
            "name": "error",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "synthesizeSteps": {
        "returnType": "any",
        "params": [
          {
            "name": "preEmbeddedItems",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "backward": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ render",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "clearSyntheticSteps": {
        "returnType": "any",
        "params": [
          {
            "name": "preEmbeddedItems",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "restart": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "complete": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get subtitle": {
        "returnType": "number",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get id": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get step": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get previousStep": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get nextStep": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AdvancementVisualizer": {
      "manager": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get manager": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AdvancementMigrationDialog": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static createDialog": {
        "returnType": "number",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "advancements",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AdvancementSelection": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "id": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeInput": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "createDialog": {
        "returnType": "Promise<any>",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ rejectClose",
            "type": "any",
            "optional": true
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get id": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "HitPointsFlow": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_updateRollResult": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "this",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ItemChoiceConfig": {
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareConfigurationUpdate": {
        "returnType": "any[]",
        "params": [
          {
            "name": "configuration",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_validateDroppedItem": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "ItemChoiceFlow": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "retainData": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getContext": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeInput": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onItemDelete": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDrop": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "boolean",
        "params": [
          {
            "name": "err",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_maxSpellSlotLevel": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ItemGrantConfig": {
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareConfigurationUpdate": {
        "returnType": "any[]",
        "params": [
          {
            "name": "configuration",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_validateDroppedItem": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "ItemGrantFlow": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getContext": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getSelectAbilities": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClickFeature": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ScaleValueConfig": {
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareLevelData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_mergeScaleValues": {
        "returnType": "any",
        "params": [
          {
            "name": "value",
            "type": "any",
            "optional": false
          },
          {
            "name": "lastValue",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeTitle": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareConfigurationUpdate": {
        "returnType": "any",
        "params": [
          {
            "name": "configuration",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static _cleanedObject": {
        "returnType": "any",
        "params": [
          {
            "name": "object",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "ScaleValueFlow": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SizeConfig": {
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareConfigurationUpdate": {
        "returnType": "any",
        "params": [
          {
            "name": "configuration",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "SizeFlow": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SubclassFlow": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "retainData": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "jQuery",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onBrowseCompendium": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClickFeature": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onItemDelete": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDrop": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "boolean",
        "params": [
          {
            "name": "err",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "TraitConfig": {
      "config": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "types": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onRender": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "addChoice": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "removeChoice": {
        "returnType": "number",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeForm": {
        "returnType": "this",
        "params": [
          {
            "name": "formConfig",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareConfigurationUpdate": {
        "returnType": "any",
        "params": [
          {
            "name": "configuration",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get config": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get types": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "TraitFlow": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "traitConfig": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onSelectTrait": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onRemoveTrait": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareInitialValue": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "prepareTraitSlots": {
        "returnType": "boolean",
        "params": [
          {
            "name": "available",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get traitConfig": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "Dialog5e": {
      "form": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "this",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareContentContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareFooterContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_attachFrameListeners": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "get form": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "PseudoDocumentSheet": {
      "document": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "isVisible": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "isEditable": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "item": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_canRender": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onFirstRender": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onRender": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClose": {
        "returnType": "any",
        "params": [
          {
            "name": "_options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_renderFrame": {
        "returnType": "string",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onCopyUuid": {
        "returnType": "number",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onSubmitForm": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "submit": {
        "returnType": "any",
        "params": [
          {
            "name": "{ updateData",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get document": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isVisible": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isEditable": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get item": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "Award": {
      "award": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "origin": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "transferDestinations": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "isPartyAward": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static prepareDestinations": {
        "returnType": "any",
        "params": [
          {
            "name": "destinations",
            "type": "any",
            "optional": false
          },
          {
            "name": "savedDestinations",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "_onRender": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeForm": {
        "returnType": "any",
        "params": [
          {
            "name": "formConfig",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_validateForm": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "handleFormSubmission": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_saveDestinations": {
        "returnType": "any",
        "params": [
          {
            "name": "destinations",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "displayAwardMessages": {
        "returnType": "any[]",
        "params": [
          {
            "name": "results",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static chatMessage": {
        "returnType": "boolean",
        "params": [
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "handleAward": {
        "returnType": "any",
        "params": [
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "any",
        "params": [
          {
            "name": "err",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static parseAwardCommand": {
        "returnType": "boolean",
        "params": [
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "get award": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get origin": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get transferDestinations": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isPartyAward": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "BastionConfig": {},
    "CompendiumBrowserSourceConfig": {
      "static collateSources": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      }
    },
    "CompendiumBrowser": {
      "displaySelection": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "currentFilters": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "selected": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "selectionLocalizationSuffix": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_configureRenderOptions": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "this",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareFooterContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareHeaderContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareSidebarContext": {
        "returnType": "string",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareResultsContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareTabsContext": {
        "returnType": "any[]",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_renderFrame": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_renderResult": {
        "returnType": "any",
        "params": [
          {
            "name": "entry",
            "type": "any",
            "optional": false
          },
          {
            "name": "documentClass",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_renderResults": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "_renderSourceFilters": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "changeTab": {
        "returnType": "any",
        "params": [
          {
            "name": "tab",
            "type": "any",
            "optional": false
          },
          {
            "name": "group",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_attachFrameListeners": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "_attachPartListeners": {
        "returnType": "string",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "htmlElement",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_applyModeFilters": {
        "returnType": "string",
        "params": [
          {
            "name": "mode",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_applyTabFilters": {
        "returnType": "string",
        "params": [
          {
            "name": "id",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "adjustCheckboxStates": {
        "returnType": "boolean",
        "params": [
          {
            "name": "htmlElement",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeForm": {
        "returnType": "string",
        "params": [
          {
            "name": "formConfig",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDragStart": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "any",
        "params": [
          {
            "name": "e",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onKeyAction": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onScrollResults": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onSearchName": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onConfigureSources": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "onClearName": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onHandleSubmit": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onOpenLink": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onSetFilter": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onSetType": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onToggleCollapse": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onToggleMode": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "select": {
        "returnType": "Promise<any>",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "selectOne": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static applyFilters": {
        "returnType": "string",
        "params": [
          {
            "name": "definition",
            "type": "any",
            "optional": false
          },
          {
            "name": "values",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static injectSidebarButton": {
        "returnType": "string",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static intersectFilters": {
        "returnType": "any",
        "params": [
          {
            "name": "first",
            "type": "any",
            "optional": false
          },
          {
            "name": "second",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "get displaySelection": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get currentFilters": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get selected": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AdoptedStyleSheetElement": {
      "adoptedCallback": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_getStyleSheet": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_adoptStyleSheet": {
        "returnType": "any",
        "params": [
          {
            "name": "sheet",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "ChatTrayElement": {
      "open": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "attributeChangedCallback": {
        "returnType": "string",
        "params": [
          {
            "name": "name",
            "type": "any",
            "optional": false
          },
          {
            "name": "oldValue",
            "type": "any",
            "optional": false
          },
          {
            "name": "newValue",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_handleClickHeader": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_handleToggleOpen": {
        "returnType": "string",
        "params": [
          {
            "name": "open",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get open": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "set open": {
        "returnType": "void",
        "params": [
          {
            "name": "open",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "set"
      }
    },
    "CopyableTextElement": {
      "connectedCallback": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "disconnectedCallback": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_onClick": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "EffectsElement": {
      "connectedCallback": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_app": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "document": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "static prepareCategories": {
        "returnType": "any",
        "params": [
          {
            "name": "effects",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ parent }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "_getContextOptions": {
        "returnType": "any",
        "params": [
          {
            "name": "effect",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onAction": {
        "returnType": "any",
        "params": [
          {
            "name": "target",
            "type": "any",
            "optional": false
          },
          {
            "name": "action",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onToggleCondition": {
        "returnType": "any",
        "params": [
          {
            "name": "conditionId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onCreate": {
        "returnType": "this",
        "params": [
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClickEffectSource": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getEffect": {
        "returnType": "this",
        "params": [
          {
            "name": "{ effectId",
            "type": "any",
            "optional": false
          },
          {
            "name": "parentId }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get _app": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get document": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "EnchantmentApplicationElement": {
      "enchantmentActivity": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "enchantmentItem": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "connectedCallback": {
        "returnType": "ChatMessage5e",
        "params": [],
        "isStatic": false
      },
      "buildItemList": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_onDrop": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onRemoveEnchantment": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get enchantmentActivity": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get enchantmentItem": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "InventoryElement": {
      "connectedCallback": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_initializeFilterLists": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_applyFilters": {
        "returnType": "boolean",
        "params": [
          {
            "name": "state",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_app": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "canUse": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "document": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "getItem": {
        "returnType": "this",
        "params": [
          {
            "name": "id",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_getContextOptions": {
        "returnType": "any",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "element",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeInput": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeInputDelta": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onAdjustInput": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onAction": {
        "returnType": "any",
        "params": [
          {
            "name": "target",
            "type": "any",
            "optional": false
          },
          {
            "name": "action",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ event }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_onCreate": {
        "returnType": "string",
        "params": [
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onExpand": {
        "returnType": "any",
        "params": [
          {
            "name": "target",
            "type": "any",
            "optional": false
          },
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onOpenContextMenu": {
        "returnType": "any",
        "params": [
          {
            "name": "element",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get _app": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get canUse": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get document": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ItemListControlsElement": {
      "connectedCallback": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "app": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "list": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "state": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "tab": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "prefs": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "keepEmpty": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "sortMode": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "buildHTML": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_initFilters": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_initGrouping": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "_initSorting": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_applyFilters": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "_applyGrouping": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "_applySorting": {
        "returnType": "any[]",
        "params": [],
        "isStatic": false
      },
      "_onToggleFilterItem": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onToggleMode": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onFilterName": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClearFilters": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "get app": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get list": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get state": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get tab": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get prefs": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get keepEmpty": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get sortMode": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SlideToggleElement": {
      "connectedCallback": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_buildElements": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      }
    },
    "TargetedApplicationElement": {
      "targetingMode": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "buildTargetContainer": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "buildTargetsList": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "buildTargetListEntry": {
        "returnType": "any",
        "params": [
          {
            "name": "{ uuid",
            "type": "any",
            "optional": false
          },
          {
            "name": "name }",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeTargetMode": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get targetingMode": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "set targetingMode": {
        "returnType": "void",
        "params": [
          {
            "name": "mode",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "set"
      }
    },
    "CurrencyManager": {
      "document": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "transferDestinations": {
        "returnType": "any[]",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_getTabs": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "setTransferValue": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeForm": {
        "returnType": "any",
        "params": [
          {
            "name": "formConfig",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_validateForm": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "handleFormSubmission": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static convertCurrency": {
        "returnType": "any",
        "params": [
          {
            "name": "doc",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static deductActorCurrency": {
        "returnType": "number",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "amount",
            "type": "any",
            "optional": false
          },
          {
            "name": "denomination",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static getActorCurrencyUpdates": {
        "returnType": "number",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "amount",
            "type": "any",
            "optional": false
          },
          {
            "name": "denomination",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ recursive",
            "type": "any",
            "optional": true
          },
          {
            "name": "priority",
            "type": "any",
            "optional": true
          },
          {
            "name": "exact",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "transferCurrency": {
        "returnType": "any",
        "params": [
          {
            "name": "origin",
            "type": "any",
            "optional": false
          },
          {
            "name": "destinations",
            "type": "any",
            "optional": false
          },
          {
            "name": "amounts",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get document": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get transferDestinations": {
        "returnType": "any[]",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AttackRollConfigurationDialog": {
      "_prepareConfigurationContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "D20RollConfigurationDialog": {
      "rollType": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_prepareButtonsContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_finalizeRolls": {
        "returnType": "this",
        "params": [
          {
            "name": "action",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get rollType": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "DamageRollConfigurationDialog": {
      "rollType": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_prepareButtonsContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareFormulasContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_buildConfig": {
        "returnType": "any",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          },
          {
            "name": "index",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_finalizeRolls": {
        "returnType": "this",
        "params": [
          {
            "name": "action",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get rollType": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "RollConfigurationDialog": {
      "rollType": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "config": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "message": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "rolls": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_identifyDiceTerms": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "this",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareButtonsContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareConfigurationContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareFormulasContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "buildRolls": {
        "returnType": "any",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_buildConfig": {
        "returnType": "boolean",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          },
          {
            "name": "index",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_finalizeRolls": {
        "returnType": "this",
        "params": [
          {
            "name": "action",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "rebuild": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "handleFormSubmission": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeForm": {
        "returnType": "any",
        "params": [
          {
            "name": "formConfig",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClose": {
        "returnType": "any[]",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "configure": {
        "returnType": "Promise<any>",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": true
          },
          {
            "name": "dialog",
            "type": "any",
            "optional": true
          },
          {
            "name": "message",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static get rollType": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get config": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get message": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get rolls": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get rollType": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SkillToolRollConfigurationDialog": {
      "_prepareConfigurationContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeForm": {
        "returnType": "string",
        "params": [
          {
            "name": "formConfig",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "ContainerSheet": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "template": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_onDragStart": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDrop": {
        "returnType": "this",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDropFolder": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDropItem": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDropSingleItem": {
        "returnType": "string",
        "params": [
          {
            "name": "itemData",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ container",
            "type": "any",
            "optional": false
          },
          {
            "name": "depth",
            "type": "any",
            "optional": false
          },
          {
            "name": "event }",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onSortItem": {
        "returnType": "any[]",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get template": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "CreateScrollDialog": {
      "config": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "spell": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContentContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "handleFormSubmission": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onChangeForm": {
        "returnType": "any",
        "params": [
          {
            "name": "formConfig",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClose": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "create": {
        "returnType": "Promise<any>",
        "params": [
          {
            "name": "spell",
            "type": "any",
            "optional": false
          },
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get config": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get spell": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "EnchantmentConfig": {},
    "StartingEquipmentConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "number",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onRender": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onAction": {
        "returnType": "any",
        "params": [
          {
            "name": "element",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ action",
            "type": "any",
            "optional": false
          },
          {
            "name": "depth",
            "type": "any",
            "optional": false
          },
          {
            "name": "entryId }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_onClickAction": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          },
          {
            "name": "updateData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processSubmitData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "submitData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDragStart": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDrop": {
        "returnType": "this",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onSortEntry": {
        "returnType": "number",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SummoningConfig": {},
    "JournalEditor": {
      "title": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SpellsUnlinkedConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_processFormData": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "DragDropApplication": {
      "_onDragOver": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_dropBehavior": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_allowedDropBehaviors": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_defaultDropBehavior": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "PropertyAttribution": {
      "renderTooltip": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_insertElement": {
        "returnType": "boolean",
        "params": [
          {
            "name": "element",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "boolean",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getPropertyLabel": {
        "returnType": "string",
        "params": [
          {
            "name": "property",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "BaseSettingsConfig": {
      "_preparePartContext": {
        "returnType": "any[]",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "createSettingField": {
        "returnType": "any",
        "params": [
          {
            "name": "name",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onCommitChanges": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "BastionSettingsConfig": {
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "CombatSettingsConfig": {
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "CompendiumBrowserSettingsConfig": {
      "_prepareContext": {
        "returnType": "string",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePackageContext": {
        "returnType": "any",
        "params": [
          {
            "name": "id",
            "type": "any",
            "optional": false
          },
          {
            "name": "pkg",
            "type": "any",
            "optional": false
          },
          {
            "name": "packs",
            "type": "any",
            "optional": false
          },
          {
            "name": "sources",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePackGroupContext": {
        "returnType": "any",
        "params": [
          {
            "name": "documentType",
            "type": "any",
            "optional": false
          },
          {
            "name": "packs",
            "type": "any",
            "optional": false
          },
          {
            "name": "sources",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_attachFrameListeners": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_attachPartListeners": {
        "returnType": "string",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "htmlElement",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_filterPackages": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_onChangeForm": {
        "returnType": "any",
        "params": [
          {
            "name": "formConfig",
            "type": "any",
            "optional": false
          },
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onFilterPackages": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onTogglePack": {
        "returnType": "string",
        "params": [
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onTogglePackage": {
        "returnType": "string",
        "params": [
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onToggleSource": {
        "returnType": "any",
        "params": [
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onClearPackageFilter": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onSelectPackage": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static collateSources": {
        "returnType": "boolean",
        "params": [],
        "isStatic": true
      }
    },
    "ModuleArtSettingsConfig": {
      "defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getData": {
        "returnType": "any[]",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "activateListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onAction": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_updateObject": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get defaultOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "VariantRulesSettingsConfig": {
      "_preparePartContext": {
        "returnType": "string",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "VisibilitySettingsConfig": {
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "CreatureTypeConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "string",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "MovementSensesConfig": {
      "keyPath": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "title": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "types": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_initializeApplicationOptions": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preparePartContext": {
        "returnType": "any",
        "params": [
          {
            "name": "partId",
            "type": "any",
            "optional": false
          },
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareExtraFields": {
        "returnType": "any[]",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get keyPath": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get title": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get types": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SourceConfig": {
      "title": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get title": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "TokenPlacement": {
      "static place": {
        "returnType": "any",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "place": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "createPreviews": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "destroyPreviews": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "requestPlacement": {
        "returnType": "Promise<any>",
        "params": [],
        "isStatic": false
      },
      "finishPlacement": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onMovePlacement": {
        "returnType": "boolean",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onRotatePlacement": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onConfirmPlacement": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onSkipPlacement": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static adjustAppendedNumber": {
        "returnType": "any",
        "params": [
          {
            "name": "tokenDocument",
            "type": "any",
            "optional": false
          },
          {
            "name": "placement",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "ActorDataModel": {
      "embeddedDescriptionKeyPath": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "transferDestinations": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "prepareEmbeddedData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_prepareScaleValues": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getRollData": {
        "returnType": "any",
        "params": [
          {
            "name": "{ deterministic",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "recoverCombatUses": {
        "returnType": "any",
        "params": [
          {
            "name": "periods",
            "type": "any",
            "optional": false
          },
          {
            "name": "results",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get embeddedDescriptionKeyPath": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get transferDestinations": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ItemDataModel": {
      "attackModes": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "availableAbilities": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "embeddedDescriptionKeyPath": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "scalingIncrease": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "prepareBaseData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "richTooltip": {
        "returnType": "any",
        "params": [
          {
            "name": "enrichmentOptions",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getCardData": {
        "returnType": "any",
        "params": [
          {
            "name": "{ activity",
            "type": "any",
            "optional": false
          },
          {
            "name": "...enrichmentOptions }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getCraftCost": {
        "returnType": "number",
        "params": [
          {
            "name": "{ baseItem",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getFavoriteData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getSheetData": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getRollData": {
        "returnType": "any",
        "params": [
          {
            "name": "{ deterministic",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get attackModes": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get availableAbilities": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get embeddedDescriptionKeyPath": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get scalingIncrease": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AttackActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "ability": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "actionType": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "activationLabels": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "availableAbilities": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "criticalThreshold": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "validAttackTypes": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "static transformTypeData": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "activityData",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "prepareData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "prepareFinalData": {
        "returnType": "boolean",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getActionLabel": {
        "returnType": "any",
        "params": [
          {
            "name": "attackMode",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getAttackData": {
        "returnType": "string",
        "params": [
          {
            "name": "{ ammunition",
            "type": "any",
            "optional": false
          },
          {
            "name": "attackMode",
            "type": "any",
            "optional": false
          },
          {
            "name": "situational }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getDamageConfig": {
        "returnType": "any",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getRangeLabel": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_processDamagePart": {
        "returnType": "boolean",
        "params": [
          {
            "name": "damage",
            "type": "any",
            "optional": false
          },
          {
            "name": "rollConfig",
            "type": "any",
            "optional": false
          },
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          },
          {
            "name": "index",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get ability": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get actionType": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get activationLabels": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get availableAbilities": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get criticalThreshold": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get validAttackTypes": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "CastActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "prepareFinalData": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "CheckActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "ability": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "static transformTypeData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "activityData",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "prepareFinalData": {
        "returnType": "string",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getAbility": {
        "returnType": "this",
        "params": [
          {
            "name": "associated",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get ability": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "DamageActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static transformTypeData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "activityData",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "prepareFinalData": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getDamageConfig": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      }
    },
    "EnchantActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "actionType": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "applicableEffects": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "appliedEnchantments": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "availableEnchantments": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "enchantableTypes": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static transformEffectsData": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static transformTypeData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "activityData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "get actionType": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get applicableEffects": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get appliedEnchantments": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get availableEnchantments": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "static get enchantableTypes": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AppliedEffectField": {
      "initialize": {
        "returnType": "any",
        "params": [
          {
            "name": "value",
            "type": "any",
            "optional": false
          },
          {
            "name": "model",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "defineProperty": {
        "returnType": "any",
        "params": [
          {
            "name": "obj",
            "type": "any",
            "optional": false
          },
          {
            "name": "\"effect\"",
            "type": "any",
            "optional": false
          },
          {
            "name": "{\n      get(",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "ConsumptionTargetsField": {},
    "ConsumptionError": {},
    "ForwardActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      }
    },
    "HealActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static transformTypeData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "activityData",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "prepareFinalData": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getDamageConfig": {
        "returnType": "any",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      }
    },
    "OrderActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "prepareData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      }
    },
    "SaveActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "ability": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "static migrateData": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static transformTypeData": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "activityData",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "prepareData": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "prepareFinalData": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getDamageConfig": {
        "returnType": "boolean",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get ability": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SummonActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "ability": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "actionType": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "applicableEffects": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "availableProfiles": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "relevantLevel": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "summonedCreatures": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static transformTypeData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "activityData",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "get ability": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get actionType": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get applicableEffects": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get availableProfiles": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get relevantLevel": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get summonedCreatures": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "UtilityActivityData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static transformTypeData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "activityData",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "CharacterData": {
      "static defineSchema": {
        "returnType": "this",
        "params": [],
        "isStatic": true
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "prepareBaseData": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "prepareEmbeddedData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "prepareDerivedData": {
        "returnType": "Record<string, any>",
        "params": [],
        "isStatic": false
      },
      "cantripLevel": {
        "returnType": "this",
        "params": [
          {
            "name": "spell",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "hasFavorite": {
        "returnType": "any",
        "params": [
          {
            "name": "favoriteId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "addFavorite": {
        "returnType": "any",
        "params": [
          {
            "name": "favorite",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "removeFavorite": {
        "returnType": "this",
        "params": [
          {
            "name": "favoriteId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "DamageTraitField": {},
    "SimpleTraitField": {},
    "NPCData": {
      "static defineSchema": {
        "returnType": "this",
        "params": [],
        "isStatic": true
      },
      "compendiumBrowserFilters": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateEnvironment": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateSource": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateSpellLevel": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateTypeData": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareBaseData": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "defineProperty": {
        "returnType": "any",
        "params": [
          {
            "name": "this.details",
            "type": "any",
            "optional": false
          },
          {
            "name": "\"spellLevel\"",
            "type": "any",
            "optional": false
          },
          {
            "name": "{\n      get(",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "set": {
        "returnType": "any",
        "params": [
          {
            "name": "value",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareEmbeddedData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "prepareDerivedData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preUpdate": {
        "returnType": "boolean",
        "params": [
          {
            "name": "changed",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "user",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "cantripLevel": {
        "returnType": "this",
        "params": [
          {
            "name": "spell",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getLegendaryActionsDescription": {
        "returnType": "string",
        "params": [
          {
            "name": "name",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getGear": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "recoverCombatUses": {
        "returnType": "any",
        "params": [
          {
            "name": "periods",
            "type": "any",
            "optional": false
          },
          {
            "name": "results",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "resistSave": {
        "returnType": "string",
        "params": [
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "toEmbed": {
        "returnType": "boolean",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_prepareEmbedContext": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static get compendiumBrowserFilters": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AttributesFields": {
      "armorClass": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "common": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "creature": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static _migrateInitiative": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static prepareBaseArmorClass": {
        "returnType": "string",
        "params": [],
        "isStatic": true
      },
      "static prepareBaseEncumbrance": {
        "returnType": "Record<string, any>",
        "params": [],
        "isStatic": true
      },
      "static prepareArmorClass": {
        "returnType": "string",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "catch": {
        "returnType": "any",
        "params": [
          {
            "name": "err",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static prepareConcentration": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static prepareEncumbrance": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ validateItem }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static prepareExhaustionLevel": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static prepareHitPoints": {
        "returnType": "any",
        "params": [
          {
            "name": "hp",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ advancement",
            "type": "any",
            "optional": true
          },
          {
            "name": "mod",
            "type": "any",
            "optional": true
          },
          {
            "name": "bonus",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static prepareInitiative": {
        "returnType": "string",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static prepareMovement": {
        "returnType": "string",
        "params": [],
        "isStatic": true
      },
      "static prepareRace": {
        "returnType": "any",
        "params": [
          {
            "name": "race",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ force",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static prepareSpellcastingAbility": {
        "returnType": "this",
        "params": [],
        "isStatic": true
      },
      "defineProperty": {
        "returnType": "this",
        "params": [
          {
            "name": "this.attributes",
            "type": "any",
            "optional": false
          },
          {
            "name": "\"spelldc\"",
            "type": "any",
            "optional": false
          },
          {
            "name": "{\n      get(",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get armorClass": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "static get common": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "static get creature": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "CreatureTemplate": {
      "static defineSchema": {
        "returnType": "this",
        "params": [],
        "isStatic": true
      },
      "static _initialSkillValue": {
        "returnType": "any",
        "params": [
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "initial",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "_spellLevels": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateSensesData": {
        "returnType": "boolean",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateToolData": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareSkills": {
        "returnType": "any",
        "params": [
          {
            "name": "{ rollData",
            "type": "any",
            "optional": true
          },
          {
            "name": "originalSkills }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "prepareSkill": {
        "returnType": "number",
        "params": [
          {
            "name": "skillId",
            "type": "any",
            "optional": false
          },
          {
            "name": "{\n    skillData",
            "type": "any",
            "optional": false
          },
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          },
          {
            "name": "originalSkills",
            "type": "any",
            "optional": false
          },
          {
            "name": "globalBonuses",
            "type": "any",
            "optional": false
          },
          {
            "name": "globalCheckBonus",
            "type": "any",
            "optional": false
          },
          {
            "name": "globalSkillBonus",
            "type": "any",
            "optional": false
          },
          {
            "name": "ability\n  }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "prepareTools": {
        "returnType": "any",
        "params": [
          {
            "name": "{ rollData",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getRollData": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "{ deterministic",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static get _spellLevels": {
        "returnType": "string",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "DetailsField": {
      "common": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "creature": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static get common": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "static get creature": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "TraitsField": {
      "common": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "creature": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static makeSimpleTrait": {
        "returnType": "any",
        "params": [
          {
            "name": "schemaOptions",
            "type": "any",
            "optional": true
          },
          {
            "name": "{initial",
            "type": "any",
            "optional": true
          },
          {
            "name": "extraFields",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static makeDamageTrait": {
        "returnType": "any",
        "params": [
          {
            "name": "schemaOptions",
            "type": "any",
            "optional": true
          },
          {
            "name": "{initial",
            "type": "any",
            "optional": true
          },
          {
            "name": "initialBypasses",
            "type": "any",
            "optional": true
          },
          {
            "name": "extraFields",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static prepareLanguages": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static prepareResistImmune": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static get common": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "static get creature": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "VehicleData": {
      "static defineSchema": {
        "returnType": "this",
        "params": [],
        "isStatic": true
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateSource": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareBaseData": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "prepareDerivedData": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      }
    },
    "AbilityScoreImprovementValueData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      }
    },
    "BaseAdvancement": {
      "typeName": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static get typeName": {
        "returnType": "this",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ScaleValueTypeNumber": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static convertFrom": {
        "returnType": "any",
        "params": [
          {
            "name": "original",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ScaleValueTypeCR": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "display": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get display": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ScaleValueTypeDice": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static convertFrom": {
        "returnType": "any",
        "params": [
          {
            "name": "original",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "formula": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "die": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "mods": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "denom": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static getFields": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "value",
            "type": "any",
            "optional": false
          },
          {
            "name": "lastValue",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static getPlaceholder": {
        "returnType": "string",
        "params": [
          {
            "name": "name",
            "type": "any",
            "optional": false
          },
          {
            "name": "lastValue",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get formula": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get die": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get mods": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get denom": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ScaleValueTypeDistance": {
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "display": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get display": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActivationsField": {
      "static getActivations": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "periods",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static processActivations": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "ActorDeltasField": {
      "static getDeltas": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static processDeltas": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "rolls",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      }
    },
    "IndividualDeltaField": {
      "static getDeltas": {
        "returnType": "any[]",
        "params": [
          {
            "name": "dataModel",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static processDelta": {
        "returnType": "any",
        "params": [
          {
            "name": "doc",
            "type": "any",
            "optional": false
          },
          {
            "name": "rolls",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      }
    },
    "RestMessageData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "get actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "TurnMessageData": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "combat": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "combatant": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContext": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get combat": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get combatant": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActivitiesField": {
      "initialize": {
        "returnType": "any",
        "params": [
          {
            "name": "value",
            "type": "any",
            "optional": false
          },
          {
            "name": "model",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "ActivityCollection": {
      "getByType": {
        "returnType": "any",
        "params": [
          {
            "name": "type",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getByTypes": {
        "returnType": "any",
        "params": [
          {
            "name": "...types",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "set": {
        "returnType": "any",
        "params": [
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "value",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "delete": {
        "returnType": "any",
        "params": [
          {
            "name": "key",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "every": {
        "returnType": "this",
        "params": [
          {
            "name": "predicate",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "toObject": {
        "returnType": "this",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      }
    },
    "EnchantmentField": {},
    "EnchantmentError": {},
    "SpellcastingField": {
      "static prepareData": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "SummonsField": {},
    "ActionTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateAbility": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateAttack": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateCritical": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateSave": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "abilityMod": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_typeAbilityMod": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "criticalThreshold": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_typeCriticalThreshold": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hasAbilityCheck": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "hasAttack": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hasDamage": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasSave": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasSummoning": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "isHealing": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "isVersatile": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "getRollData": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get abilityMod": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get _typeAbilityMod": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get criticalThreshold": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get _typeCriticalThreshold": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasAbilityCheck": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasAttack": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasDamage": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasSave": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasSummoning": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isHealing": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isVersatile": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActivatedEffectTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "getUsesData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "prepareFinalActivatedEffectData": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_prepareFinalFormula": {
        "returnType": "any",
        "params": [
          {
            "name": "keyPath",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ label",
            "type": "any",
            "optional": false
          },
          {
            "name": "rollData }",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "any",
        "params": [
          {
            "name": "err",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateFormulaFields": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateRanges": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateTargets": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateUses": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateConsume": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "activatedEffectCardProperties": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hasAreaTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasIndividualTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasLimitedUses": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasResource": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasAmmo": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasScalarDuration": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasScalarRange": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasScalarTarget": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hasTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "isActive": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "get activatedEffectCardProperties": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasAreaTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasIndividualTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasLimitedUses": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasResource": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasAmmo": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasScalarDuration": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasScalarRange": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasScalarTarget": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isActive": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ItemUsesField": {
      "getUsesData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "prepareFinalActivatedEffectData": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "_prepareFinalFormula": {
        "returnType": "any",
        "params": [
          {
            "name": "keyPath",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ label",
            "type": "any",
            "optional": false
          },
          {
            "name": "rollData }",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "any",
        "params": [
          {
            "name": "err",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateFormulaFields": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateRanges": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateTargets": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateUses": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateConsume": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "activatedEffectCardProperties": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hasAreaTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasIndividualTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasLimitedUses": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasResource": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasAmmo": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasScalarDuration": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasScalarRange": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasScalarTarget": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hasTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "isActive": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "get activatedEffectCardProperties": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasAreaTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasIndividualTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasLimitedUses": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasResource": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasAmmo": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasScalarDuration": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasScalarRange": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasScalarTarget": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasTarget": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isActive": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActivitiesTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "abilityMod": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_typeAbilityMod": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "appliedEnchantments": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "criticalThreshold": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasAttack": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hasLimitedUses": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hasSave": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hasSummoning": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "isActive": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "isEnchantment": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "isHealing": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "summonedCreatures": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "static migrateActivities": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateUses": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static initializeActivities": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "shouldCreateInitialActivity": {
        "returnType": "boolean",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "createInitialActivity": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareFinalActivityData": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getUsesData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "recoverUses": {
        "returnType": "string",
        "params": [
          {
            "name": "periods",
            "type": "any",
            "optional": false
          },
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onCreateActivities": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "preUpdateActivities": {
        "returnType": "any",
        "params": [
          {
            "name": "changed",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "user",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onUpdateActivities": {
        "returnType": "any",
        "params": [
          {
            "name": "changed",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onDeleteActivities": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static _applyActivityShims": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "get abilityMod": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get _typeAbilityMod": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get appliedEnchantments": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get criticalThreshold": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasAttack": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasLimitedUses": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasSave": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasSummoning": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isActive": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isEnchantment": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isHealing": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get summonedCreatures": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "EquippableItemTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "compendiumBrowserAttunementFilter": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateAttunement": {
        "returnType": "boolean",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateEquipped": {
        "returnType": "boolean",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareFinalEquippableData": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "equippableItemCardProperties": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "magicAvailable": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "preCreateEquipped": {
        "returnType": "string",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "user",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get compendiumBrowserAttunementFilter": {
        "returnType": "number",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get equippableItemCardProperties": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get magicAvailable": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "IdentifiableTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateUnidentified": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareIdentifiable": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "preUpdateIdentifiable": {
        "returnType": "any",
        "params": [
          {
            "name": "changed",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "user",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "ItemDescriptionTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateSource": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "prepareDescriptionData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "validProperties": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static compendiumBrowserPropertiesFilter": {
        "returnType": "any",
        "params": [
          {
            "name": "type",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "get validProperties": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ItemTypeTemplate": {
      "itemCategories": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migrateType": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get itemCategories": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get itemCategories": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "MountableTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      }
    },
    "PhysicalItemTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "compendiumBrowserPhysicalItemFilters": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "priceLabel": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "totalWeight": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "physicalItemSheetFields": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "preparePhysicalData": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "static _migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "migratePrice": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateRarity": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "migrateWeight": {
        "returnType": "string",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_renderContainers": {
        "returnType": "any",
        "params": [
          {
            "name": "{ formerContainer",
            "type": "any",
            "optional": false
          },
          {
            "name": "...rendering }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_preUpdate": {
        "returnType": "boolean",
        "params": [
          {
            "name": "changed",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "user",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onCreate": {
        "returnType": "boolean",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onUpdate": {
        "returnType": "boolean",
        "params": [
          {
            "name": "changed",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDelete": {
        "returnType": "boolean",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "allContainers": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "totalWeightIn": {
        "returnType": "any",
        "params": [
          {
            "name": "units",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get compendiumBrowserPhysicalItemFilters": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get priceLabel": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get totalWeight": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get physicalItemSheetFields": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "StartingEquipmentTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "startingEquipmentDescription": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "get startingEquipmentDescription": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActivationField": {
      "static prepareData": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          },
          {
            "name": "labels",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "CurrencyTemplate": {
      "static defineSchema": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "currencyWeight": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "get currencyWeight": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "DamageField": {},
    "DurationField": {
      "static prepareData": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          },
          {
            "name": "labels",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static getEffectDuration": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      }
    },
    "RangeField": {
      "static prepareData": {
        "returnType": "any",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          },
          {
            "name": "labels",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "SourceField": {
      "static prepareData": {
        "returnType": "any",
        "params": [
          {
            "name": "uuid",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static getModuleBook": {
        "returnType": "number",
        "params": [
          {
            "name": "pkg",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static getPackage": {
        "returnType": "any",
        "params": [
          {
            "name": "uuid",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static shimActor": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "defineProperty": {
        "returnType": "any",
        "params": [
          {
            "name": "this.details",
            "type": "any",
            "optional": false
          },
          {
            "name": "\"source\"",
            "type": "any",
            "optional": false
          },
          {
            "name": "{\n      get(",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "TargetField": {
      "static prepareData": {
        "returnType": "boolean",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          },
          {
            "name": "labels",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static templateDimensions": {
        "returnType": "string",
        "params": [
          {
            "name": "type",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "UsesField": {
      "static prepareData": {
        "returnType": "string",
        "params": [
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          },
          {
            "name": "labels",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "rechargeOptions": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "static getStatblockLabel": {
        "returnType": "string",
        "params": [],
        "isStatic": true
      },
      "recoverUses": {
        "returnType": "boolean",
        "params": [
          {
            "name": "periods",
            "type": "any",
            "optional": false
          },
          {
            "name": "rollData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "catch": {
        "returnType": "any",
        "params": [
          {
            "name": "err",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "rollRecharge": {
        "returnType": "boolean",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": true
          },
          {
            "name": "dialog",
            "type": "any",
            "optional": true
          },
          {
            "name": "message",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static get rechargeOptions": {
        "returnType": "number",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "BasicRoll": {
      "static fromConfig": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "process",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static constructParts": {
        "returnType": "string",
        "params": [
          {
            "name": "parts",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "build": {
        "returnType": "any",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": true
          },
          {
            "name": "dialog",
            "type": "any",
            "optional": true
          },
          {
            "name": "message",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "buildConfigure": {
        "returnType": "boolean",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": true
          },
          {
            "name": "dialog",
            "type": "any",
            "optional": true
          },
          {
            "name": "message",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "buildEvaluate": {
        "returnType": "boolean",
        "params": [
          {
            "name": "rolls",
            "type": "any",
            "optional": false
          },
          {
            "name": "config",
            "type": "any",
            "optional": true
          },
          {
            "name": "message",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "buildPost": {
        "returnType": "boolean",
        "params": [
          {
            "name": "rolls",
            "type": "any",
            "optional": false
          },
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static applyKeybindings": {
        "returnType": "boolean",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "dialog",
            "type": "any",
            "optional": false
          },
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "isFailure": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "isSuccess": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "toMessage": {
        "returnType": "any",
        "params": [
          {
            "name": "rolls",
            "type": "any",
            "optional": false
          },
          {
            "name": "messageData",
            "type": "any",
            "optional": true
          },
          {
            "name": "{ rollMode",
            "type": "any",
            "optional": false
          },
          {
            "name": "create",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static _prepareMessageData": {
        "returnType": "any",
        "params": [
          {
            "name": "rolls",
            "type": "any",
            "optional": false
          },
          {
            "name": "messageData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "evaluate": {
        "returnType": "typeof RollConfigurationDialog",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "evaluateSync": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static replaceFormulaData": {
        "returnType": "any",
        "params": [
          {
            "name": "formula",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "preCalculateDiceTerms": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static preCalculateTerm": {
        "returnType": "boolean",
        "params": [
          {
            "name": "die",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ minimize",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "simplify": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static mergeConfigs": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "original",
            "type": "any",
            "optional": false
          },
          {
            "name": "other",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "get isFailure": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isSuccess": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "D20Die": {
      "isCriticalSuccess": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "isCriticalFailure": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "isValid": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "applyAdvantage": {
        "returnType": "number",
        "params": [
          {
            "name": "advantageMode",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "applyFlag": {
        "returnType": "string",
        "params": [
          {
            "name": "flag",
            "type": "any",
            "optional": false
          },
          {
            "name": "enabled",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "applyRange": {
        "returnType": "any",
        "params": [
          {
            "name": "values",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get isCriticalSuccess": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isCriticalFailure": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isValid": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "D20Roll": {
      "static fromConfig": {
        "returnType": "any",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "process",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static fromRoll": {
        "returnType": "any",
        "params": [
          {
            "name": "roll",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static applyKeybindings": {
        "returnType": "any",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "dialog",
            "type": "any",
            "optional": false
          },
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "d20": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasAdvantage": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hasDisadvantage": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "isCritical": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "isFumble": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "validD20Roll": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static _prepareMessageData": {
        "returnType": "boolean",
        "params": [
          {
            "name": "rolls",
            "type": "any",
            "optional": false
          },
          {
            "name": "messageData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "configureModifiers": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "createD20Die": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "configureDialog": {
        "returnType": "any",
        "params": [
          {
            "name": "{\n    title",
            "type": "any",
            "optional": false
          },
          {
            "name": "defaultRollMode",
            "type": "any",
            "optional": false
          },
          {
            "name": "defaultAction",
            "type": "any",
            "optional": true
          },
          {
            "name": "ammunitionOptions",
            "type": "any",
            "optional": false
          },
          {
            "name": "attackModes",
            "type": "any",
            "optional": false
          },
          {
            "name": "chooseModifier",
            "type": "any",
            "optional": true
          },
          {
            "name": "defaultAbility",
            "type": "any",
            "optional": false
          },
          {
            "name": "masteryOptions",
            "type": "any",
            "optional": false
          },
          {
            "name": "template\n  }",
            "type": "any",
            "optional": true
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get d20": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "set d20": {
        "returnType": "void",
        "params": [
          {
            "name": "die",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "set"
      },
      "get hasAdvantage": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasDisadvantage": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isCritical": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isFumble": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get validD20Roll": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "DamageRoll": {
      "static fromConfig": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "process",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "build": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": true
          },
          {
            "name": "dialog",
            "type": "any",
            "optional": true
          },
          {
            "name": "message",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static applyKeybindings": {
        "returnType": "any",
        "params": [
          {
            "name": "config",
            "type": "any",
            "optional": false
          },
          {
            "name": "dialog",
            "type": "any",
            "optional": false
          },
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "isCritical": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "preprocessFormula": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "configureDamage": {
        "returnType": "any",
        "params": [
          {
            "name": "{ critical",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "configureDialog": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": true
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get isCritical": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ActiveEffect5e": {
      "isAppliedEnchantment": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "isConcealed": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "isTemporary": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getSource": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_fromStatusEffect": {
        "returnType": "any",
        "params": [
          {
            "name": "statusId",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ reference",
            "type": "any",
            "optional": false
          },
          {
            "name": "...effectData }",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_initializeSource": {
        "returnType": "string",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "apply": {
        "returnType": "any",
        "params": [
          {
            "name": "doc",
            "type": "any",
            "optional": false
          },
          {
            "name": "change",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "applyActivity": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "change",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static applyField": {
        "returnType": "any",
        "params": [
          {
            "name": "model",
            "type": "any",
            "optional": false
          },
          {
            "name": "change",
            "type": "any",
            "optional": false
          },
          {
            "name": "field",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "_applyAdd": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "change",
            "type": "any",
            "optional": false
          },
          {
            "name": "current",
            "type": "any",
            "optional": false
          },
          {
            "name": "delta",
            "type": "any",
            "optional": false
          },
          {
            "name": "changes",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_applyLegacy": {
        "returnType": "boolean",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "change",
            "type": "any",
            "optional": false
          },
          {
            "name": "changes",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_applyUpgrade": {
        "returnType": "this",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "change",
            "type": "any",
            "optional": false
          },
          {
            "name": "current",
            "type": "any",
            "optional": false
          },
          {
            "name": "delta",
            "type": "any",
            "optional": false
          },
          {
            "name": "changes",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_prepareFlagChange": {
        "returnType": "boolean",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "change",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "determineSuppression": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "prepareDerivedData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_prepareExhaustionLevel": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "getFavoriteData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "createRiderConditions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "createRiderEnchantments": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "toDragData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preCreate": {
        "returnType": "boolean",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "user",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onCreate": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onUpdate": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_preDelete": {
        "returnType": "boolean",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "user",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDelete": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_displayScrollingStatus": {
        "returnType": "any",
        "params": [
          {
            "name": "enabled",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static createConcentrationEffectData": {
        "returnType": "any",
        "params": [
          {
            "name": "activity",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "static registerHUDListeners": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static onRenderActiveEffectConfig": {
        "returnType": "any",
        "params": [
          {
            "name": "app",
            "type": "any",
            "optional": false
          },
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static onTokenHUDRender": {
        "returnType": "string",
        "params": [
          {
            "name": "app",
            "type": "any",
            "optional": false
          },
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static _getExhaustionImage": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static getEffectDurationFromItem": {
        "returnType": "any",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static onClickTokenHUD": {
        "returnType": "string",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static _manageExhaustion": {
        "returnType": "number",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "actor",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static _manageConcentration": {
        "returnType": "number",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "actor",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "addDependent": {
        "returnType": "this",
        "params": [
          {
            "name": "...dependent",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getDependents": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static addOverriddenChoices": {
        "returnType": "any",
        "params": [
          {
            "name": "doc",
            "type": "any",
            "optional": false
          },
          {
            "name": "prefix",
            "type": "any",
            "optional": false
          },
          {
            "name": "path",
            "type": "any",
            "optional": false
          },
          {
            "name": "overrides",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "richTooltip": {
        "returnType": "string",
        "params": [
          {
            "name": "enrichmentOptions",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "deleteDialog": {
        "returnType": "any",
        "params": [
          {
            "name": "dialogOptions",
            "type": "any",
            "optional": true
          },
          {
            "name": "operation",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get isAppliedEnchantment": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isConcealed": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isTemporary": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SourcedItemsMap": {
      "get": {
        "returnType": "any",
        "params": [
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ remap",
            "type": "any",
            "optional": true
          },
          {
            "name": "legacy",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "set": {
        "returnType": "this",
        "params": [
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "value",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_redirectKeys": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      }
    },
    "Bastion": {
      "advanceAllBastions": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "advanceAllFacilities": {
        "returnType": "string",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ duration",
            "type": "any",
            "optional": true
          },
          {
            "name": "summary",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "advanceTurn": {
        "returnType": "string",
        "params": [
          {
            "name": "facility",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ duration",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "resolveAttack": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "formula",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ summary",
            "type": "any",
            "optional": true
          },
          {
            "name": "threshold",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_activateChatListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "message",
            "type": "any",
            "optional": false
          },
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "evaluateOrder": {
        "returnType": "this",
        "params": [
          {
            "name": "facility",
            "type": "any",
            "optional": false
          },
          {
            "name": "order",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "evaluateBuildOrder": {
        "returnType": "boolean",
        "params": [
          {
            "name": "facility",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "evaluateCraftOrder": {
        "returnType": "any",
        "params": [
          {
            "name": "facility",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "evaluateEnlargeOrder": {
        "returnType": "any",
        "params": [
          {
            "name": "facility",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "evaluateHarvestOrder": {
        "returnType": "any",
        "params": [
          {
            "name": "facility",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "evaluateRepairOrder": {
        "returnType": "boolean",
        "params": [
          {
            "name": "facility",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "evaluateTradeOrder": {
        "returnType": "boolean",
        "params": [
          {
            "name": "facility",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getDefenders": {
        "returnType": "string",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onChatAction": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "target",
            "type": "any",
            "optional": false
          },
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onClaimGold": {
        "returnType": "boolean",
        "params": [
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onDragItem": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "updates",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "onResolveAttack": {
        "returnType": "number",
        "params": [
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "onViewItem": {
        "returnType": "any",
        "params": [
          {
            "name": "target",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "renderAttackSummary": {
        "returnType": "any[]",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "roll",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ damaged",
            "type": "any",
            "optional": false
          },
          {
            "name": "deaths",
            "type": "any",
            "optional": false
          },
          {
            "name": "undefended",
            "type": "any",
            "optional": false
          },
          {
            "name": "resolved }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "renderTurnSummary": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          },
          {
            "name": "results",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "confirmAdvance": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "initializeUI": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "promptAttack": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "BastionAttackDialog": {
      "formula": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "subtitle": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_prepareContentContext": {
        "returnType": "any",
        "params": [
          {
            "name": "context",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "handleFormSubmission": {
        "returnType": "this",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          },
          {
            "name": "form",
            "type": "any",
            "optional": false
          },
          {
            "name": "formData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClose": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static prompt": {
        "returnType": "Promise<any>",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "get formula": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get subtitle": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "HitDice": {
      "value": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "max": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "smallest": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "smallestAvailable": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "smallestFace": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "largest": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "largestAvailable": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "largestFace": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "pct": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "bySize": {
        "returnType": "Record<string, any>",
        "params": [],
        "isStatic": false
      },
      "toString": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "createHitDiceUpdates": {
        "returnType": "any",
        "params": [
          {
            "name": "{ maxHitDice",
            "type": "any",
            "optional": false
          },
          {
            "name": "fraction",
            "type": "any",
            "optional": true
          },
          {
            "name": "largest",
            "type": "any",
            "optional": true
          },
          {
            "name": "...config }",
            "type": "any",
            "optional": true
          },
          {
            "name": "result",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get value": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get max": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get smallest": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get smallestAvailable": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get smallestFace": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get largest": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get largestAvailable": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get largestFace": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get pct": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get bySize": {
        "returnType": "Record<string, any>",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "Proficiency": {
      "flat": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "dice": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "term": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "hasProficiency": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static calculateMod": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "clone": {
        "returnType": "string",
        "params": [
          {
            "name": "{ proficiency",
            "type": "any",
            "optional": false
          },
          {
            "name": "multiplier",
            "type": "any",
            "optional": false
          },
          {
            "name": "roundDown }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "toString": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "get flat": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get dice": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get term": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hasProficiency": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SelectChoices": {
      "asSet": {
        "returnType": "any",
        "params": [
          {
            "name": "set",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "clone": {
        "returnType": "Record<string, any>",
        "params": [],
        "isStatic": false
      },
      "find": {
        "returnType": "any",
        "params": [
          {
            "name": "key",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "forEach": {
        "returnType": "any",
        "params": [
          {
            "name": "func",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "merge": {
        "returnType": "this",
        "params": [
          {
            "name": "other",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ inplace",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_sort": {
        "returnType": "boolean",
        "params": [
          {
            "name": "lhs",
            "type": "any",
            "optional": false
          },
          {
            "name": "rhs",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "sort": {
        "returnType": "boolean",
        "params": [
          {
            "name": "{ inplace",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "filter": {
        "returnType": "this",
        "params": [
          {
            "name": "filter",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ inplace",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "exclude": {
        "returnType": "this",
        "params": [
          {
            "name": "keys",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ inplace",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      }
    },
    "AbilityScoreImprovementAdvancement": {
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_preCreate": {
        "returnType": "boolean",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "allowFeat": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "points": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "canImprove": {
        "returnType": "boolean",
        "params": [
          {
            "name": "ability",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "titleForLevel": {
        "returnType": "this",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "summaryForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "apply": {
        "returnType": "string",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "restore": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "reverse": {
        "returnType": "string",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get allowFeat": {
        "returnType": "string",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get points": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "AdvancementError": {},
    "HitPointsAdvancement": {
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "average": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "levels": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "hitDie": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "hitDieValue": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "configuredForLevel": {
        "returnType": "this",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "titleForLevel": {
        "returnType": "this",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          },
          {
            "name": "legacyDisplay",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "valueForLevel": {
        "returnType": "this",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static valueForLevel": {
        "returnType": "string",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "hitDieValue",
            "type": "any",
            "optional": false
          },
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "total": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getAdjustedTotal": {
        "returnType": "any",
        "params": [
          {
            "name": "mod",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static availableForItem": {
        "returnType": "any",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "getApplicableValue": {
        "returnType": "any",
        "params": [
          {
            "name": "value",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "apply": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "automaticApplicationValue": {
        "returnType": "boolean",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "restore": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "reverse": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get average": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get levels": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hitDie": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get hitDieValue": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ItemChoiceAdvancement": {
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "levels": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "configuredForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "titleForLevel": {
        "returnType": "this",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "summaryForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "storagePath": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "apply": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ replace: original",
            "type": "any",
            "optional": false
          },
          {
            "name": "...data }",
            "type": "any",
            "optional": false
          },
          {
            "name": "retainedData",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "automaticApplicationValue": {
        "returnType": "boolean",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "restore": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "reverse": {
        "returnType": "string",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_validateItemType": {
        "returnType": "boolean",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ type",
            "type": "any",
            "optional": false
          },
          {
            "name": "restriction",
            "type": "any",
            "optional": false
          },
          {
            "name": "strict",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get levels": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ItemGrantAdvancement": {
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "configuredForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "summaryForLevel": {
        "returnType": "this",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "storagePath": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "apply": {
        "returnType": "any[]",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "retainedData",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "automaticApplicationValue": {
        "returnType": "boolean",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "restore": {
        "returnType": "Record<string, any>",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "reverse": {
        "returnType": "any[]",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_validateItemType": {
        "returnType": "boolean",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ strict",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ScaleValueAdvancement": {
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static localize": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "levels": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "identifier": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "titleForLevel": {
        "returnType": "this",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          },
          {
            "name": "legacyDisplay",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "valueForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "testEquality": {
        "returnType": "boolean",
        "params": [
          {
            "name": "a",
            "type": "any",
            "optional": false
          },
          {
            "name": "b",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "automaticApplicationValue": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getContextMenuOptions": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get levels": {
        "returnType": "number",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get identifier": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SizeAdvancement": {
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "automaticHint": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "levels": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "summaryForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static availableForItem": {
        "returnType": "any",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "apply": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "automaticApplicationValue": {
        "returnType": "boolean",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "restore": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "reverse": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get automaticHint": {
        "returnType": "number",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get levels": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SubclassAdvancement": {
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "configuredForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "summaryforLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "static availableForItem": {
        "returnType": "any",
        "params": [
          {
            "name": "item",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "apply": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          },
          {
            "name": "retainedData",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "restore": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "reverse": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "TraitAdvancement": {
      "metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "static localize": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "maxTraits": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "prepareData": {
        "returnType": "number",
        "params": [],
        "isStatic": false
      },
      "configuredForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "sortingValueForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "levels",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "summaryForLevel": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "{ configMode",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "apply": {
        "returnType": "string",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "automaticApplicationValue": {
        "returnType": "boolean",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "restore": {
        "returnType": "any",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          },
          {
            "name": "data",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "reverse": {
        "returnType": "string",
        "params": [
          {
            "name": "level",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "actorSelected": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "representedTraits": {
        "returnType": "any",
        "params": [
          {
            "name": "pools",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "availableChoices": {
        "returnType": "number",
        "params": [
          {
            "name": "chosen",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "unfulfilledChoices": {
        "returnType": "any",
        "params": [
          {
            "name": "chosen",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get metadata": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get maxTraits": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ChatMessage5e": {
      "canApplyDamage": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "canSelectTargets": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "isRoll": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "shouldDisplayChallenge": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "static migrateData": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "prepareData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getHTML": {
        "returnType": "string",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_collapseTrays": {
        "returnType": "boolean",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_displayChatActionButtons": {
        "returnType": "boolean",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_highlightCriticalSuccessFailure": {
        "returnType": "boolean",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "makeIcon": {
        "returnType": "any",
        "params": [
          {
            "name": "cls",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_enrichChatCard": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_enrichRollTooltip": {
        "returnType": "any",
        "params": [
          {
            "name": "roll",
            "type": "any",
            "optional": false
          },
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_enrichAttackTargets": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_enrichDamageTooltip": {
        "returnType": "any",
        "params": [
          {
            "name": "rolls",
            "type": "any",
            "optional": false
          },
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_simplifyDamageRoll": {
        "returnType": "boolean",
        "params": [
          {
            "name": "roll",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_enrichEnchantmentTooltip": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_enrichSaveTooltip": {
        "returnType": "string",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_enrichUsageEffects": {
        "returnType": "string",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static addChatMessageContextOptions": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "_activateActivityListeners": {
        "returnType": "any",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onTargetMouseDown": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onTargetHoverIn": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onTargetHoverOut": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "applyChatCardDamage": {
        "returnType": "any",
        "params": [
          {
            "name": "li",
            "type": "any",
            "optional": false
          },
          {
            "name": "multiplier",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "selectTargets": {
        "returnType": "any",
        "params": [
          {
            "name": "li",
            "type": "any",
            "optional": false
          },
          {
            "name": "type",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "applyChatCardTemp": {
        "returnType": "any",
        "params": [
          {
            "name": "li",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onClickDiceRoll": {
        "returnType": "any",
        "params": [
          {
            "name": "event",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static onRenderChatPopout": {
        "returnType": "string",
        "params": [
          {
            "name": "app",
            "type": "any",
            "optional": false
          },
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static onRenderChatLog": {
        "returnType": "string",
        "params": [
          {
            "name": "html",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static activateListeners": {
        "returnType": "any",
        "params": [],
        "isStatic": true
      },
      "static toggleModifiers": {
        "returnType": "string",
        "params": [
          {
            "name": "{ releaseAll",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": true
      },
      "_onDelete": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getAssociatedActivity": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "getAssociatedActor": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getAssociatedItem": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "getAssociatedRolls": {
        "returnType": "any",
        "params": [
          {
            "name": "type",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getOriginatingMessage": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_shimFlags": {
        "returnType": "string",
        "params": [],
        "isStatic": false
      },
      "defineProperty": {
        "returnType": "any",
        "params": [
          {
            "name": "flags.use",
            "type": "any",
            "optional": false
          },
          {
            "name": "\"type\"",
            "type": "any",
            "optional": false
          },
          {
            "name": "{\n        get(",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get canApplyDamage": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get canSelectTargets": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get isRoll": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get shouldDisplayChallenge": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "Combat5e": {
      "startCombat": {
        "returnType": "Set<string>",
        "params": [],
        "isStatic": false
      },
      "endCombat": {
        "returnType": "Set<string>",
        "params": [],
        "isStatic": false
      },
      "rollAll": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "rollNPC": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "rollInitiative": {
        "returnType": "Set<string>",
        "params": [
          {
            "name": "ids",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "_sortCombatants": {
        "returnType": "any",
        "params": [
          {
            "name": "a",
            "type": "any",
            "optional": false
          },
          {
            "name": "b",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onUpdate": {
        "returnType": "any",
        "params": [
          {
            "name": "changed",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onDelete": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onEndTurn": {
        "returnType": "Set<string>",
        "params": [
          {
            "name": "combatant",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onStartTurn": {
        "returnType": "Set<string>",
        "params": [
          {
            "name": "combatant",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "createGroups": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_recoverUses": {
        "returnType": "boolean",
        "params": [
          {
            "name": "types",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "Combatant5e": {
      "createTurnMessage": {
        "returnType": "any",
        "params": [
          {
            "name": "{ deltas",
            "type": "any",
            "optional": false
          },
          {
            "name": "periods",
            "type": "any",
            "optional": false
          },
          {
            "name": "rolls }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "getGroupingKey": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "getInitiativeRoll": {
        "returnType": "this",
        "params": [
          {
            "name": "formula",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "recoverCombatUses": {
        "returnType": "boolean",
        "params": [
          {
            "name": "periods",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "refreshDynamicRing": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_onDelete": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          },
          {
            "name": "userId",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onUpdateOperation": {
        "returnType": "ChatMessage5e|void",
        "params": [
          {
            "name": "documents",
            "type": "any",
            "optional": false
          },
          {
            "name": "operation",
            "type": "any",
            "optional": false
          },
          {
            "name": "user",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      }
    },
    "JournalEntryPage5e": {
      "getRollData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      }
    },
    "SystemFlags": {
      "_systemFlagsDataModel": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "prepareData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "setFlag": {
        "returnType": "typeof DataModel|null",
        "params": [
          {
            "name": "scope",
            "type": "any",
            "optional": false
          },
          {
            "name": "key",
            "type": "any",
            "optional": false
          },
          {
            "name": "value",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "get _systemFlagsDataModel": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "PseudoDocument": {
      "metadata": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "documentConfig": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "documentName": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "id": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "relativeID": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "uuid": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "item": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "sheet": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "render": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static _registerApp": {
        "returnType": "any",
        "params": [
          {
            "name": "doc",
            "type": "any",
            "optional": false
          },
          {
            "name": "app",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static _unregisterApp": {
        "returnType": "any",
        "params": [
          {
            "name": "doc",
            "type": "any",
            "optional": false
          },
          {
            "name": "app",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "update": {
        "returnType": "any",
        "params": [
          {
            "name": "updates",
            "type": "any",
            "optional": false
          },
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "updateSource": {
        "returnType": "this",
        "params": [
          {
            "name": "updates",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "delete": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "deleteDialog": {
        "returnType": "any",
        "params": [
          {
            "name": "options",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "toDragData": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "createDialog": {
        "returnType": "any",
        "params": [
          {
            "name": "data",
            "type": "any",
            "optional": true
          },
          {
            "name": "{ parent",
            "type": "any",
            "optional": false
          },
          {
            "name": "types",
            "type": "any",
            "optional": true
          },
          {
            "name": "...options }",
            "type": "any",
            "optional": true
          }
        ],
        "isStatic": false
      },
      "get metadata": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "static get documentConfig": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get documentConfig": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "static get documentName": {
        "returnType": "this",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get documentName": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get id": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get relativeID": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get uuid": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get item": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get actor": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get sheet": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "Scaling": {
      "increase": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "value": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "toString": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "get increase": {
        "returnType": "number",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get value": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "ModuleArt": {
      "registerModuleArt": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "catch": {
        "returnType": "any",
        "params": [
          {
            "name": "e",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "parseArtMapping": {
        "returnType": "any",
        "params": [
          {
            "name": "moduleId",
            "type": "any",
            "optional": false
          },
          {
            "name": "mapping",
            "type": "any",
            "optional": false
          },
          {
            "name": "credit",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "apply": {
        "returnType": "any",
        "params": [
          {
            "name": "index",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static getModuleArtPath": {
        "returnType": "any",
        "params": [
          {
            "name": "module",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static getArtModules": {
        "returnType": "any[]",
        "params": [],
        "isStatic": true
      }
    },
    "EnchantmentRegisty": {
      "static applied": {
        "returnType": "any",
        "params": [
          {
            "name": "uuid",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static track": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "enchanted",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static untrack": {
        "returnType": "any",
        "params": [
          {
            "name": "source",
            "type": "any",
            "optional": false
          },
          {
            "name": "enchanted",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "ItemRegistry": {
      "choices": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "options": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "get": {
        "returnType": "this",
        "params": [
          {
            "name": "identifier",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "initialize": {
        "returnType": "boolean",
        "params": [],
        "isStatic": false
      },
      "get choices": {
        "returnType": "this",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get options": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "MessageRegistry": {
      "static get": {
        "returnType": "any",
        "params": [
          {
            "name": "origin",
            "type": "any",
            "optional": false
          },
          {
            "name": "type",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static track": {
        "returnType": "any",
        "params": [
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static untrack": {
        "returnType": "any",
        "params": [
          {
            "name": "message",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "SpellListRegistry": {
      "options": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "ready": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "static forSpell": {
        "returnType": "any",
        "params": [
          {
            "name": "uuid",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static forType": {
        "returnType": "any",
        "params": [
          {
            "name": "type",
            "type": "any",
            "optional": false
          },
          {
            "name": "identifier",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "register": {
        "returnType": "any",
        "params": [
          {
            "name": "uuid",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static get options": {
        "returnType": "any",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      },
      "static get ready": {
        "returnType": "this",
        "params": [],
        "isStatic": true,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SpellList": {
      "indexes": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "metadata": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "name": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "uuids": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "contribute": {
        "returnType": "any",
        "params": [
          {
            "name": "page",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "getSpells": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "get indexes": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get metadata": {
        "returnType": "Map<string, Set<string>>",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get name": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      },
      "get uuids": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    },
    "SummonRegistry": {
      "static creatures": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static track": {
        "returnType": "any",
        "params": [
          {
            "name": "summoner",
            "type": "any",
            "optional": false
          },
          {
            "name": "summoned",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      },
      "static untrack": {
        "returnType": "any",
        "params": [
          {
            "name": "summoner",
            "type": "any",
            "optional": false
          },
          {
            "name": "summoned",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": true
      }
    },
    "Tooltips5e": {
      "tooltip": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "observe": {
        "returnType": "any",
        "params": [],
        "isStatic": false
      },
      "_onMutation": {
        "returnType": "boolean",
        "params": [
          {
            "name": "mutationList",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onTooltipActivate": {
        "returnType": "this",
        "params": [],
        "isStatic": false
      },
      "_onHoverActor": {
        "returnType": "any",
        "params": [
          {
            "name": "actor",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onHoverContentLink": {
        "returnType": "any",
        "params": [
          {
            "name": "doc",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_onHoverPassive": {
        "returnType": "any",
        "params": [
          {
            "name": "skill",
            "type": "any",
            "optional": false
          },
          {
            "name": "ability",
            "type": "any",
            "optional": false
          },
          {
            "name": "dc",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "_positionItemTooltip": {
        "returnType": "any",
        "params": [
          {
            "name": "direction",
            "type": "any",
            "optional": false
          }
        ],
        "isStatic": false
      },
      "static activateListeners": {
        "returnType": "number",
        "params": [],
        "isStatic": true
      },
      "get tooltip": {
        "returnType": "any",
        "params": [],
        "isStatic": false,
        "isAccessor": true,
        "accessorType": "get"
      }
    }
  },
  "properties": {
    "Accordion": [
      "contentSelector",
      "config",
      "sections",
      "ongoing",
      "firstBind",
      "collapsed",
      "collapsedIndex",
      "content",
      "wrapper",
      "_fullHeight",
      "heading",
      "animate",
      "height",
      "onEnd",
      "entries",
      "i"
    ],
    "ActivityChoiceDialog": [
      "options",
      "item",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "controlHint",
      "activities",
      "activity",
      "resolve"
    ],
    "ActivitySheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "static CLEAN_ARRAYS",
      "tabGroups",
      "expandedSections",
      "tab",
      "data",
      "disabled",
      "activationTypes",
      "affectsPlaceholder",
      "durationUnits",
      "rangeUnits",
      "canScale",
      "consumptionTypeOptions",
      "consumptionTargets",
      "showTextTarget",
      "target",
      "type",
      "showConsumeSpellSlot",
      "showScaling",
      "recoveryPeriods",
      "recoveryTypes",
      "usesRecovery",
      "dimensions",
      "appliedEffects",
      "allEffects",
      "effect",
      "denominationOptions",
      "scaleKey",
      "scalingOptions",
      "typeOptions",
      "makePart",
      "damageParts",
      "placeholder",
      "active",
      "cssClass",
      "options",
      "primary",
      "types",
      "existingTypes",
      "filteredTypes",
      "effectData",
      "periods",
      "existingPeriods",
      "filteredPeriods",
      "consumption",
      "parts",
      "effectId",
      "result",
      "effects",
      "recovery",
      "submitData",
      "e"
    ],
    "ActivityUsageDialog": [
      "options",
      "activityId",
      "item",
      "config",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "used",
      "context",
      "hasConcentration",
      "notes",
      "fields",
      "existingConcentration",
      "optional",
      "containsLegendaryConsumption",
      "type",
      "value",
      "warn",
      "addResources",
      "isArray",
      "hasConsumption",
      "hasCreation",
      "template",
      "buttons",
      "hasScaling",
      "scale",
      "rollData",
      "max",
      "minimumLevel",
      "maximumLevel",
      "spellSlotOptions",
      "_",
      "spellSlots",
      "consumeSlot",
      "spellSlotValue",
      "label",
      "disabled",
      "o",
      "scaling",
      "display",
      "submitData",
      "formData",
      "level",
      "resources",
      "dialog",
      "event"
    ],
    "AttackSheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "availableAbilities",
      "abilityOptions",
      "hasBaseDamage",
      "attackTypeOptions",
      "t",
      "attackClassificationOptions"
    ],
    "CastSheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "contentLink",
      "levelOptions",
      "abilityOptions",
      "propertyOptions",
      "placeholder",
      "tabs",
      "label",
      "icon"
    ],
    "CheckSheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "group",
      "abilityOptions",
      "associated",
      "type",
      "size",
      "label",
      "associatedOptions",
      "calculationOptions"
    ],
    "DamageSheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS"
    ],
    "EnchantSheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "tabGroups",
      "activityOptions",
      "effectOptions",
      "context",
      "appliedEnchantments",
      "allEnchantments",
      "enchantableTypes",
      "typeOptions",
      "type",
      "typeDataModel",
      "categoryOptions",
      "propertyOptions",
      "tabs",
      "label",
      "icon"
    ],
    "EnchantUsageDialog": [
      "static PARTS",
      "context",
      "enchantments",
      "hasCreation",
      "enchantment"
    ],
    "ForwardSheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "showConsumeSpellSlot",
      "showScaling",
      "activityOptions"
    ],
    "HealSheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "typeOptions",
      "scaleKey",
      "scalingOptions"
    ],
    "OrderUsageDialog": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "build",
      "costs",
      "craft",
      "order",
      "value",
      "quantity",
      "baseItem",
      "item",
      "sizes",
      "index",
      "description",
      "days",
      "buttons",
      "config",
      "duration",
      "context",
      "trade",
      "isSelling",
      "max",
      "label",
      "stock",
      "sell",
      "buy",
      "uuid",
      "removable",
      "doc",
      "creatures",
      "data",
      "recalculateCosts",
      "submitData",
      "gold",
      "k"
    ],
    "SaveSheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "additionalSettings",
      "context",
      "abilityOptions",
      "calculationOptions",
      "onSaveOptions"
    ],
    "SummonSheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "static CLEAN_ARRAYS",
      "tabGroups",
      "context",
      "abilityOptions",
      "creatureSizeOptions",
      "creatureTypeOptions",
      "profileModes",
      "profiles",
      "tabs",
      "label",
      "icon",
      "data",
      "actor",
      "profileId",
      "profile",
      "uuid"
    ],
    "SummonUsageDialog": [
      "static PARTS",
      "context",
      "profiles",
      "hasCreation",
      "summonsFields",
      "rollData",
      "options",
      "o",
      "summonsProfile",
      "value",
      "label",
      "cr",
      "doc",
      "count"
    ],
    "UtilitySheet": [
      "static DEFAULT_OPTIONS",
      "static PARTS"
    ],
    "BaseConfigSheet": [
      "static DEFAULT_OPTIONS",
      "context",
      "advantageModeOptions",
      "name",
      "tooltip"
    ],
    "ActorSheet5eCharacter": [
      "options",
      "resources",
      "value",
      "max",
      "classes",
      "c",
      "inventory",
      "inventoryTypes",
      "ctx",
      "isStack",
      "attunement",
      "isExpanded",
      "hasRecharge",
      "hasUses",
      "concealDetails",
      "ungroup",
      "group",
      "type",
      "totalWeight",
      "spellbook",
      "nPrepared",
      "mode",
      "maxLevelDelta",
      "availableLevels",
      "label",
      "prefixedImage",
      "identifier",
      "subclass",
      "subclassAdvancement",
      "needsSubclass",
      "message",
      "features",
      "inventoryFilters",
      "preparedSpells",
      "isAlways",
      "isPrepared",
      "toggleClass",
      "toggleTitle",
      "isActive",
      "canToggle",
      "action",
      "button",
      "levels",
      "err",
      "cls",
      "priorLevel",
      "manager"
    ],
    "AbilityConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "proficiencyOptions"
    ],
    "ArmorClassConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "data",
      "fields",
      "source",
      "calculationOptions",
      "value",
      "config",
      "formula",
      "dexterity",
      "calculations",
      "item",
      "val",
      "key"
    ],
    "BaseProficiencyConfig": [
      "static DEFAULT_OPTIONS",
      "options",
      "uniqueId",
      "context",
      "source",
      "keyPath",
      "data",
      "fields",
      "label",
      "prefix",
      "global"
    ],
    "ConcentrationConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "source",
      "data",
      "fields",
      "ability",
      "abilityOptions",
      "global"
    ],
    "DamagesConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "bypasses",
      "value",
      "trait",
      "bypassHint",
      "hint",
      "field",
      "key",
      "input",
      "categoryChosen",
      "config",
      "icon",
      "submitData"
    ],
    "DeathConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "source",
      "data",
      "fields",
      "global"
    ],
    "HabitatConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "config",
      "value",
      "any",
      "custom",
      "habitats",
      "checked",
      "rows",
      "submitData",
      "entry",
      "subtype"
    ],
    "HitDiceConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "classes",
      "valueField",
      "action",
      "submitData",
      "classUpdates"
    ],
    "HitPointsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "data",
      "fields",
      "source",
      "ability",
      "mod",
      "classes",
      "effects",
      "e",
      "levels",
      "levelMultiplier",
      "showCalculation",
      "showMaxInCalculation",
      "roll",
      "clone",
      "maxDelta",
      "current",
      "hitDie"
    ],
    "InitiativeConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "source",
      "defaultAbility",
      "abilityOptions",
      "data",
      "fields",
      "ability",
      "abilityConfig",
      "flags"
    ],
    "LanguagesConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "unitOptions",
      "communication"
    ],
    "SkillToolConfig": [
      "static PARTS",
      "trait",
      "context",
      "abilityOptions",
      "proficiencyOptions",
      "section",
      "skill"
    ],
    "SkillsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "skills",
      "rows",
      "categoryChosen",
      "skill",
      "value",
      "total",
      "tooltip",
      "e"
    ],
    "SpellSlotsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "source",
      "overrides",
      "hasSpell"
    ],
    "ToolsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "categoryChosen",
      "tool",
      "hasEntry",
      "value",
      "total",
      "tooltip",
      "e",
      "submitData",
      "config"
    ],
    "TraitsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "options",
      "uniqueId",
      "context",
      "keyPath",
      "data",
      "checkbox",
      "chosen",
      "choices",
      "fields",
      "other",
      "OTHER",
      "categoryChosen",
      "disabled",
      "submitData"
    ],
    "TreasureConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "config",
      "any",
      "treasure"
    ],
    "WeaponsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "categoryChosen",
      "mastery",
      "submitData"
    ],
    "ActorAbilityConfig": [],
    "ActorArmorConfig": [],
    "ActorConcentrationConfig": [],
    "DamageModificationConfig": [
      "options"
    ],
    "ActorHitDiceConfig": [],
    "ActorHitPointsConfig": [],
    "ActorInitiativeConfig": [],
    "ActorMovementConfig": [],
    "ProficiencyConfig": [
      "trait"
    ],
    "ActorSensesConfig": [],
    "ActorSkillsConfig": [
      "options"
    ],
    "ActorSpellSlotsConfig": [],
    "ToolSelector": [
      "options"
    ],
    "TraitSelector": [
      "options"
    ],
    "ActorTypeConfig": [
      "options",
      "keyPath"
    ],
    "ActorSheet5eNPC": [
      "context",
      "cr",
      "crLabels",
      "classSpellcasting",
      "features",
      "maxLevelDelta",
      "ctx",
      "isStack",
      "isExpanded",
      "hasRecharge",
      "hasUses",
      "hasTarget",
      "canToggle",
      "totalWeight",
      "isPassive",
      "group",
      "ungroup",
      "type",
      "label",
      "spellbook",
      "inventoryFilters",
      "ac",
      "calc",
      "action",
      "button",
      "editor",
      "initial",
      "crs",
      "crv"
    ],
    "BaseRestDialog": [
      "options",
      "actor",
      "config",
      "static DEFAULT_OPTIONS",
      "duration",
      "rested",
      "context",
      "app"
    ],
    "LongRestDialog": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "options"
    ],
    "ShortRestDialog": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "autoRoll",
      "type",
      "hitDice",
      "denomination",
      "denom",
      "options"
    ],
    "ActorSheetFlags": [
      "data",
      "actor",
      "classes",
      "flags",
      "bonuses",
      "type",
      "baseData",
      "flag",
      "isCheckbox",
      "isSelect",
      "value",
      "src",
      "updateData"
    ],
    "ActorSheet5eVehicle": [
      "static unsupportedItemTypes",
      "largestPrimary",
      "isCrewed",
      "toggleClass",
      "toggleTitle",
      "type",
      "cover",
      "cargoColumns",
      "equipmentColumns",
      "features",
      "item",
      "ctx",
      "canToggle",
      "isExpanded",
      "hasUses",
      "cargo",
      "isCargo",
      "act",
      "inventoryFilters",
      "encumbrance",
      "tab",
      "evt",
      "target",
      "row",
      "idx",
      "property",
      "entry",
      "key",
      "value",
      "detail",
      "cargoCollection",
      "cargoTypes"
    ],
    "AbilityScoreImprovementConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "abilities",
      "fixed",
      "locked",
      "points",
      "action",
      "input",
      "parent",
      "value"
    ],
    "AbilityScoreImprovementFlow": [
      "assignments",
      "static _customElements",
      "featUuid",
      "feat",
      "points",
      "available",
      "formatter",
      "lockImprovement",
      "abilities",
      "ability",
      "assignment",
      "fixed",
      "locked",
      "value",
      "max",
      "min",
      "modernRules",
      "pluralRules",
      "action",
      "input",
      "name",
      "key",
      "filters",
      "result",
      "uuid",
      "item",
      "data"
    ],
    "AdvancementConfig": [
      "advancement",
      "options",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "levels",
      "label",
      "context",
      "uuidToDelete",
      "items",
      "updates",
      "configuration",
      "keep",
      "data",
      "item",
      "existingItems",
      "uuid",
      "i",
      "advancementId",
      "type",
      "action",
      "force"
    ],
    "AdvancementConfirmationDialog": [
      "class",
      "dialog"
    ],
    "AdvancementFlow": [
      "options",
      "item",
      "_advancementId",
      "level",
      "retainedData",
      "static _customElements"
    ],
    "AdvancementManager": [
      "options",
      "actor",
      "clone",
      "visualizer",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "advancing",
      "parts",
      "item",
      "level",
      "visibleSteps",
      "visibleIndex",
      "stepIndex",
      "steps",
      "nextIndex",
      "clonedItem",
      "currentLevel",
      "minimumLevel",
      "oldFlows",
      "flow",
      "advancementArray",
      "a",
      "value",
      "newFlows",
      "dataClone",
      "_id",
      "type",
      "targetLevel",
      "l",
      "flows",
      "f",
      "advancement",
      "raceItem",
      "pushSteps",
      "getItemFlows",
      "offset",
      "classLevel",
      "characterLevel",
      "stepData",
      "context",
      "forced",
      "allowed",
      "automaticData",
      "_element",
      "class",
      "disabled",
      "preEmbeddedItems",
      "automatic",
      "initialIds",
      "preIds",
      "postIds",
      "addedIds",
      "deletedIds",
      "handledLevel",
      "idx",
      "thisLevel",
      "nextLevel",
      "render",
      "modifiedIds",
      "restart",
      "s",
      "updates",
      "items",
      "id",
      "i"
    ],
    "AdvancementVisualizer": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "steps"
    ],
    "AdvancementMigrationDialog": [
      "advancementContext",
      "dialog"
    ],
    "AdvancementSelection": [
      "dialogData",
      "item",
      "context",
      "advancement",
      "types",
      "submit",
      "disabled",
      "config",
      "type"
    ],
    "HitPointsFlow": [
      "source",
      "value",
      "useAverage",
      "lastValue",
      "level",
      "event",
      "disabled",
      "roll",
      "errorType"
    ],
    "ItemChoiceConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "items",
      "abilityOptions",
      "choices",
      "levelRestrictionOptions",
      "showContainerWarning",
      "showSpellConfig",
      "showRequireSpellSlot",
      "typeOptions",
      "type",
      "typeRestriction",
      "pool"
    ],
    "ItemChoiceFlow": [
      "replacement",
      "selected",
      "context",
      "i",
      "dropped",
      "uuid",
      "item",
      "levelConfig",
      "max",
      "replaceable",
      "noReplacement",
      "choices",
      "previousLevels",
      "previouslySelected",
      "added",
      "id",
      "replaced",
      "match",
      "items",
      "disabled",
      "validLevel",
      "available",
      "abilities",
      "tagName",
      "type",
      "name",
      "uuidToDelete",
      "data",
      "spellLevel",
      "spellcasting",
      "progression",
      "maxSpellLevel",
      "spells"
    ],
    "ItemGrantConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "items",
      "abilityOptions",
      "showContainerWarning",
      "showSpellConfig",
      "showRequireSpellSlot"
    ],
    "ItemGrantFlow": [
      "config",
      "added",
      "checked",
      "i",
      "optional",
      "options",
      "uuid",
      "item",
      "retainedData"
    ],
    "ScaleValueConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "config",
      "type",
      "distanceOptions",
      "identifier",
      "hint",
      "levels",
      "lastValue",
      "value",
      "className",
      "name",
      "slug",
      "k",
      "scale",
      "typeChange",
      "OriginalType",
      "NewType",
      "original"
    ],
    "ScaleValueFlow": [],
    "SizeConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "sizes"
    ],
    "SizeFlow": [
      "sizes",
      "size"
    ],
    "SubclassFlow": [
      "uuid",
      "subclass",
      "context",
      "action",
      "filters",
      "result",
      "item",
      "data"
    ],
    "TraitConfig": [
      "selected",
      "trait",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "pool",
      "context",
      "grants",
      "choices",
      "chosen",
      "count",
      "selectedIndex",
      "rep",
      "disableAllowReplacements",
      "traitConfig",
      "title",
      "icon",
      "hint",
      "mode",
      "toCheck",
      "i",
      "input",
      "name",
      "types",
      "validTraitTypes",
      "configuration",
      "prefix",
      "filteredSelected",
      "current",
      "filteredPrevious",
      "c",
      "checkKey"
    ],
    "TraitFlow": [
      "available",
      "s",
      "addedTrait",
      "tag",
      "chosen",
      "existingChosen",
      "set",
      "size",
      "config",
      "count",
      "selectorShown",
      "slots",
      "i",
      "key"
    ],
    "Dialog5e": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "tag",
      "context",
      "partId",
      "buttons"
    ],
    "PseudoDocumentSheet": [
      "options",
      "documentId",
      "documentType",
      "item",
      "static DEFAULT_OPTIONS",
      "frame",
      "autocomplete",
      "copyLabel",
      "copyId",
      "id",
      "type",
      "label",
      "submitData",
      "input",
      "updateData",
      "event",
      "formData"
    ],
    "Award": [
      "_options",
      "origin",
      "options",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "primaryParty",
      "u",
      "value",
      "context",
      "currency",
      "destinations",
      "each",
      "hideXP",
      "noPrimaryParty",
      "xp",
      "icons",
      "doc",
      "formData",
      "data",
      "valid",
      "name",
      "results",
      "target",
      "config",
      "originCurrency",
      "remainingDestinations",
      "destinationUpdates",
      "result",
      "amount",
      "originUpdate",
      "perDestination",
      "cls",
      "messages",
      "entries",
      "label",
      "class",
      "content",
      "whisperTargets",
      "whisper",
      "messageData",
      "static COMMAND_PATTERN",
      "static VALUE_PATTERN",
      "roll",
      "savedDestinations",
      "app",
      "command",
      "party",
      "unrecognized",
      "part"
    ],
    "BastionConfig": [],
    "CompendiumBrowserSourceConfig": [],
    "CompendiumBrowser": [
      "filters",
      "_mode",
      "isAdvanced",
      "tab",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "static TABS",
      "static MODES",
      "static BATCHING",
      "static SEARCH_DELAY",
      "source",
      "resultIndex",
      "renderThrottle",
      "selected",
      "max",
      "min",
      "_debouncedSearch",
      "context",
      "dataModels",
      "filterDefinitions",
      "k",
      "value",
      "displaySelection",
      "invalid",
      "suffix",
      "summary",
      "showModeToggle",
      "isLocked",
      "types",
      "documentClass",
      "partId",
      "sort",
      "results",
      "tabs",
      "advanced",
      "activeTab",
      "active",
      "frame",
      "action",
      "subtitle",
      "html",
      "template",
      "innerHTML",
      "element",
      "tooltip",
      "tooltipClass",
      "rendered",
      "batchEnd",
      "i",
      "hidden",
      "part",
      "sources",
      "id",
      "locked",
      "filter",
      "options",
      "target",
      "event",
      "group",
      "children",
      "e",
      "indeterminate",
      "checked",
      "name",
      "handler",
      "batchStart",
      "input",
      "pr",
      "existingValue",
      "tagName",
      "indexFields",
      "documents",
      "sortFunc",
      "def",
      "choices",
      "_blank",
      "v",
      "button",
      "type",
      "headerActions",
      "className",
      "final",
      "secondConfig",
      "finalConfig"
    ],
    "AdoptedStyleSheetElement": [
      "static _stylesheets",
      "static CSS",
      "sheet"
    ],
    "ChatTrayElement": [
      "static observedAttributes",
      "name",
      "popout",
      "height"
    ],
    "CopyableTextElement": [
      "controller",
      "button",
      "ariaLabel",
      "tooltip",
      "innerHTML",
      "value"
    ],
    "EffectsElement": [
      "app",
      "event",
      "MenuCls",
      "element",
      "menuItems",
      "options",
      "identified",
      "type",
      "hidden",
      "localizationPrefix",
      "isConcentrationEffect",
      "uuid",
      "isFavorited",
      "class",
      "action",
      "dataset",
      "effect",
      "existing",
      "li",
      "isActor",
      "isEnchantment",
      "effectType",
      "doc"
    ],
    "EnchantmentApplicationElement": [
      "messageId",
      "chatMessage",
      "div",
      "innerHTML",
      "dropArea",
      "item",
      "scaling",
      "activity",
      "maxTargets",
      "countArea",
      "enchantedItems",
      "enchantmentUuid",
      "control",
      "ariaLabel",
      "action",
      "tooltip",
      "innerText",
      "data",
      "effect",
      "droppedItem",
      "errors",
      "err",
      "concentrationId",
      "concentration",
      "effectData",
      "origin",
      "applied",
      "enchantment"
    ],
    "InventoryElement": [
      "app",
      "action",
      "type",
      "inputmode",
      "event",
      "e",
      "MenuCls",
      "filterLists",
      "state",
      "set",
      "filters",
      "f",
      "items",
      "elementMap",
      "el",
      "hidden",
      "compendiumLocked",
      "options",
      "li",
      "class",
      "mode",
      "uuid",
      "isFavorited",
      "expanded",
      "itemId",
      "item",
      "min",
      "max",
      "value",
      "input",
      "activity",
      "result",
      "name",
      "button",
      "inventoryEvent",
      "itemData",
      "summary",
      "chatData",
      "menuItems"
    ],
    "ItemListControlsElement": [
      "app",
      "list",
      "state",
      "tab",
      "debouncedFilter",
      "static SORT_MODES",
      "static FILTER_DEBOUNCE_MS",
      "sortMode",
      "options",
      "search",
      "innerHTML",
      "controls",
      "item",
      "option",
      "groupLabel",
      "_inputElement",
      "_filterItems",
      "_controls",
      "el",
      "value",
      "className",
      "tooltip",
      "entries",
      "elementMap",
      "hidden",
      "group",
      "sections",
      "section",
      "items",
      "element",
      "itemPreparationMode",
      "target",
      "filter",
      "flag",
      "current",
      "action",
      "index",
      "name"
    ],
    "SlideToggleElement": [
      "role",
      "static tagName",
      "static useShadowRoot",
      "track",
      "thumb"
    ],
    "TargetedApplicationElement": [
      "selectedTokensHook",
      "pressed",
      "mode",
      "toPress",
      "currentlyPressed",
      "ariaPressed",
      "targetSourceControl",
      "innerHTML",
      "b",
      "hidden",
      "targetList",
      "targetedTokens",
      "t",
      "targets",
      "li",
      "innerText",
      "targetingMode"
    ],
    "CurrencyManager": [
      "_options",
      "document",
      "options",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "tabGroups",
      "destinations",
      "actor",
      "b",
      "primaryParty",
      "context",
      "currency",
      "tabs",
      "tab",
      "primary",
      "action",
      "input",
      "value",
      "formData",
      "data",
      "valid",
      "name",
      "currencies",
      "basis",
      "amount",
      "recursive",
      "updates",
      "priority",
      "baseConversion",
      "multiplier",
      "deduct"
    ],
    "AttackRollConfigurationDialog": [
      "static DEFAULT_OPTIONS",
      "context",
      "optionsFields",
      "fields"
    ],
    "D20RollConfigurationDialog": [
      "defaultButton",
      "advantage",
      "disadvantage",
      "advantageMode",
      "buttons",
      "action",
      "roll"
    ],
    "DamageRollConfigurationDialog": [
      "static PARTS",
      "allowCritical",
      "defaultCritical",
      "buttons",
      "context",
      "allTypes",
      "rolls",
      "_",
      "config",
      "damageType",
      "type",
      "roll"
    ],
    "RollConfigurationDialog": [
      "config",
      "message",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "dice",
      "shouldDisplay",
      "identifyTerm",
      "i",
      "identifyDice",
      "roll",
      "byDenom",
      "context",
      "buttons",
      "fields",
      "rolls",
      "RollType",
      "situational",
      "v",
      "rollMode",
      "formData",
      "options"
    ],
    "SkillToolRollConfigurationDialog": [
      "static DEFAULT_OPTIONS",
      "context",
      "name",
      "ability",
      "abilityLabel",
      "flavor"
    ],
    "ContainerSheet": [
      "_expanded",
      "options",
      "items",
      "capacity",
      "itemContext",
      "ctx",
      "totalWeight",
      "isExpanded",
      "isStack",
      "expanded",
      "isContainer",
      "inventory",
      "li",
      "item",
      "dragData",
      "data",
      "type",
      "folder",
      "recursiveWarning",
      "parentContainers",
      "containers",
      "container",
      "uuid",
      "toCreate",
      "d",
      "behavior",
      "created",
      "dropTarget",
      "contents",
      "target",
      "id",
      "siblings",
      "siblingId",
      "sortUpdates",
      "updateData",
      "_id"
    ],
    "CreateScrollDialog": [
      "options",
      "config",
      "spell",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "anchor",
      "fields",
      "values",
      "valuePlaceholders",
      "level",
      "formData",
      "event"
    ],
    "EnchantmentConfig": [],
    "StartingEquipmentConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "processEntry",
      "children",
      "type",
      "showRequireProficiency",
      "entries",
      "options",
      "submitData",
      "startingEquipment",
      "highestSort",
      "deleteIds",
      "getDeleteIds",
      "c",
      "i",
      "entry",
      "box",
      "data",
      "uuid",
      "item",
      "closestDrop",
      "entryType",
      "dropArea",
      "dragEntry",
      "dropEntry",
      "_id",
      "depth",
      "updateData",
      "target",
      "group",
      "sortBefore",
      "sortedEntries",
      "siblings",
      "sortUpdates"
    ],
    "SummoningConfig": [],
    "JournalEditor": [
      "_options",
      "options",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "rawText"
    ],
    "SpellsUnlinkedConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "submitData",
      "unlinkedSpells",
      "editing"
    ],
    "DragDropApplication": [
      "data",
      "dropEffect",
      "allowed",
      "behavior",
      "type"
    ],
    "PropertyAttribution": [
      "options",
      "object",
      "attributions",
      "property",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "total",
      "sources",
      "entry",
      "mode",
      "value",
      "parts"
    ],
    "BaseSettingsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "fields",
      "buttons",
      "setting",
      "Field",
      "data",
      "type",
      "options"
    ],
    "BastionSettingsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "fields",
      "source"
    ],
    "CombatSettingsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "fields",
      "legend"
    ],
    "CompendiumBrowserSettingsConfig": [
      "selected",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "static FILTER_DELAY",
      "filter",
      "_debouncedFilter",
      "sources",
      "byPackage",
      "packageType",
      "entry",
      "packages",
      "world",
      "system",
      "modules",
      "id",
      "module",
      "packs",
      "all",
      "indeterminate",
      "documentName",
      "partId",
      "query",
      "item",
      "name",
      "pkg",
      "setting",
      "input",
      "value"
    ],
    "ModuleArtSettingsConfig": [
      "object",
      "options",
      "config",
      "settings",
      "action",
      "item",
      "id",
      "configs",
      "key",
      "idx",
      "sortBefore",
      "target",
      "updates",
      "value"
    ],
    "VariantRulesSettingsConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "fields",
      "legend"
    ],
    "VisibilitySettingsConfig": [
      "static DEFAULT_OPTIONS",
      "context",
      "fields"
    ],
    "CreatureTypeConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "source",
      "data",
      "fields",
      "keyPath",
      "swarmOptions",
      "typeOptions",
      "custom",
      "rows",
      "preview"
    ],
    "MovementSensesConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "keyPath",
      "type",
      "options",
      "uniqueId",
      "context",
      "source",
      "placeholderData",
      "data",
      "fields",
      "extras",
      "types",
      "unitsOptions"
    ],
    "SourceConfig": [
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "context",
      "source",
      "buttons",
      "data",
      "fields",
      "keyPath",
      "sourceUuid",
      "sourceAnchor",
      "rulesVersions",
      "identifier"
    ],
    "TokenPlacement": [
      "config",
      "currentPlacement",
      "moveTime",
      "throttle",
      "placement",
      "placements",
      "total",
      "uniqueTokens",
      "obj",
      "eventMode",
      "actorId",
      "index",
      "previews",
      "tokenData",
      "enabled",
      "_id",
      "src",
      "cls",
      "doc",
      "p",
      "events",
      "oncontextmenu",
      "onwheel",
      "idx",
      "preview",
      "clone",
      "local",
      "x",
      "y",
      "dest",
      "delta",
      "snap",
      "regex",
      "match",
      "name"
    ],
    "ActorDataModel": [
      "static metadata",
      "primaryParty",
      "destinations",
      "scale",
      "deterministic",
      "prof"
    ],
    "ItemDataModel": [
      "static metadata",
      "static ITEM_TOOLTIP_TEMPLATE",
      "sourceId",
      "enrichmentOptions",
      "rollData",
      "isIdentified",
      "chat",
      "description",
      "uses",
      "price",
      "subtitle",
      "context",
      "properties",
      "hasProperties",
      "baseItem",
      "gold",
      "valueInGP",
      "base",
      "costs",
      "deterministic",
      "data"
    ],
    "AttackActivityData": [
      "ability",
      "availableAbilities",
      "size",
      "abilities",
      "type",
      "value",
      "labels",
      "reach",
      "classification",
      "melee",
      "ranged",
      "threshold",
      "sourceType",
      "damageParts",
      "hasBase",
      "parts",
      "part",
      "basePart",
      "base",
      "locked",
      "roll",
      "modifier",
      "formula",
      "toHit",
      "key",
      "attackModeLabel",
      "actionType",
      "actionTypeLabel",
      "isLegacy",
      "isUnarmed",
      "isSpell",
      "weaponType",
      "weaponTypeLabel",
      "config",
      "weapon",
      "ammo",
      "properties",
      "basePartIndex",
      "damage",
      "rollData",
      "range",
      "_",
      "index",
      "attackMode",
      "types",
      "includeMod",
      "p",
      "magicalBonus",
      "ammoBonus",
      "criticalBonusDice"
    ],
    "CastActivityData": [
      "schema",
      "spell",
      "name",
      "img"
    ],
    "CheckActivityData": [
      "calculation",
      "ability",
      "value",
      "type"
    ],
    "DamageActivityData": [
      "part",
      "config"
    ],
    "EnchantActivityData": [
      "keyPath",
      "level",
      "e",
      "effects"
    ],
    "AppliedEffectField": [
      "fields",
      "options",
      "item"
    ],
    "ConsumptionTargetsField": [
      "options"
    ],
    "ConsumptionError": [
      "name"
    ],
    "ForwardActivityData": [
      "schema"
    ],
    "HealActivityData": [
      "config",
      "rollConfig",
      "rollData",
      "rolls"
    ],
    "OrderActivityData": [
      "img"
    ],
    "SaveActivityData": [
      "calculation",
      "ability",
      "type",
      "onSave",
      "bonus",
      "value",
      "save",
      "config"
    ],
    "SummonActivityData": [
      "level",
      "e",
      "keyPath",
      "i"
    ],
    "UtilityActivityData": [],
    "CharacterData": [
      "static LOCALIZATION_PREFIXES",
      "static metadata",
      "static _systemType",
      "hd",
      "level",
      "value",
      "type",
      "prof",
      "max",
      "min",
      "required",
      "pct",
      "overflow",
      "boonsEarned",
      "progress",
      "rollData",
      "hpOptions",
      "bonus",
      "mod",
      "f",
      "maxSort",
      "favorites"
    ],
    "DamageTraitField": [
      "fields"
    ],
    "SimpleTraitField": [
      "fields"
    ],
    "NPCData": [
      "static LOCALIZATION_PREFIXES",
      "static metadata",
      "static _systemType",
      "value",
      "v",
      "custom",
      "source",
      "original",
      "type",
      "pattern",
      "match",
      "typeLc",
      "typeMatch",
      "subtype",
      "sizeLc",
      "sizeMatch",
      "swarm",
      "level",
      "max",
      "denomination",
      "lairAdjustment",
      "cr",
      "prof",
      "attributes",
      "rollData",
      "pct",
      "hpOptions",
      "label",
      "delta",
      "mode",
      "name",
      "pr",
      "rulesVersion",
      "i",
      "options",
      "context",
      "cite",
      "anchor",
      "template",
      "innerHTML",
      "formatter",
      "prepareMeasured",
      "prepareTrait",
      "prepared",
      "k",
      "entries",
      "category",
      "trait",
      "data",
      "list",
      "t",
      "description",
      "identifier",
      "openingTag",
      "uses",
      "key"
    ],
    "AttributesFields": [
      "init",
      "bonus",
      "ac",
      "armor",
      "shield",
      "min",
      "encumbrance",
      "multipliers",
      "bonuses",
      "cfg",
      "calc",
      "flat",
      "value",
      "base",
      "formula",
      "armorData",
      "isHeavy",
      "dex",
      "equippedArmor",
      "replaced",
      "equippedShield",
      "cover",
      "abilityId",
      "ability",
      "save",
      "config",
      "baseUnits",
      "unitSystem",
      "weight",
      "currency",
      "numCoins",
      "currencyPerWeight",
      "keys",
      "index",
      "sizeConfig",
      "sizeMod",
      "calculateThreshold",
      "multiplier",
      "threshold",
      "type",
      "thresholds",
      "max",
      "mod",
      "stops",
      "pct",
      "encumbered",
      "exhaustion",
      "level",
      "options",
      "effectiveMax",
      "damage",
      "flags",
      "globalCheckBonus",
      "isLegacy",
      "prof",
      "joat",
      "ra",
      "alert",
      "initBonus",
      "abilityBonus",
      "total",
      "score",
      "statuses",
      "noMovement",
      "halfMovement",
      "heavilyEncumbered",
      "exceedingCarryingCapacity",
      "crawl",
      "units",
      "reduction",
      "speed",
      "hover",
      "special",
      "abilityLabel",
      "attack",
      "dc"
    ],
    "CreatureTemplate": [
      "ability",
      "levels",
      "original",
      "pattern",
      "wasMatched",
      "s",
      "match",
      "type",
      "special",
      "validProf",
      "options",
      "globalCheckBonus",
      "globalSkillBonus",
      "flags",
      "abilityData",
      "baseBonus",
      "value",
      "checkBonusAbl",
      "effectValue",
      "bonus",
      "mod",
      "prof",
      "total",
      "passive",
      "passiveBonus",
      "deterministic",
      "classes",
      "hitDice",
      "subclass"
    ],
    "DetailsField": [],
    "TraitsField": [
      "schemaOptions",
      "languages",
      "labels",
      "processCategory",
      "topLevel",
      "data",
      "custom",
      "type"
    ],
    "VehicleData": [
      "static LOCALIZATION_PREFIXES",
      "static _systemType",
      "custom",
      "source",
      "prof",
      "calc",
      "rollData",
      "item"
    ],
    "AbilityScoreImprovementValueData": [],
    "BaseAdvancement": [
      "v",
      "hint"
    ],
    "ScaleValueTypeNumber": [
      "value"
    ],
    "ScaleValueTypeCR": [
      "static LOCALIZATION_PREFIXES"
    ],
    "ScaleValueTypeDice": [
      "static LOCALIZATION_PREFIXES",
      "static FACES",
      "number",
      "faces",
      "fields",
      "options",
      "name"
    ],
    "ScaleValueTypeDistance": [],
    "ActivationsField": [
      "i",
      "uuid"
    ],
    "ActorDeltasField": [
      "deltas",
      "rolls"
    ],
    "IndividualDeltaField": [
      "updates",
      "deltas",
      "currentValue",
      "delta",
      "rolls",
      "value",
      "roll"
    ],
    "RestMessageData": [
      "static metadata",
      "context",
      "activities",
      "deltas"
    ],
    "TurnMessageData": [
      "static metadata",
      "context",
      "activities",
      "deltas"
    ],
    "ActivitiesField": [
      "activities"
    ],
    "ActivityCollection": [
      "model",
      "types",
      "key",
      "source"
    ],
    "EnchantmentField": [
      "options"
    ],
    "EnchantmentError": [
      "name"
    ],
    "SpellcastingField": [
      "fields",
      "max",
      "type",
      "actor",
      "levels",
      "ability",
      "mod",
      "modProf",
      "msak",
      "rsak",
      "attack",
      "save"
    ],
    "SummonsField": [
      "options"
    ],
    "ActionTemplate": [
      "ability",
      "bonus",
      "critical",
      "damage",
      "scaling",
      "dc",
      "ammoThreshold",
      "threshold",
      "actionType",
      "data",
      "key",
      "mod"
    ],
    "ActivatedEffectTemplate": [
      "static ItemUsesField",
      "value",
      "units",
      "rollData",
      "duration",
      "concentrationDuration",
      "activation",
      "target",
      "range",
      "recharge",
      "item",
      "property",
      "formula",
      "roll",
      "message",
      "max",
      "long",
      "type",
      "amount",
      "consume"
    ],
    "ItemUsesField": [
      "value",
      "units",
      "rollData",
      "duration",
      "concentrationDuration",
      "activation",
      "target",
      "range",
      "recharge",
      "item",
      "property",
      "formula",
      "roll",
      "message",
      "max",
      "long",
      "type",
      "amount",
      "consume"
    ],
    "ActivitiesTemplate": [
      "static LOCALIZATION_PREFIXES",
      "activity",
      "a",
      "max",
      "charged",
      "spent",
      "per",
      "recovery",
      "uses",
      "type",
      "cls",
      "labels",
      "updates",
      "rolls",
      "autoRecharge",
      "shouldRecharge",
      "recharge",
      "message",
      "result",
      "spells",
      "cloneChanges",
      "riders",
      "effect",
      "removed",
      "_",
      "cachedInserts",
      "existingSpell",
      "enchantment",
      "cached",
      "spellIds",
      "shim",
      "addShims",
      "firstActivity",
      "d",
      "activation",
      "consumption",
      "target",
      "consume"
    ],
    "EquippableItemTemplate": [
      "value",
      "filter",
      "attuned",
      "attunement",
      "equipped",
      "type"
    ],
    "IdentifiableTemplate": [
      "description",
      "name",
      "fetchName",
      "fetchDesc",
      "baseItem"
    ],
    "ItemDescriptionTemplate": [
      "source",
      "uuid"
    ],
    "ItemTypeTemplate": [
      "oldType"
    ],
    "MountableTemplate": [],
    "PhysicalItemTemplate": [
      "static MAX_DEPTH",
      "hasPrice",
      "multiplier",
      "valueInGP",
      "price",
      "rarity",
      "weight",
      "options",
      "c",
      "a",
      "former",
      "formerContainer",
      "item",
      "depth",
      "containers",
      "container",
      "w"
    ],
    "StartingEquipmentTemplate": [
      "topLevel",
      "e"
    ],
    "ActivationField": [
      "fields",
      "scalar",
      "value",
      "activation"
    ],
    "CurrencyTemplate": [
      "count",
      "currencyPerWeight"
    ],
    "DamageField": [],
    "DurationField": [
      "fields",
      "scalar",
      "value",
      "duration",
      "concentrationDuration"
    ],
    "RangeField": [
      "fields",
      "scalar",
      "value",
      "range",
      "rangeParts"
    ],
    "SourceField": [
      "fields",
      "pkg",
      "bookPlaceholder",
      "book",
      "label",
      "page",
      "value",
      "slug",
      "sourceBooks",
      "keys",
      "pack",
      "source"
    ],
    "TargetField": [
      "fields",
      "scalar",
      "count",
      "dimensions",
      "size",
      "width",
      "height",
      "pr",
      "templateConfig",
      "parts",
      "label",
      "affectsConfig",
      "labels",
      "target",
      "sizes"
    ],
    "UsesField": [
      "fields",
      "value",
      "periods",
      "period",
      "type",
      "recharge",
      "config",
      "recovery",
      "label",
      "min",
      "max",
      "updates",
      "rolls",
      "item",
      "delta",
      "roll",
      "total",
      "newSpent",
      "spent",
      "oldReturn",
      "apply",
      "rollConfig",
      "hookNames",
      "subject",
      "dialogConfig",
      "messageConfig",
      "hookData",
      "data",
      "target",
      "create",
      "flavor"
    ],
    "BasicRoll": [
      "static DefaultConfigurationDialog",
      "formula",
      "data",
      "config",
      "configure",
      "DialogClass",
      "rolls",
      "rollType",
      "roll",
      "name",
      "messageId",
      "document",
      "create",
      "messageData",
      "cls",
      "msg",
      "options",
      "terms",
      "number",
      "preCalculateOptions",
      "currentModifiers",
      "keep",
      "drop",
      "validModifiers",
      "matchedModifier",
      "rgx",
      "match",
      "command",
      "amount",
      "n",
      "_number",
      "f",
      "_faces",
      "flavor",
      "other"
    ],
    "D20Die": [
      "number",
      "static CRITICAL_SUCCESS_TOTAL",
      "static CRITICAL_FAILURE_TOTAL",
      "faces",
      "advantageMode",
      "m",
      "isAdvantage",
      "flag",
      "index",
      "mod"
    ],
    "D20Roll": [
      "static ADV_MODE",
      "static DefaultConfigurationDialog",
      "formula",
      "newRoll",
      "keys",
      "k",
      "advantage",
      "disadvantage",
      "advantageMode",
      "rtLabel",
      "r",
      "minimum",
      "elvenAccuracy",
      "halflingLucky",
      "criticalSuccess",
      "criticalFailure",
      "target",
      "configured",
      "defaultAction",
      "DialogClass",
      "defaultButton"
    ],
    "DamageRoll": [
      "static DefaultConfigurationDialog",
      "config",
      "critical",
      "keys",
      "k",
      "isCritical",
      "nextTerm",
      "prevTerm",
      "formula",
      "newTerm",
      "term",
      "newFormula",
      "deleteCount",
      "preprocessed",
      "options",
      "flatBonus",
      "baseNumber",
      "number",
      "cm",
      "bonus",
      "flavor",
      "cb",
      "extra",
      "configured",
      "allowCritical",
      "data",
      "DialogClass",
      "r"
    ],
    "ActiveEffect5e": [
      "static ID",
      "static FORMULA_FIELDS",
      "static LOCALIZATION_PREFIXES",
      "type",
      "id",
      "isSuppressed",
      "description",
      "options",
      "change",
      "field",
      "changes",
      "apply",
      "activity",
      "current",
      "modes",
      "mode",
      "mappingField",
      "keyPath",
      "created",
      "handle",
      "item",
      "data",
      "initialValue",
      "value",
      "config",
      "level",
      "img",
      "name",
      "s",
      "riders",
      "r",
      "createRider",
      "effect",
      "effectData",
      "_",
      "message",
      "profile",
      "origin",
      "riderActivities",
      "riderEffects",
      "activityData",
      "_id",
      "createdActivities",
      "a",
      "createdEffects",
      "createdItems",
      "riderItems",
      "activityId",
      "keepOrigin",
      "errors",
      "err",
      "userId",
      "originalLevel",
      "newLevel",
      "originalEncumbrance",
      "newEncumbrance",
      "increase",
      "dependents",
      "user",
      "uuid",
      "statusEffect",
      "html",
      "element",
      "tab",
      "actor",
      "elem",
      "objectPosition",
      "background",
      "split",
      "ext",
      "path",
      "button",
      "max",
      "size",
      "choices",
      "content",
      "source",
      "d",
      "delta",
      "enrichmentOptions",
      "p",
      "dialogOptions"
    ],
    "SourcedItemsMap": [
      "remap"
    ],
    "Bastion": [
      "static ATTACK_TEMPLATE",
      "static TURN_TEMPLATE",
      "haveBastions",
      "duration",
      "order",
      "gold",
      "content",
      "value",
      "newProgress",
      "updates",
      "summary",
      "roll",
      "deaths",
      "defenders",
      "undefended",
      "event",
      "actor",
      "el",
      "item",
      "draggable",
      "sizes",
      "index",
      "operation",
      "sold",
      "allDefenders",
      "results",
      "gp",
      "claimed",
      "slain",
      "i",
      "a",
      "special",
      "damaged",
      "resolved",
      "context",
      "plurals",
      "key",
      "description",
      "buttons",
      "class",
      "facility",
      "items",
      "_",
      "orders",
      "supplements",
      "proceed",
      "turnButton",
      "v12",
      "type",
      "formula"
    ],
    "BastionAttackDialog": [
      "actor",
      "static DEFAULT_OPTIONS",
      "static PARTS",
      "formula",
      "context",
      "options",
      "resolve"
    ],
    "HitDice": [
      "actor",
      "value",
      "max",
      "sizes",
      "classes",
      "bySize",
      "hd",
      "cls",
      "fraction",
      "updateItems",
      "recovered",
      "used",
      "delta"
    ],
    "Proficiency": [
      "roundDown",
      "multiplier",
      "rounding",
      "deterministic",
      "roundMethod",
      "_baseProficiency",
      "roundTerm",
      "updates"
    ],
    "SelectChoices": [
      "choices",
      "category",
      "children",
      "newData",
      "clone",
      "k",
      "result",
      "options",
      "sorting",
      "inplace",
      "filter",
      "wildcardKey"
    ],
    "AbilityScoreImprovementAdvancement": [
      "type",
      "configMode",
      "entries",
      "name",
      "class",
      "feat",
      "updates",
      "ability",
      "source",
      "assignments",
      "itemData",
      "featUuid",
      "item",
      "retainedItems"
    ],
    "AdvancementError": [
      "name"
    ],
    "HitPointsAdvancement": [
      "type",
      "configMode",
      "value",
      "abilityId",
      "level",
      "source"
    ],
    "ItemChoiceAdvancement": [
      "configMode",
      "tag",
      "retainedData",
      "updates",
      "replacedLevel",
      "original",
      "items",
      "replaced",
      "uuid",
      "itemData",
      "type",
      "strict",
      "subtype",
      "errorLabel",
      "l"
    ],
    "ItemGrantAdvancement": [
      "static VALID_TYPES",
      "configMode",
      "id",
      "retainedData",
      "updates",
      "itemData",
      "type",
      "i",
      "items",
      "keyPath",
      "item",
      "strict"
    ],
    "ScaleValueAdvancement": [
      "static TYPES",
      "v",
      "l",
      "configMode",
      "key",
      "data",
      "TypeClass",
      "keys",
      "options",
      "class"
    ],
    "SizeAdvancement": [
      "size",
      "listFormatter",
      "s",
      "configMode"
    ],
    "SubclassAdvancement": [
      "configMode",
      "useRetained",
      "itemData",
      "item"
    ],
    "TraitAdvancement": [
      "rep",
      "traitConfig",
      "title",
      "icon",
      "traitOrder",
      "modeOrder",
      "order",
      "configMode",
      "k",
      "updates",
      "keyPath",
      "existingValue",
      "mode",
      "toolId",
      "ability",
      "kp",
      "retainedData",
      "selected",
      "available",
      "traitTypes",
      "actorValues",
      "choices",
      "value",
      "category",
      "set",
      "c",
      "unfilteredLength",
      "size",
      "remainingSet",
      "actorData",
      "grant",
      "allChoices",
      "a"
    ],
    "ChatMessage5e": [
      "static TRAY_TYPES",
      "_highlighted",
      "type",
      "author",
      "source",
      "use",
      "itemData",
      "options",
      "element",
      "collapse",
      "chatCard",
      "flavor",
      "displayChallenge",
      "actor",
      "isCreator",
      "visibility",
      "originatingMessage",
      "displayAttackResult",
      "forceSuccess",
      "icon",
      "d0",
      "d20Roll",
      "d",
      "isModifiedRoll",
      "total",
      "canCrit",
      "isAttack",
      "showResult",
      "icons",
      "img",
      "nameText",
      "avatar",
      "uuid",
      "avatarImg",
      "name",
      "title",
      "subtitle",
      "innerText",
      "sender",
      "metadata",
      "deleteButton",
      "anchor",
      "contextMenu",
      "innerHTML",
      "el",
      "src",
      "roll",
      "item",
      "activity",
      "isCritical",
      "r",
      "constant",
      "sign",
      "part",
      "attackRoll",
      "masteryConfig",
      "p",
      "mastery",
      "isVisible",
      "targets",
      "tray",
      "evaluation",
      "rows",
      "isMiss",
      "li",
      "className",
      "missA",
      "missB",
      "target",
      "aggregatedRolls",
      "formula",
      "tooltipContents",
      "class",
      "damageOnSave",
      "damageApplication",
      "damages",
      "aggregate",
      "hasMultiplication",
      "i",
      "term",
      "value",
      "multiplier",
      "operator",
      "enchantmentProfile",
      "concentrationId",
      "enchantmentApplication",
      "afterElement",
      "content",
      "button",
      "effects",
      "effectApplication",
      "canApply",
      "canTarget",
      "token",
      "releaseOthers",
      "t",
      "lis",
      "uuids",
      "tokens",
      "html",
      "close",
      "tooltip",
      "gmUser",
      "releaseAll",
      "chatlog",
      "scene",
      "storedData",
      "flags",
      "messageType"
    ],
    "Combat5e": [
      "expandedGroups",
      "ids",
      "combatant",
      "initiative",
      "options",
      "name",
      "groups",
      "key",
      "periods"
    ],
    "Combatant5e": [
      "data",
      "create",
      "initiative",
      "results",
      "rollData",
      "updateTarget",
      "deltas",
      "message",
      "updates",
      "i",
      "update",
      "combatant"
    ],
    "JournalEntryPage5e": [],
    "SystemFlags": [
      "dnd5e",
      "scope",
      "changes",
      "diff"
    ],
    "PseudoDocument": [
      "parent",
      "static _apps",
      "static _sheets",
      "cls",
      "sheet",
      "options",
      "dragData",
      "uuid",
      "data",
      "label",
      "title",
      "type",
      "content",
      "html",
      "folder",
      "btn",
      "icon",
      "innerHTML",
      "tooltip",
      "fd",
      "createData"
    ],
    "Scaling": [
      "increase"
    ],
    "ModuleArt": [
      "suppressArt",
      "json",
      "settings",
      "pack",
      "entry",
      "img",
      "credit",
      "uuid",
      "info",
      "flags",
      "artPath",
      "unsorted",
      "configs",
      "mapping",
      "config",
      "priority",
      "maxPriority"
    ],
    "EnchantmentRegisty": [
      "appliedEnchantments",
      "source",
      "a",
      "uuid"
    ],
    "ItemRegistry": [
      "itemType",
      "items",
      "status",
      "STATUS_STATES",
      "initialized",
      "indexes",
      "identifier",
      "itemData",
      "name",
      "img"
    ],
    "MessageRegistry": [
      "messages",
      "originMap",
      "ids",
      "id",
      "origin",
      "type"
    ],
    "SpellListRegistry": [
      "bySpell",
      "byType",
      "loading",
      "lists",
      "size",
      "page",
      "type",
      "list",
      "uuid"
    ],
    "SpellList": [
      "metadata",
      "REGISTRIES",
      "s",
      "spells",
      "unlinked",
      "added"
    ],
    "SummonRegistry": [
      "creatures",
      "uuid"
    ],
    "Tooltips5e": [
      "observer",
      "isActive",
      "tooltip",
      "type",
      "doc",
      "loading",
      "innerHTML",
      "c",
      "skillConfig",
      "abilityConfig",
      "label",
      "party",
      "context",
      "systemData",
      "ability",
      "customSkillData",
      "passive",
      "abilityMod",
      "data",
      "status",
      "direction",
      "pos",
      "dirs",
      "description",
      "event"
    ]
  },
  "propertyDocs": {
    "Accordion": {
      "contentSelector": "",
      "config": "",
      "sections": "",
      "ongoing": "",
      "firstBind": "",
      "collapsed": "",
      "collapsedIndex": "",
      "content": "",
      "wrapper": "",
      "_fullHeight": "",
      "heading": "",
      "animate": "",
      "height": "",
      "onEnd": "",
      "entries": "",
      "i": ""
    },
    "ActivityChoiceDialog": {
      "options": "",
      "item": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "controlHint": "",
      "activities": "",
      "activity": "",
      "resolve": ""
    },
    "ActivitySheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "static CLEAN_ARRAYS": "",
      "tabGroups": "",
      "expandedSections": "",
      "tab": "",
      "data": "",
      "disabled": "",
      "activationTypes": "",
      "affectsPlaceholder": "",
      "durationUnits": "",
      "rangeUnits": "",
      "canScale": "",
      "consumptionTypeOptions": "",
      "consumptionTargets": "",
      "showTextTarget": "",
      "target": "",
      "type": "",
      "showConsumeSpellSlot": "",
      "showScaling": "",
      "recoveryPeriods": "",
      "recoveryTypes": "",
      "usesRecovery": "",
      "dimensions": "",
      "appliedEffects": "",
      "allEffects": "",
      "effect": "",
      "denominationOptions": "",
      "scaleKey": "",
      "scalingOptions": "",
      "typeOptions": "",
      "makePart": "",
      "damageParts": "",
      "placeholder": "",
      "active": "",
      "cssClass": "",
      "options": "",
      "primary": "",
      "types": "",
      "existingTypes": "",
      "filteredTypes": "",
      "effectData": "",
      "periods": "Default sheet for activities.\n/\nexport default class ActivitySheet extends PseudoDocumentSheet {\n  /** @inheritDoc */\n  static DEFAULT_OPTIONS = {\n    classes: [\"activity\"],\n    window: {\n      icon: \"fa-solid fa-gauge\"\n    },\n    actions: {\n      addConsumption: ActivitySheet.#addConsumption,\n      addDamagePart: ActivitySheet.#addDamagePart,\n      addEffect: ActivitySheet.#addEffect,\n      addRecovery: ActivitySheet.#addRecovery,\n      deleteConsumption: ActivitySheet.#deleteConsumption,\n      deleteDamagePart: ActivitySheet.#deleteDamagePart,\n      deleteEffect: ActivitySheet.#deleteEffect,\n      deleteRecovery: ActivitySheet.#deleteRecovery,\n      dissociateEffect: ActivitySheet.#dissociateEffect,\n      toggleCollapsed: ActivitySheet.#toggleCollapsed\n    },\n    position: {\n      width: 500,\n      height: \"auto\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    tabs: {\n      template: \"templates/generic/tab-navigation.hbs\"\n    },\n    identity: {\n      template: \"systems/dnd5e/templates/activity/identity.hbs\",\n      templates: [\n        \"systems/dnd5e/templates/activity/parts/activity-identity.hbs\"\n      ]\n    },\n    activation: {\n      template: \"systems/dnd5e/templates/activity/activation.hbs\",\n      templates: [\n        \"systems/dnd5e/templates/activity/parts/activity-time.hbs\",\n        \"systems/dnd5e/templates/activity/parts/activity-targeting.hbs\",\n        \"systems/dnd5e/templates/activity/parts/activity-consumption.hbs\"\n      ]\n    },\n    effect: {\n      template: \"systems/dnd5e/templates/activity/effect.hbs\",\n      templates: [\n        \"systems/dnd5e/templates/activity/parts/activity-effects.hbs\"\n      ]\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nKey paths to the parts of the submit data stored in arrays that will need special handling on submission.\n@type {string[]}\n/\n  static CLEAN_ARRAYS = [\"consumption.targets\", \"damage.parts\", \"effects\", \"uses.recovery\"];\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  tabGroups = {\n    sheet: \"identity\",\n    activation: \"time\"\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nThe Activity associated with this application.\n@type {Activity}\n/\n  get activity() {\n    return this.document;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nExpanded states for additional settings sections.\n@type {Map<string, boolean>}\n/\n  #expandedSections = new Map();\n\n  get expandedSections() {\n    return this.#expandedSections;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  get title() {\n    return this.activity.name;\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _prepareContext(options) {\n    return {\n      ...await super._prepareContext(options),\n      activity: this.activity,\n      fields: this.activity.schema.fields,\n      inferred: this.activity._inferredSource,\n      source: this.activity.toObject(),\n      tabs: this._getTabs()\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  async _preparePartContext(partId, context) {\n    switch ( partId ) {\n      case \"activation\": return this._prepareActivationContext(context);\n      case \"effect\": return this._prepareEffectContext(context);\n      case \"identity\": return this._prepareIdentityContext(context);\n    }\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare rendering context for the activation tab.\n@param {ApplicationRenderContext} context  Context being prepared.\n@returns {ApplicationRenderContext}\n@protected\n/\n  async _prepareActivationContext(context) {\n    context.tab = context.tabs.activation;\n\n    context.data = {};\n    context.disabled = {};\n    for ( const field of [\"activation\", \"duration\", \"range\", \"target\", \"uses\"] ) {\n      if ( !this.activity[field] ) continue;\n      context.data[field] = this.activity[field].override ? context.source[field] : context.inferred[field];\n      context.disabled[field] = this.activity[field].canOverride && !this.activity[field].override;\n    }\n\n    context.activationTypes = [\n      ...Object.entries(CONFIG.DND5E.activityActivationTypes).map(([value, config]) => ({\n        value,\n        label: game.i18n.localize(config.label),\n        group: game.i18n.localize(config.group)\n      })),\n      { value: \"\", label: game.i18n.localize(\"DND5E.NoneActionLabel\") }\n    ];\n    context.affectsPlaceholder = game.i18n.localize(\n      `DND5E.TARGET.Count.${context.data.target?.template?.type ? \"Every\" : \"Any\"}`\n    );\n    context.durationUnits = [\n      { value: \"inst\", label: game.i18n.localize(\"DND5E.TimeInst\") },\n      ...Object.entries(CONFIG.DND5E.scalarTimePeriods).map(([value, label]) => ({\n        value, label, group: game.i18n.localize(\"DND5E.DurationTime\")\n      })),\n      ...Object.entries(CONFIG.DND5E.permanentTimePeriods).map(([value, label]) => ({\n        value, label, group: game.i18n.localize(\"DND5E.DurationPermanent\")\n      })),\n      { value: \"spec\", label: game.i18n.localize(\"DND5E.Special\") }\n    ];\n    context.rangeUnits = [\n      ...Object.entries(CONFIG.DND5E.rangeTypes).map(([value, label]) => ({ value, label })),\n      ...Object.entries(CONFIG.DND5E.movementUnits).map(([value, { label }]) => ({\n        value, label, group: game.i18n.localize(\"DND5E.RangeDistance\")\n      }))\n    ];\n\n    // Consumption targets\n    const canScale = this.activity.canConfigureScaling;\n    const consumptionTypeOptions = Array.from(this.activity.validConsumptionTypes).map(value => ({\n      value,\n      label: CONFIG.DND5E.activityConsumptionTypes[value].label\n    }));\n    context.consumptionTargets = context.source.consumption.targets.map((data, index) => {\n      const typeConfig = CONFIG.DND5E.activityConsumptionTypes[data.type] ?? {};\n      const showTextTarget = typeConfig.targetRequiresEmbedded && !this.item.isEmbedded;\n      const target = new ConsumptionTargetData(data, { parent: this.activity });\n      return {\n        data,\n        fields: this.activity.schema.fields.consumption.fields.targets.element.fields,\n        prefix: `consumption.targets.${index}.`,\n        source: context.source.consumption.targets[index] ?? data,\n        typeOptions: consumptionTypeOptions,\n        scalingModes: canScale ? [\n          { value: \"\", label: game.i18n.localize(\"DND5E.CONSUMPTION.Scaling.None\") },\n          { value: \"amount\", label: game.i18n.localize(\"DND5E.CONSUMPTION.Scaling.Amount\") },\n          ...(typeConfig.scalingModes ?? []).map(({ value, label }) => ({ value, label: game.i18n.localize(label) }))\n        ] : null,\n        showTargets: \"validTargets\" in typeConfig,\n        selectedTarget: (\"validTargets\" in typeConfig) && ((data.type === \"Item\") && data.target?.includes(\".\"))\n          ? (this.activity.actor?.sourcedItems?.get(data.target, { legacy: false })?.first()?.id ?? data.target)\n          : data.target,\n        targetPlaceholder: data.type === \"itemUses\" ? game.i18n.localize(\"DND5E.CONSUMPTION.Target.ThisItem\") : null,\n        validTargets: showTextTarget ? null : target.validTargets\n      };\n    });\n    context.showConsumeSpellSlot = this.activity.isSpell && (this.item.system.level !== 0);\n    context.showScaling = !this.activity.isSpell;\n\n    // Uses recovery\n    context.recoveryPeriods = CONFIG.DND5E.limitedUsePeriods.recoveryOptions;\n    context.recoveryTypes = [\n      { value: \"recoverAll\", label: game.i18n.localize(\"DND5E.USES.Recovery.Type.RecoverAll\") },\n      { value: \"loseAll\", label: game.i18n.localize(\"DND5E.USES.Recovery.Type.LoseAll\") },\n      { value: \"formula\", label: game.i18n.localize(\"DND5E.USES.Recovery.Type.Formula\") }\n    ];\n    context.usesRecovery = context.source.uses.recovery.map((data, index) => ({\n      data,\n      fields: this.activity.schema.fields.uses.fields.recovery.element.fields,\n      prefix: `uses.recovery.${index}.`,\n      source: context.source.uses.recovery[index] ?? data,\n      formulaOptions: data.period === \"recharge\" ? UsesField.rechargeOptions : null\n    }));\n\n    // Template dimensions\n    context.dimensions = context.activity.target?.template?.dimensions;\n\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare a specific applied effect if present in the activity data.\n@param {ApplicationRenderContext} context  Context being prepared.\n@param {object} effect                     Applied effect context being prepared.\n@returns {object}\n@protected\n/\n  _prepareAppliedEffectContext(context, effect) {\n    return effect;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare a specific damage part if present in the activity data.\n@param {ApplicationRenderContext} context  Context being prepared.\n@param {object} part                       Damage part context being prepared.\n@returns {object}\n@protected\n/\n  _prepareDamagePartContext(context, part) {\n    return part;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare rendering context for the effect tab.\n@param {ApplicationRenderContext} context  Context being prepared.\n@returns {ApplicationRenderContext}\n@protected\n/\n  async _prepareEffectContext(context) {\n    context.tab = context.tabs.effect;\n\n    if ( context.activity.effects ) {\n      const appliedEffects = new Set(context.activity.effects?.map(e => e._id) ?? []);\n      context.allEffects = this.item.effects\n        .filter(e => e.type !== \"enchantment\")\n        .map(effect => ({\n          value: effect.id, label: effect.name, selected: appliedEffects.has(effect.id)\n        }));\n      context.appliedEffects = context.activity.effects.reduce((arr, data) => {\n        if ( !data.effect ) return arr;\n        const effect = {\n          data,\n          collapsed: this.expandedSections.get(`effects.${data._id}`) ? \"\" : \"collapsed\",\n          effect: data.effect,\n          fields: this.activity.schema.fields.effects.element.fields,\n          prefix: `effects.${data._index}.`,\n          source: context.source.effects[data._index] ?? data,\n          contentLink: data.effect.toAnchor().outerHTML,\n          additionalSettings: null\n        };\n        arr.push(this._prepareAppliedEffectContext(context, effect));\n        return arr;\n      }, []);\n    }\n\n    context.denominationOptions = [\n      { value: \"\", label: \"\" },\n      ...CONFIG.DND5E.dieSteps.map(value => ({ value, label: `d${value}` }))\n    ];\n    if ( context.activity.damage?.parts ) {\n      const scaleKey = (this.item.type === \"spell\") && (this.item.system.level === 0) ? \"labelCantrip\" : \"label\";\n      const scalingOptions = [\n        { value: \"\", label: game.i18n.localize(\"DND5E.DAMAGE.Scaling.None\") },\n        ...Object.entries(CONFIG.DND5E.damageScalingModes).map(([value, { [scaleKey]: label }]) => ({ value, label }))\n      ];\n      const typeOptions = Object.entries(CONFIG.DND5E.damageTypes).map(([value, { label }]) => ({ value, label }));\n      const makePart = (data, index) => this._prepareDamagePartContext(context, {\n        data, index, scalingOptions, typeOptions,\n        canScale: this.activity.canScaleDamage,\n        fields: this.activity.schema.fields.damage.fields.parts.element.fields,\n        prefix: index !== undefined ? `damage.parts.${index}.` : \"_.\",\n        source: data\n      });\n      context.damageParts = [\n        ...context.activity.damage.parts\n          .filter(p => p._index === undefined)\n          .map((data, index) => makePart(data)),\n        ...context.source.damage.parts.map((data, index) => makePart(data, index))\n      ];\n    }\n\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare rendering context for the identity tab.\n@param {ApplicationRenderContext} context  Context being prepared.\n@returns {ApplicationRenderContext}\n@protected\n/\n  async _prepareIdentityContext(context) {\n    context.tab = context.tabs.identity;\n    context.placeholder = {\n      name: game.i18n.localize(this.activity.metadata.title),\n      img: this.activity.metadata.img\n    };\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the tab information for the sheet.\n@returns {Record<string, Partial<ApplicationTab>>}\n@protected\n/\n  _getTabs() {\n    return this._markTabs({\n      identity: {\n        id: \"identity\", group: \"sheet\", icon: \"fa-solid fa-tag\",\n        label: \"DND5E.ACTIVITY.SECTIONS.Identity\"\n      },\n      activation: {\n        id: \"activation\", group: \"sheet\", icon: \"fa-solid fa-clapperboard\",\n        label: \"DND5E.ACTIVITY.SECTIONS.Activation\",\n        tabs: {\n          time: {\n            id: \"time\", group: \"activation\", icon: \"fa-solid fa-clock\",\n            label: \"DND5E.ACTIVITY.SECTIONS.Time\"\n          },\n          consumption: {\n            id: \"consumption\", group: \"activation\", icon: \"fa-solid fa-boxes-stacked\",\n            label: \"DND5E.CONSUMPTION.FIELDS.consumption.label\"\n          },\n          targeting: {\n            id: \"activation-targeting\", group: \"activation\", icon: \"fa-solid fa-bullseye\",\n            label: \"DND5E.TARGET.FIELDS.target.label\"\n          }\n        }\n      },\n      effect: {\n        id: \"effect\", group: \"sheet\", icon: \"fa-solid fa-sun\",\n        label: \"DND5E.ACTIVITY.SECTIONS.Effect\"\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHelper to mark the tabs data structure with the appropriate CSS class if it is active.\n@param {Record<string, Partial<ApplicationTab>>} tabs  Tabs definition to modify.\n@returns {Record<string, Partial<ApplicationTab>>}\n@internal\n/\n  _markTabs(tabs) {\n    for ( const v of Object.values(tabs) ) {\n      v.active = this.tabGroups[v.group] === v.id;\n      v.cssClass = v.active ? \"active\" : \"\";\n      if ( \"tabs\" in v ) this._markTabs(v.tabs);\n    }\n    return tabs;\n  }\n\n  /* -------------------------------------------- */\n  /*  Life-Cycle Handlers                         */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _onRender(context, options) {\n    super._onRender(context, options);\n    for ( const element of this.element.querySelectorAll(\"[data-expand-id]\") ) {\n      element.querySelector(\".collapsible\")?.classList\n        .toggle(\"collapsed\", !this.#expandedSections.get(element.dataset.expandId));\n    }\n    this.#toggleNestedTabs();\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers                */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  changeTab(tab, group, options={}) {\n    super.changeTab(tab, group, options);\n    if ( group !== \"sheet\" ) return;\n    this.#toggleNestedTabs();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nApply nested tab classes.\n/\n  #toggleNestedTabs() {\n    const primary = this.element.querySelector('.window-content > [data-application-part=\"tabs\"]');\n    const active = this.element.querySelector('.tab.active[data-group=\"sheet\"]');\n    if ( !primary || !active ) return;\n    primary.classList.toggle(\"nested-tabs\", active.querySelector(\":scope > .sheet-tabs\"));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle adding a new entry to the consumption list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static #addConsumption(event, target) {\n    const types = this.activity.validConsumptionTypes;\n    const existingTypes = new Set(this.activity.consumption.targets.map(t => t.type));\n    const filteredTypes = types.difference(existingTypes);\n    this.activity.update({\n      \"consumption.targets\": [\n        ...this.activity.toObject().consumption.targets,\n        { type: filteredTypes.first() ?? types.first() }\n      ]\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle adding a new entry to the damage parts list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static #addDamagePart(event, target) {\n    if ( !this.activity.damage?.parts ) return;\n    this.activity.update({ \"damage.parts\": [...this.activity.toObject().damage.parts, {}] });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle creating a new active effect and adding it to the applied effects list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static async #addEffect(event, target) {\n    if ( !this.activity.effects ) return;\n    const effectData = this._addEffectData();\n    const [created] = await this.item.createEmbeddedDocuments(\"ActiveEffect\", [effectData], { render: false });\n    this.activity.update({ effects: [...this.activity.toObject().effects, { _id: created.id }] });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe data for a newly created applied effect.\n@returns {object}\n@protected\n/\n  _addEffectData() {\n    return {\n      name: this.item.name,\n      img: this.item.img,\n      origin: this.item.uuid,\n      transfer: false\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle adding a new entry to the uses recovery list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.",
      "existingPeriods": "",
      "filteredPeriods": "",
      "consumption": "",
      "parts": "",
      "effectId": "",
      "result": "",
      "effects": "",
      "recovery": "",
      "submitData": "Default sheet for activities.\n/\nexport default class ActivitySheet extends PseudoDocumentSheet {\n  /** @inheritDoc */\n  static DEFAULT_OPTIONS = {\n    classes: [\"activity\"],\n    window: {\n      icon: \"fa-solid fa-gauge\"\n    },\n    actions: {\n      addConsumption: ActivitySheet.#addConsumption,\n      addDamagePart: ActivitySheet.#addDamagePart,\n      addEffect: ActivitySheet.#addEffect,\n      addRecovery: ActivitySheet.#addRecovery,\n      deleteConsumption: ActivitySheet.#deleteConsumption,\n      deleteDamagePart: ActivitySheet.#deleteDamagePart,\n      deleteEffect: ActivitySheet.#deleteEffect,\n      deleteRecovery: ActivitySheet.#deleteRecovery,\n      dissociateEffect: ActivitySheet.#dissociateEffect,\n      toggleCollapsed: ActivitySheet.#toggleCollapsed\n    },\n    position: {\n      width: 500,\n      height: \"auto\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    tabs: {\n      template: \"templates/generic/tab-navigation.hbs\"\n    },\n    identity: {\n      template: \"systems/dnd5e/templates/activity/identity.hbs\",\n      templates: [\n        \"systems/dnd5e/templates/activity/parts/activity-identity.hbs\"\n      ]\n    },\n    activation: {\n      template: \"systems/dnd5e/templates/activity/activation.hbs\",\n      templates: [\n        \"systems/dnd5e/templates/activity/parts/activity-time.hbs\",\n        \"systems/dnd5e/templates/activity/parts/activity-targeting.hbs\",\n        \"systems/dnd5e/templates/activity/parts/activity-consumption.hbs\"\n      ]\n    },\n    effect: {\n      template: \"systems/dnd5e/templates/activity/effect.hbs\",\n      templates: [\n        \"systems/dnd5e/templates/activity/parts/activity-effects.hbs\"\n      ]\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nKey paths to the parts of the submit data stored in arrays that will need special handling on submission.\n@type {string[]}\n/\n  static CLEAN_ARRAYS = [\"consumption.targets\", \"damage.parts\", \"effects\", \"uses.recovery\"];\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  tabGroups = {\n    sheet: \"identity\",\n    activation: \"time\"\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nThe Activity associated with this application.\n@type {Activity}\n/\n  get activity() {\n    return this.document;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nExpanded states for additional settings sections.\n@type {Map<string, boolean>}\n/\n  #expandedSections = new Map();\n\n  get expandedSections() {\n    return this.#expandedSections;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  get title() {\n    return this.activity.name;\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _prepareContext(options) {\n    return {\n      ...await super._prepareContext(options),\n      activity: this.activity,\n      fields: this.activity.schema.fields,\n      inferred: this.activity._inferredSource,\n      source: this.activity.toObject(),\n      tabs: this._getTabs()\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  async _preparePartContext(partId, context) {\n    switch ( partId ) {\n      case \"activation\": return this._prepareActivationContext(context);\n      case \"effect\": return this._prepareEffectContext(context);\n      case \"identity\": return this._prepareIdentityContext(context);\n    }\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare rendering context for the activation tab.\n@param {ApplicationRenderContext} context  Context being prepared.\n@returns {ApplicationRenderContext}\n@protected\n/\n  async _prepareActivationContext(context) {\n    context.tab = context.tabs.activation;\n\n    context.data = {};\n    context.disabled = {};\n    for ( const field of [\"activation\", \"duration\", \"range\", \"target\", \"uses\"] ) {\n      if ( !this.activity[field] ) continue;\n      context.data[field] = this.activity[field].override ? context.source[field] : context.inferred[field];\n      context.disabled[field] = this.activity[field].canOverride && !this.activity[field].override;\n    }\n\n    context.activationTypes = [\n      ...Object.entries(CONFIG.DND5E.activityActivationTypes).map(([value, config]) => ({\n        value,\n        label: game.i18n.localize(config.label),\n        group: game.i18n.localize(config.group)\n      })),\n      { value: \"\", label: game.i18n.localize(\"DND5E.NoneActionLabel\") }\n    ];\n    context.affectsPlaceholder = game.i18n.localize(\n      `DND5E.TARGET.Count.${context.data.target?.template?.type ? \"Every\" : \"Any\"}`\n    );\n    context.durationUnits = [\n      { value: \"inst\", label: game.i18n.localize(\"DND5E.TimeInst\") },\n      ...Object.entries(CONFIG.DND5E.scalarTimePeriods).map(([value, label]) => ({\n        value, label, group: game.i18n.localize(\"DND5E.DurationTime\")\n      })),\n      ...Object.entries(CONFIG.DND5E.permanentTimePeriods).map(([value, label]) => ({\n        value, label, group: game.i18n.localize(\"DND5E.DurationPermanent\")\n      })),\n      { value: \"spec\", label: game.i18n.localize(\"DND5E.Special\") }\n    ];\n    context.rangeUnits = [\n      ...Object.entries(CONFIG.DND5E.rangeTypes).map(([value, label]) => ({ value, label })),\n      ...Object.entries(CONFIG.DND5E.movementUnits).map(([value, { label }]) => ({\n        value, label, group: game.i18n.localize(\"DND5E.RangeDistance\")\n      }))\n    ];\n\n    // Consumption targets\n    const canScale = this.activity.canConfigureScaling;\n    const consumptionTypeOptions = Array.from(this.activity.validConsumptionTypes).map(value => ({\n      value,\n      label: CONFIG.DND5E.activityConsumptionTypes[value].label\n    }));\n    context.consumptionTargets = context.source.consumption.targets.map((data, index) => {\n      const typeConfig = CONFIG.DND5E.activityConsumptionTypes[data.type] ?? {};\n      const showTextTarget = typeConfig.targetRequiresEmbedded && !this.item.isEmbedded;\n      const target = new ConsumptionTargetData(data, { parent: this.activity });\n      return {\n        data,\n        fields: this.activity.schema.fields.consumption.fields.targets.element.fields,\n        prefix: `consumption.targets.${index}.`,\n        source: context.source.consumption.targets[index] ?? data,\n        typeOptions: consumptionTypeOptions,\n        scalingModes: canScale ? [\n          { value: \"\", label: game.i18n.localize(\"DND5E.CONSUMPTION.Scaling.None\") },\n          { value: \"amount\", label: game.i18n.localize(\"DND5E.CONSUMPTION.Scaling.Amount\") },\n          ...(typeConfig.scalingModes ?? []).map(({ value, label }) => ({ value, label: game.i18n.localize(label) }))\n        ] : null,\n        showTargets: \"validTargets\" in typeConfig,\n        selectedTarget: (\"validTargets\" in typeConfig) && ((data.type === \"Item\") && data.target?.includes(\".\"))\n          ? (this.activity.actor?.sourcedItems?.get(data.target, { legacy: false })?.first()?.id ?? data.target)\n          : data.target,\n        targetPlaceholder: data.type === \"itemUses\" ? game.i18n.localize(\"DND5E.CONSUMPTION.Target.ThisItem\") : null,\n        validTargets: showTextTarget ? null : target.validTargets\n      };\n    });\n    context.showConsumeSpellSlot = this.activity.isSpell && (this.item.system.level !== 0);\n    context.showScaling = !this.activity.isSpell;\n\n    // Uses recovery\n    context.recoveryPeriods = CONFIG.DND5E.limitedUsePeriods.recoveryOptions;\n    context.recoveryTypes = [\n      { value: \"recoverAll\", label: game.i18n.localize(\"DND5E.USES.Recovery.Type.RecoverAll\") },\n      { value: \"loseAll\", label: game.i18n.localize(\"DND5E.USES.Recovery.Type.LoseAll\") },\n      { value: \"formula\", label: game.i18n.localize(\"DND5E.USES.Recovery.Type.Formula\") }\n    ];\n    context.usesRecovery = context.source.uses.recovery.map((data, index) => ({\n      data,\n      fields: this.activity.schema.fields.uses.fields.recovery.element.fields,\n      prefix: `uses.recovery.${index}.`,\n      source: context.source.uses.recovery[index] ?? data,\n      formulaOptions: data.period === \"recharge\" ? UsesField.rechargeOptions : null\n    }));\n\n    // Template dimensions\n    context.dimensions = context.activity.target?.template?.dimensions;\n\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare a specific applied effect if present in the activity data.\n@param {ApplicationRenderContext} context  Context being prepared.\n@param {object} effect                     Applied effect context being prepared.\n@returns {object}\n@protected\n/\n  _prepareAppliedEffectContext(context, effect) {\n    return effect;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare a specific damage part if present in the activity data.\n@param {ApplicationRenderContext} context  Context being prepared.\n@param {object} part                       Damage part context being prepared.\n@returns {object}\n@protected\n/\n  _prepareDamagePartContext(context, part) {\n    return part;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare rendering context for the effect tab.\n@param {ApplicationRenderContext} context  Context being prepared.\n@returns {ApplicationRenderContext}\n@protected\n/\n  async _prepareEffectContext(context) {\n    context.tab = context.tabs.effect;\n\n    if ( context.activity.effects ) {\n      const appliedEffects = new Set(context.activity.effects?.map(e => e._id) ?? []);\n      context.allEffects = this.item.effects\n        .filter(e => e.type !== \"enchantment\")\n        .map(effect => ({\n          value: effect.id, label: effect.name, selected: appliedEffects.has(effect.id)\n        }));\n      context.appliedEffects = context.activity.effects.reduce((arr, data) => {\n        if ( !data.effect ) return arr;\n        const effect = {\n          data,\n          collapsed: this.expandedSections.get(`effects.${data._id}`) ? \"\" : \"collapsed\",\n          effect: data.effect,\n          fields: this.activity.schema.fields.effects.element.fields,\n          prefix: `effects.${data._index}.`,\n          source: context.source.effects[data._index] ?? data,\n          contentLink: data.effect.toAnchor().outerHTML,\n          additionalSettings: null\n        };\n        arr.push(this._prepareAppliedEffectContext(context, effect));\n        return arr;\n      }, []);\n    }\n\n    context.denominationOptions = [\n      { value: \"\", label: \"\" },\n      ...CONFIG.DND5E.dieSteps.map(value => ({ value, label: `d${value}` }))\n    ];\n    if ( context.activity.damage?.parts ) {\n      const scaleKey = (this.item.type === \"spell\") && (this.item.system.level === 0) ? \"labelCantrip\" : \"label\";\n      const scalingOptions = [\n        { value: \"\", label: game.i18n.localize(\"DND5E.DAMAGE.Scaling.None\") },\n        ...Object.entries(CONFIG.DND5E.damageScalingModes).map(([value, { [scaleKey]: label }]) => ({ value, label }))\n      ];\n      const typeOptions = Object.entries(CONFIG.DND5E.damageTypes).map(([value, { label }]) => ({ value, label }));\n      const makePart = (data, index) => this._prepareDamagePartContext(context, {\n        data, index, scalingOptions, typeOptions,\n        canScale: this.activity.canScaleDamage,\n        fields: this.activity.schema.fields.damage.fields.parts.element.fields,\n        prefix: index !== undefined ? `damage.parts.${index}.` : \"_.\",\n        source: data\n      });\n      context.damageParts = [\n        ...context.activity.damage.parts\n          .filter(p => p._index === undefined)\n          .map((data, index) => makePart(data)),\n        ...context.source.damage.parts.map((data, index) => makePart(data, index))\n      ];\n    }\n\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare rendering context for the identity tab.\n@param {ApplicationRenderContext} context  Context being prepared.\n@returns {ApplicationRenderContext}\n@protected\n/\n  async _prepareIdentityContext(context) {\n    context.tab = context.tabs.identity;\n    context.placeholder = {\n      name: game.i18n.localize(this.activity.metadata.title),\n      img: this.activity.metadata.img\n    };\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the tab information for the sheet.\n@returns {Record<string, Partial<ApplicationTab>>}\n@protected\n/\n  _getTabs() {\n    return this._markTabs({\n      identity: {\n        id: \"identity\", group: \"sheet\", icon: \"fa-solid fa-tag\",\n        label: \"DND5E.ACTIVITY.SECTIONS.Identity\"\n      },\n      activation: {\n        id: \"activation\", group: \"sheet\", icon: \"fa-solid fa-clapperboard\",\n        label: \"DND5E.ACTIVITY.SECTIONS.Activation\",\n        tabs: {\n          time: {\n            id: \"time\", group: \"activation\", icon: \"fa-solid fa-clock\",\n            label: \"DND5E.ACTIVITY.SECTIONS.Time\"\n          },\n          consumption: {\n            id: \"consumption\", group: \"activation\", icon: \"fa-solid fa-boxes-stacked\",\n            label: \"DND5E.CONSUMPTION.FIELDS.consumption.label\"\n          },\n          targeting: {\n            id: \"activation-targeting\", group: \"activation\", icon: \"fa-solid fa-bullseye\",\n            label: \"DND5E.TARGET.FIELDS.target.label\"\n          }\n        }\n      },\n      effect: {\n        id: \"effect\", group: \"sheet\", icon: \"fa-solid fa-sun\",\n        label: \"DND5E.ACTIVITY.SECTIONS.Effect\"\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHelper to mark the tabs data structure with the appropriate CSS class if it is active.\n@param {Record<string, Partial<ApplicationTab>>} tabs  Tabs definition to modify.\n@returns {Record<string, Partial<ApplicationTab>>}\n@internal\n/\n  _markTabs(tabs) {\n    for ( const v of Object.values(tabs) ) {\n      v.active = this.tabGroups[v.group] === v.id;\n      v.cssClass = v.active ? \"active\" : \"\";\n      if ( \"tabs\" in v ) this._markTabs(v.tabs);\n    }\n    return tabs;\n  }\n\n  /* -------------------------------------------- */\n  /*  Life-Cycle Handlers                         */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _onRender(context, options) {\n    super._onRender(context, options);\n    for ( const element of this.element.querySelectorAll(\"[data-expand-id]\") ) {\n      element.querySelector(\".collapsible\")?.classList\n        .toggle(\"collapsed\", !this.#expandedSections.get(element.dataset.expandId));\n    }\n    this.#toggleNestedTabs();\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers                */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  changeTab(tab, group, options={}) {\n    super.changeTab(tab, group, options);\n    if ( group !== \"sheet\" ) return;\n    this.#toggleNestedTabs();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nApply nested tab classes.\n/\n  #toggleNestedTabs() {\n    const primary = this.element.querySelector('.window-content > [data-application-part=\"tabs\"]');\n    const active = this.element.querySelector('.tab.active[data-group=\"sheet\"]');\n    if ( !primary || !active ) return;\n    primary.classList.toggle(\"nested-tabs\", active.querySelector(\":scope > .sheet-tabs\"));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle adding a new entry to the consumption list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static #addConsumption(event, target) {\n    const types = this.activity.validConsumptionTypes;\n    const existingTypes = new Set(this.activity.consumption.targets.map(t => t.type));\n    const filteredTypes = types.difference(existingTypes);\n    this.activity.update({\n      \"consumption.targets\": [\n        ...this.activity.toObject().consumption.targets,\n        { type: filteredTypes.first() ?? types.first() }\n      ]\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle adding a new entry to the damage parts list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static #addDamagePart(event, target) {\n    if ( !this.activity.damage?.parts ) return;\n    this.activity.update({ \"damage.parts\": [...this.activity.toObject().damage.parts, {}] });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle creating a new active effect and adding it to the applied effects list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static async #addEffect(event, target) {\n    if ( !this.activity.effects ) return;\n    const effectData = this._addEffectData();\n    const [created] = await this.item.createEmbeddedDocuments(\"ActiveEffect\", [effectData], { render: false });\n    this.activity.update({ effects: [...this.activity.toObject().effects, { _id: created.id }] });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe data for a newly created applied effect.\n@returns {object}\n@protected\n/\n  _addEffectData() {\n    return {\n      name: this.item.name,\n      img: this.item.img,\n      origin: this.item.uuid,\n      transfer: false\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle adding a new entry to the uses recovery list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static #addRecovery(event, target) {\n    const periods = new Set(\n      Object.entries(CONFIG.DND5E.limitedUsePeriods).filter(([, config]) => !config.deprecated).map(([k]) => k)\n    );\n    const existingPeriods = new Set(this.activity.uses.recovery.map(t => t.period));\n    const filteredPeriods = periods.difference(existingPeriods);\n    this.activity.update({\n      \"uses.recovery\": [\n        ...this.activity.toObject().uses.recovery,\n        { period: filteredPeriods.first() ?? periods.first() }\n      ]\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle removing an entry from the consumption targets list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static #deleteConsumption(event, target) {\n    const consumption = this.activity.toObject().consumption.targets;\n    consumption.splice(target.closest(\"[data-index]\").dataset.index, 1);\n    this.activity.update({ \"consumption.targets\": consumption });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle removing an entry from the damage parts list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static #deleteDamagePart(event, target) {\n    if ( !this.activity.damage?.parts ) return;\n    const parts = this.activity.toObject().damage.parts;\n    parts.splice(target.closest(\"[data-index]\").dataset.index, 1);\n    this.activity.update({ \"damage.parts\": parts });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle deleting an active effect and removing it from the applied effects list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static async #deleteEffect(event, target) {\n    if ( !this.activity.effects ) return;\n    const effectId = target.closest(\"[data-effect-id]\")?.dataset.effectId;\n    const result = await this.item.effects.get(effectId)?.deleteDialog({}, { render: false });\n    if ( result instanceof ActiveEffect ) {\n      const effects = this.activity.toObject().effects.filter(e => e._id !== effectId);\n      this.activity.update({ effects });\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle removing an entry from the uses recovery list.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static #deleteRecovery(event, target) {\n    const recovery = this.activity.toObject().uses.recovery;\n    recovery.splice(target.closest(\"[data-index]\").dataset.index, 1);\n    this.activity.update({ \"uses.recovery\": recovery });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle dissociating an Active Effect from this Activity.\n@this {ActivitySheet}\n@param {PointerEvent} event  The triggering click event.\n@param {HTMLElement} target  The button that was clicked.\n/\n  static #dissociateEffect(event, target) {\n    const { effectId } = target.closest(\"[data-effect-id]\")?.dataset ?? {};\n    if ( !this.activity.effects || !effectId ) return;\n    const effects = this.activity.toObject().effects.filter(e => e._id !== effectId);\n    this.activity.update({ effects });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle toggling the collapsed state of an additional settings section.\n@this {ActivitySheet}\n@param {Event} event         Triggering click event.\n@param {HTMLElement} target  Button that was clicked.\n/\n  static #toggleCollapsed(event, target) {\n    if ( event.target.closest(\".collapsible-content\") ) return;\n    target.classList.toggle(\"collapsed\");\n    this.#expandedSections.set(\n      target.closest(\"[data-expand-id]\")?.dataset.expandId,\n      !target.classList.contains(\"collapsed\")\n    );\n  }\n\n  /* -------------------------------------------- */\n  /*  Form Handling                               */\n  /* -------------------------------------------- */\n\n  /**\nPerform any pre-processing of the form data to prepare it for updating.\n@param {SubmitEvent} event          Triggering submit event.\n@param {FormDataExtended} formData  Data from the submitted form.\n@returns {object}",
      "e": ""
    },
    "ActivityUsageDialog": {
      "options": "",
      "activityId": "",
      "item": "",
      "config": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "used": "",
      "context": "",
      "hasConcentration": "",
      "notes": "",
      "fields": "",
      "existingConcentration": "",
      "optional": "",
      "containsLegendaryConsumption": "",
      "type": "",
      "value": "",
      "warn": "",
      "addResources": "",
      "isArray": "",
      "hasConsumption": "",
      "hasCreation": "",
      "template": "",
      "buttons": "",
      "hasScaling": "",
      "scale": "",
      "rollData": "",
      "max": "",
      "minimumLevel": "",
      "maximumLevel": "",
      "spellSlotOptions": "",
      "_": "",
      "spellSlots": "",
      "consumeSlot": "",
      "spellSlotValue": "",
      "label": "",
      "disabled": "",
      "o": "",
      "scaling": "",
      "display": "",
      "submitData": "",
      "formData": "",
      "level": "",
      "resources": "",
      "dialog": "",
      "event": ""
    },
    "AttackSheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "availableAbilities": "",
      "abilityOptions": "",
      "hasBaseDamage": "",
      "attackTypeOptions": "",
      "t": "",
      "attackClassificationOptions": ""
    },
    "CastSheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "contentLink": "",
      "levelOptions": "",
      "abilityOptions": "",
      "propertyOptions": "",
      "placeholder": "",
      "tabs": "",
      "label": "",
      "icon": ""
    },
    "CheckSheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "group": "",
      "abilityOptions": "",
      "associated": "",
      "type": "",
      "size": "",
      "label": "",
      "associatedOptions": "",
      "calculationOptions": ""
    },
    "DamageSheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": ""
    },
    "EnchantSheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "tabGroups": "",
      "activityOptions": "",
      "effectOptions": "",
      "context": "",
      "appliedEnchantments": "",
      "allEnchantments": "",
      "enchantableTypes": "",
      "typeOptions": "",
      "type": "",
      "typeDataModel": "",
      "categoryOptions": "",
      "propertyOptions": "",
      "tabs": "",
      "label": "",
      "icon": ""
    },
    "EnchantUsageDialog": {
      "static PARTS": "",
      "context": "Dialog for configuring the usage of an activity.\n/\nexport default class EnchantUsageDialog extends ActivityUsageDialog {\n\n  /** @inheritDoc */\n  static PARTS = {\n    ...super.PARTS,\n    creation: {\n      template: \"systems/dnd5e/templates/activity/enchant-usage-creation.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "enchantments": "",
      "hasCreation": "",
      "enchantment": ""
    },
    "ForwardSheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "showConsumeSpellSlot": "",
      "showScaling": "",
      "activityOptions": ""
    },
    "HealSheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "typeOptions": "",
      "scaleKey": "",
      "scalingOptions": ""
    },
    "OrderUsageDialog": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "build": "",
      "costs": "",
      "craft": "",
      "order": "",
      "value": "",
      "quantity": "",
      "baseItem": "",
      "item": "",
      "sizes": "",
      "index": "",
      "description": "",
      "days": "",
      "buttons": "",
      "config": "",
      "duration": "",
      "context": "",
      "trade": "",
      "isSelling": "",
      "max": "",
      "label": "",
      "stock": "",
      "sell": "",
      "buy": "",
      "uuid": "",
      "removable": "",
      "doc": "",
      "creatures": "",
      "data": "",
      "recalculateCosts": "",
      "submitData": "",
      "gold": "",
      "k": ""
    },
    "SaveSheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "additionalSettings": "",
      "context": "",
      "abilityOptions": "",
      "calculationOptions": "",
      "onSaveOptions": ""
    },
    "SummonSheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "static CLEAN_ARRAYS": "",
      "tabGroups": "",
      "context": "",
      "abilityOptions": "",
      "creatureSizeOptions": "",
      "creatureTypeOptions": "",
      "profileModes": "",
      "profiles": "",
      "tabs": "",
      "label": "",
      "icon": "",
      "data": "",
      "actor": "",
      "profileId": "",
      "profile": "",
      "uuid": ""
    },
    "SummonUsageDialog": {
      "static PARTS": "",
      "context": "",
      "profiles": "",
      "hasCreation": "",
      "summonsFields": "",
      "rollData": "",
      "options": "",
      "o": "",
      "summonsProfile": "",
      "value": "",
      "label": "",
      "cr": "",
      "doc": "",
      "count": ""
    },
    "UtilitySheet": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": ""
    },
    "BaseConfigSheet": {
      "static DEFAULT_OPTIONS": "",
      "context": "",
      "advantageModeOptions": "",
      "name": "",
      "tooltip": ""
    },
    "ActorSheet5eCharacter": {
      "options": "",
      "resources": "",
      "value": "",
      "max": "",
      "classes": "",
      "c": "",
      "inventory": "",
      "inventoryTypes": "",
      "ctx": "",
      "isStack": "",
      "attunement": "",
      "isExpanded": "",
      "hasRecharge": "",
      "hasUses": "",
      "concealDetails": "",
      "ungroup": "",
      "group": "",
      "type": "",
      "totalWeight": "",
      "spellbook": "",
      "nPrepared": "",
      "mode": "",
      "maxLevelDelta": "",
      "availableLevels": "",
      "label": "",
      "prefixedImage": "",
      "identifier": "",
      "subclass": "",
      "subclassAdvancement": "",
      "needsSubclass": "",
      "message": "",
      "features": "",
      "inventoryFilters": "",
      "preparedSpells": "",
      "isAlways": "",
      "isPrepared": "",
      "toggleClass": "",
      "toggleTitle": "",
      "isActive": "",
      "canToggle": "",
      "action": "",
      "button": "",
      "levels": "",
      "err": "",
      "cls": "",
      "priorLevel": "",
      "manager": ""
    },
    "AbilityConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "proficiencyOptions": ""
    },
    "ArmorClassConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "data": "",
      "fields": "",
      "source": "",
      "calculationOptions": "",
      "value": "",
      "config": "",
      "formula": "",
      "dexterity": "",
      "calculations": "",
      "item": "",
      "val": "",
      "key": ""
    },
    "BaseProficiencyConfig": {
      "static DEFAULT_OPTIONS": "",
      "options": "",
      "uniqueId": "",
      "context": "",
      "source": "",
      "keyPath": "",
      "data": "",
      "fields": "",
      "label": "",
      "prefix": "",
      "global": ""
    },
    "ConcentrationConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "source": "",
      "data": "",
      "fields": "",
      "ability": "",
      "abilityOptions": "",
      "global": ""
    },
    "DamagesConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "bypasses": "",
      "value": "",
      "trait": "",
      "bypassHint": "",
      "hint": "",
      "field": "",
      "key": "",
      "input": "",
      "categoryChosen": "",
      "config": "",
      "icon": "",
      "submitData": ""
    },
    "DeathConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "source": "",
      "data": "",
      "fields": "",
      "global": ""
    },
    "HabitatConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "@override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"habitat-config\"],\n    position: {\n      width: 420\n    }\n  };\n\n  /** @override */\n  static PARTS = {\n    config: {\n      template: \"systems/dnd5e/templates/actors/config/habitat-config.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /** @override */\n  get title() {\n    return game.i18n.localize(\"DND5E.Habitat.Configuration.Title\");\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "config": "",
      "value": "",
      "any": "",
      "custom": "",
      "habitats": "",
      "checked": "",
      "rows": "",
      "submitData": "",
      "entry": "",
      "subtype": ""
    },
    "HitDiceConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "classes": "",
      "valueField": "Configuration application for adjusting hit dice amounts and rolling.\n/\nexport default class HitDiceConfig extends BaseConfigSheet {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"hit-dice\"],\n    actions: {\n      decrease: HitDiceConfig.#stepValue,\n      increase: HitDiceConfig.#stepValue,\n      roll: HitDiceConfig.#rollDie\n    },\n    position: {\n      width: 420\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    config: {\n      template: \"systems/dnd5e/templates/actors/config/hit-dice-config.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /** @override */\n  get title() {\n    return game.i18n.localize(\"DND5E.HitDice\");\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _preparePartContext(partId, context, options) {\n    context = await super._preparePartContext(partId, context, options);\n    context.classes = Array.from(this.document.system.attributes?.hd?.classes ?? []).map(cls => ({\n      data: { ...cls.system.hd },\n      denomination: Number(cls.system.hd.denomination.slice(1)),\n      id: cls.id,\n      label: `${cls.name} (${cls.system.hd.denomination})`\n    })).sort((lhs, rhs) => rhs.denomination - lhs.denomination);\n    return context;\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers                */\n  /* -------------------------------------------- */\n\n  /**\nHandle rolling a specific hit die.\n@this {HitDiceConfig}\n@param {PointerEvent} event  The triggering click event.\n@param {HTMLElement} target  The button that was clicked.\n/\n  static async #rollDie(event, target) {\n    await this.document.rollHitDie({ denomination: target.dataset.denomination });\n    this.render();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle stepping a hit die count up or down.\n@this {HitDiceConfig}\n@param {PointerEvent} event  The triggering click event.\n@param {HTMLElement} target  The button that was clicked.",
      "action": "",
      "submitData": "",
      "classUpdates": ""
    },
    "HitPointsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "data": "",
      "fields": "",
      "source": "",
      "ability": "",
      "mod": "",
      "classes": "",
      "effects": "",
      "e": "",
      "levels": "",
      "levelMultiplier": "",
      "showCalculation": "",
      "showMaxInCalculation": "",
      "roll": "",
      "clone": "",
      "maxDelta": "",
      "current": "",
      "hitDie": ""
    },
    "InitiativeConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "source": "",
      "defaultAbility": "",
      "abilityOptions": "",
      "data": "",
      "fields": "",
      "ability": "",
      "abilityConfig": "",
      "flags": ""
    },
    "LanguagesConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "unitOptions": "",
      "communication": ""
    },
    "SkillToolConfig": {
      "static PARTS": "",
      "trait": "",
      "context": "",
      "abilityOptions": "",
      "proficiencyOptions": "",
      "section": "",
      "skill": ""
    },
    "SkillsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "skills": "",
      "rows": "",
      "categoryChosen": "",
      "skill": "",
      "value": "",
      "total": "",
      "tooltip": "",
      "e": ""
    },
    "SpellSlotsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "source": "",
      "overrides": "",
      "hasSpell": ""
    },
    "ToolsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "categoryChosen": "",
      "tool": "",
      "hasEntry": "",
      "value": "",
      "total": "",
      "tooltip": "",
      "e": "",
      "submitData": "",
      "config": ""
    },
    "TraitsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "options": "",
      "uniqueId": "",
      "context": "",
      "keyPath": "",
      "data": "",
      "checkbox": "",
      "chosen": "",
      "choices": "",
      "fields": "",
      "other": "",
      "OTHER": "",
      "categoryChosen": "",
      "disabled": "",
      "submitData": ""
    },
    "TreasureConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "Configuration application for an NPC's treasure categories.\n/\nexport default class TreasureConfig extends BaseConfigSheet {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"treasure-config\"],\n    position: {\n      width: 400\n    }\n  };\n\n  /** @override */\n  static PARTS = {\n    config: {\n      template: \"systems/dnd5e/templates/actors/config/treasure-config.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /** @override */\n  get title() {\n    return game.i18n.localize(\"DND5E.Treasure.Configuration.Title\");\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "config": "",
      "any": "",
      "treasure": ""
    },
    "WeaponsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "categoryChosen": "",
      "mastery": "",
      "submitData": ""
    },
    "ActorAbilityConfig": {},
    "ActorArmorConfig": {},
    "ActorConcentrationConfig": {},
    "DamageModificationConfig": {
      "options": ""
    },
    "ActorHitDiceConfig": {},
    "ActorHitPointsConfig": {},
    "ActorInitiativeConfig": {},
    "ActorMovementConfig": {},
    "ProficiencyConfig": {
      "trait": ""
    },
    "ActorSensesConfig": {},
    "ActorSkillsConfig": {
      "options": ""
    },
    "ActorSpellSlotsConfig": {},
    "ToolSelector": {
      "options": ""
    },
    "TraitSelector": {
      "options": ""
    },
    "ActorTypeConfig": {
      "options": "",
      "keyPath": ""
    },
    "ActorSheet5eNPC": {
      "context": "",
      "cr": "",
      "crLabels": "",
      "classSpellcasting": "",
      "features": "",
      "maxLevelDelta": "",
      "ctx": "",
      "isStack": "",
      "isExpanded": "",
      "hasRecharge": "",
      "hasUses": "",
      "hasTarget": "",
      "canToggle": "",
      "totalWeight": "",
      "isPassive": "",
      "group": "",
      "ungroup": "",
      "type": "",
      "label": "",
      "spellbook": "",
      "inventoryFilters": "",
      "ac": "",
      "calc": "",
      "action": "",
      "button": "",
      "editor": "",
      "initial": "",
      "crs": "",
      "crv": ""
    },
    "BaseRestDialog": {
      "options": "",
      "actor": "",
      "config": "",
      "static DEFAULT_OPTIONS": "",
      "duration": "",
      "rested": "",
      "context": "",
      "app": ""
    },
    "LongRestDialog": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "Dialog for configuring a long rest.\n/\nexport default class LongRestDialog extends BaseRestDialog {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"long-rest\"],\n    window: {\n      title: \"DND5E.REST.Long.Label\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static PARTS = {\n    ...super.PARTS,\n    content: {\n      template: \"systems/dnd5e/templates/actors/rest/long-rest.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "options": ""
    },
    "ShortRestDialog": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "Dialog for configuring a short rest.\n/\nexport default class ShortRestDialog extends BaseRestDialog {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"short-rest\"],\n    actions: {\n      rollHitDie: ShortRestDialog.#rollHitDie\n    },\n    window: {\n      title: \"DND5E.REST.Short.Label\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static PARTS = {\n    ...super.PARTS,\n    content: {\n      template: \"systems/dnd5e/templates/actors/rest/short-rest.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nCurrently selected hit dice denomination.\n@type {string}\n/\n  #denom;\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "autoRoll": "",
      "type": "",
      "hitDice": "",
      "denomination": "",
      "denom": "",
      "options": ""
    },
    "ActorSheetFlags": {
      "data": "An application class which provides advanced configuration for special character flags which modify an Actor.\n/\nexport default class ActorSheetFlags extends BaseConfigSheet {\n  constructor(...args) {\n    foundry.utils.logCompatibilityWarning(\n      \"The `ActorSheetFlags` application has been deprecated and replaced with a tab on the character sheet.\",\n      { since: \"DnD5e 4.3\", until: \"DnD5e 4.5\" }\n    );\n    super(...args);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static get defaultOptions() {\n    return foundry.utils.mergeObject(super.defaultOptions, {\n      id: \"actor-flags\",\n      classes: [\"dnd5e\"],\n      template: \"systems/dnd5e/templates/apps/actor-flags.hbs\",\n      width: 500,\n      closeOnSubmit: true\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get title() {\n    return `${game.i18n.localize(\"DND5E.FlagsTitle\")}: ${this.object.name}`;\n  }\n\n  /* --------------------------------------------",
      "actor": "",
      "classes": "",
      "flags": "",
      "bonuses": "",
      "type": "",
      "baseData": "An application class which provides advanced configuration for special character flags which modify an Actor.\n/\nexport default class ActorSheetFlags extends BaseConfigSheet {\n  constructor(...args) {\n    foundry.utils.logCompatibilityWarning(\n      \"The `ActorSheetFlags` application has been deprecated and replaced with a tab on the character sheet.\",\n      { since: \"DnD5e 4.3\", until: \"DnD5e 4.5\" }\n    );\n    super(...args);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static get defaultOptions() {\n    return foundry.utils.mergeObject(super.defaultOptions, {\n      id: \"actor-flags\",\n      classes: [\"dnd5e\"],\n      template: \"systems/dnd5e/templates/apps/actor-flags.hbs\",\n      width: 500,\n      closeOnSubmit: true\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get title() {\n    return `${game.i18n.localize(\"DND5E.FlagsTitle\")}: ${this.object.name}`;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  getData() {\n    const data = {};\n    data.actor = this.object;\n    data.classes = this._getClasses();\n    data.flags = this._getFlags();\n    data.bonuses = this._getBonuses();\n    if ( this.document.type === \"npc\" ) data.npc = this._getNPC();\n    return data;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare an object of sorted classes.\n@returns {object}\n@private\n/\n  _getClasses() {\n    const classes = this.object.items.filter(i => i.type === \"class\");\n    return classes.sort((a, b) => a.name.localeCompare(b.name, game.i18n.lang)).reduce((obj, i) => {\n      obj[i.id] = i.name;\n      return obj;\n    }, {});\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare an object of flags data which groups flags by section\nAdd some additional data for rendering\n@returns {object}\n@private",
      "flag": "",
      "isCheckbox": "",
      "isSelect": "",
      "value": "",
      "src": "",
      "updateData": ""
    },
    "ActorSheet5eVehicle": {
      "static unsupportedItemTypes": "",
      "largestPrimary": "An Actor sheet for Vehicle type actors.\n/\nexport default class ActorSheet5eVehicle extends ActorSheet5e {\n\n  /** @inheritDoc */\n  static get defaultOptions() {\n    return foundry.utils.mergeObject(super.defaultOptions, {\n      classes: [\"dnd5e\", \"sheet\", \"actor\", \"vehicle\"]\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static unsupportedItemTypes = new Set([\"background\", \"class\", \"race\", \"subclass\"]);\n\n  /* -------------------------------------------- */\n\n  /**\nCreates a new cargo entry for a vehicle Actor.\n@type {object}\n/\n  static get newCargo() {\n    return {name: \"\", quantity: 1};\n  }\n\n  /* -------------------------------------------- */\n  /*  Context Preparation                         */\n  /* --------------------------------------------",
      "isCrewed": "",
      "toggleClass": "",
      "toggleTitle": "",
      "type": "",
      "cover": "",
      "cargoColumns": "",
      "equipmentColumns": "",
      "features": "",
      "item": "",
      "ctx": "",
      "canToggle": "",
      "isExpanded": "",
      "hasUses": "",
      "cargo": "",
      "isCargo": "",
      "act": "",
      "inventoryFilters": "",
      "encumbrance": "",
      "tab": "",
      "evt": "",
      "target": "",
      "row": "",
      "idx": "",
      "property": "",
      "entry": "",
      "key": "",
      "value": "",
      "detail": "An Actor sheet for Vehicle type actors.\n/\nexport default class ActorSheet5eVehicle extends ActorSheet5e {\n\n  /** @inheritDoc */\n  static get defaultOptions() {\n    return foundry.utils.mergeObject(super.defaultOptions, {\n      classes: [\"dnd5e\", \"sheet\", \"actor\", \"vehicle\"]\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static unsupportedItemTypes = new Set([\"background\", \"class\", \"race\", \"subclass\"]);\n\n  /* -------------------------------------------- */\n\n  /**\nCreates a new cargo entry for a vehicle Actor.\n@type {object}\n/\n  static get newCargo() {\n    return {name: \"\", quantity: 1};\n  }\n\n  /* -------------------------------------------- */\n  /*  Context Preparation                         */\n  /* -------------------------------------------- */\n\n  /** @override */\n  _getMovementSpeed(actorData, largestPrimary=true) {\n    return super._getMovementSpeed(actorData, largestPrimary);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare items that are mounted to a vehicle and require one or more crew to operate.\n@param {object} item     Copy of the item data being prepared for display.\n@param {object} context  Display context for the item.\n@protected\n/\n  _prepareCrewedItem(item, context) {\n\n    // Determine crewed status\n    const isCrewed = item.system.crewed;\n    context.toggleClass = isCrewed ? \"active\" : \"\";\n    context.toggleTitle = game.i18n.localize(`DND5E.${isCrewed ? \"Crewed\" : \"Uncrewed\"}`);\n\n    // Handle crew actions\n    if ( (item.type === \"feat\") && (item.system.activation.type === \"crew\") ) {\n      if ( item.system.cover === 1 ) context.cover = game.i18n.localize(\"DND5E.CoverTotal\");\n      else if ( item.system.cover === .5 ) context.cover = \"Â½\";\n      else if ( item.system.cover === .75 ) context.cover = \"Â¾\";\n      else context.cover = \"â€”\";\n    }\n\n    // Prepare vehicle weapons\n    if ( (item.type === \"equipment\") || (item.type === \"weapon\") ) {\n      context.threshold = item.system.hp?.dt ? item.system.hp.dt : \"â€”\";\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  _prepareItems(context) {\n    const cargoColumns = [{\n      label: game.i18n.localize(\"DND5E.Quantity\"),\n      css: \"item-qty\",\n      property: \"quantity\",\n      editable: \"Number\"\n    }];\n\n    const equipmentColumns = [{\n      label: game.i18n.localize(\"DND5E.Quantity\"),\n      css: \"item-qty\",\n      property: \"system.quantity\",\n      editable: \"Number\"\n    }, {\n      label: game.i18n.localize(\"DND5E.AC\"),\n      css: \"item-ac\",\n      property: \"system.armor.value\"\n    }, {\n      label: game.i18n.localize(\"DND5E.HP\"),\n      css: \"item-hp\",\n      property: \"system.hp.value\",\n      maxProperty: \"system.hp.max\",\n      editable: \"Number\"\n    }, {\n      label: game.i18n.localize(\"DND5E.Threshold\"),\n      css: \"item-threshold\",\n      property: \"threshold\"\n    }];\n\n    const features = {\n      actions: {\n        label: game.i18n.localize(\"DND5E.ActionPl\"),\n        items: [],\n        hasActions: true,\n        crewable: true,\n        dataset: {type: \"feat\", \"activation.type\": \"crew\"},\n        columns: [{\n          label: game.i18n.localize(\"DND5E.Cover\"),\n          css: \"item-cover\",\n          property: \"cover\"\n        }]\n      },\n      equipment: {\n        label: game.i18n.localize(CONFIG.Item.typeLabels.equipment),\n        items: [],\n        crewable: true,\n        dataset: {type: \"equipment\", \"type.value\": \"vehicle\"},\n        columns: equipmentColumns\n      },\n      passive: {\n        label: game.i18n.localize(\"DND5E.Features\"),\n        items: [],\n        dataset: {type: \"feat\"}\n      },\n      reactions: {\n        label: game.i18n.localize(\"DND5E.ReactionPl\"),\n        items: [],\n        dataset: {type: \"feat\", \"activation.type\": \"reaction\"}\n      },\n      weapons: {\n        label: game.i18n.localize(`${CONFIG.Item.typeLabels.weapon}Pl`),\n        items: [],\n        crewable: true,\n        dataset: {type: \"weapon\", \"weapon-type\": \"siege\"},\n        columns: equipmentColumns\n      }\n    };\n\n    context.items.forEach(item => {\n      const {uses} = item.system;\n      const ctx = context.itemContext[item.id] ??= {};\n      ctx.canToggle = false;\n      ctx.isExpanded = this._expanded.has(item.id);\n      ctx.hasUses = uses && (uses.max > 0);\n    });\n\n    const cargo = {\n      crew: {\n        label: game.i18n.localize(\"DND5E.VehicleCrew\"),\n        items: context.actor.system.cargo.crew,\n        css: \"cargo-row crew\",\n        editableName: true,\n        dataset: {type: \"crew\"},\n        columns: cargoColumns\n      },\n      passengers: {\n        label: game.i18n.localize(\"DND5E.VehiclePassengers\"),\n        items: context.actor.system.cargo.passengers,\n        css: \"cargo-row passengers\",\n        editableName: true,\n        dataset: {type: \"passengers\"},\n        columns: cargoColumns\n      },\n      cargo: {\n        label: game.i18n.localize(\"DND5E.VehicleCargo\"),\n        items: [],\n        dataset: {type: \"loot\"},\n        columns: [{\n          label: game.i18n.localize(\"DND5E.Quantity\"),\n          css: \"item-qty\",\n          property: \"system.quantity\",\n          editable: \"Number\"\n        }, {\n          label: game.i18n.localize(\"DND5E.Price\"),\n          css: \"item-price\",\n          property: \"system.price.value\",\n          editable: \"Number\"\n        }, {\n          label: game.i18n.localize(\"DND5E.Weight\"),\n          css: \"item-weight\",\n          property: \"system.weight.value\",\n          editable: \"Number\"\n        }]\n      }\n    };\n\n    // Classify items owned by the vehicle and compute total cargo weight\n    for ( const item of context.items ) {\n      const ctx = context.itemContext[item.id] ??= {};\n      this._prepareCrewedItem(item, ctx);\n\n      // Handle cargo explicitly\n      const isCargo = item.flags.dnd5e?.vehicleCargo === true;\n      if ( isCargo ) {\n        cargo.cargo.items.push(item);\n        continue;\n      }\n\n      // Handle non-cargo item types\n      switch ( item.type ) {\n        case \"weapon\":\n          features.weapons.items.push(item);\n          break;\n        case \"equipment\":\n          features.equipment.items.push(item);\n          break;\n        case \"feat\":\n          const act = item.system.activation;\n          if ( !act.type || (act.type === \"none\") ) features.passive.items.push(item);\n          else if (act.type === \"reaction\") features.reactions.items.push(item);\n          else features.actions.items.push(item);\n          break;\n        case \"spell\":\n          break;\n        default:\n          cargo.cargo.items.push(item);\n      }\n    }\n\n    // Update the rendering context data\n    context.inventoryFilters = false;\n    context.features = Object.values(features);\n    context.cargo = Object.values(cargo);\n    context.encumbrance = context.system.attributes.encumbrance;\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers                */\n  /* -------------------------------------------- */\n\n  /** @override */\n  activateListeners(html) {\n    super.activateListeners(html);\n    if ( !this.isEditable ) return;\n\n    html[0].querySelector('[data-tab=\"cargo\"] dnd5e-inventory')\n      .addEventListener(\"inventory\", this._onInventoryEvent.bind(this));\n\n    html.find(\".cargo-row input\")\n      .click(evt => evt.target.select())\n      .change(this._onCargoRowChange.bind(this));\n\n    if (this.actor.system.attributes.actions.stations) {\n      html.find(\".counter.actions, .counter.action-thresholds\").hide();\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle saving a cargo row (i.e. crew or passenger) in-sheet.\n@param {Event} event              Triggering event.\n@returns {Promise<Actor5e>|null}  Actor after update if any changes were made.\n@private\n/\n  _onCargoRowChange(event) {\n    event.preventDefault();\n    const target = event.currentTarget;\n    const row = target.closest(\".item\");\n    const idx = Number(row.dataset.itemIndex);\n    const property = row.classList.contains(\"crew\") ? \"crew\" : \"passengers\";\n\n    // Get the cargo entry\n    const cargo = foundry.utils.deepClone(this.actor.system.cargo[property]);\n    const entry = cargo[idx];\n    if ( !entry ) return null;\n\n    // Update the cargo value\n    const key = target.dataset.name ?? \"name\";\n    const type = target.dataset.dtype;\n    let value = target.value;\n    if (type === \"Number\") value = Number(value);\n    entry[key] = value;\n\n    // Perform the Actor update\n    return this.actor.update({[`system.cargo.${property}`]: cargo});\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle creating and deleting crew and passenger rows.\n@param {CustomEvent} event   Triggering inventory event.\n@returns {Promise}",
      "cargoCollection": "",
      "cargoTypes": ""
    },
    "AbilityScoreImprovementConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "abilities": "",
      "fixed": "",
      "locked": "",
      "points": "",
      "action": "",
      "input": "",
      "parent": "",
      "value": ""
    },
    "AbilityScoreImprovementFlow": {
      "assignments": "",
      "static _customElements": "",
      "featUuid": "",
      "feat": "",
      "points": "",
      "available": "",
      "formatter": "",
      "lockImprovement": "",
      "abilities": "",
      "ability": "",
      "assignment": "",
      "fixed": "",
      "locked": "",
      "value": "",
      "max": "",
      "min": "",
      "modernRules": "",
      "pluralRules": "",
      "action": "",
      "input": "",
      "name": "",
      "key": "",
      "filters": "",
      "result": "",
      "uuid": "",
      "item": "",
      "data": ""
    },
    "AdvancementConfig": {
      "advancement": "",
      "options": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "levels": "",
      "label": "",
      "context": "",
      "uuidToDelete": "",
      "items": "",
      "updates": "",
      "configuration": "",
      "keep": "",
      "data": "",
      "item": "",
      "existingItems": "",
      "uuid": "",
      "i": "",
      "advancementId": "",
      "type": "Base configuration application for advancements that can be extended by other types to implement custom\nediting interfaces.\n@param {Advancement} advancement            The advancement item being edited.\n@param {object} [options={}]                Additional options passed to FormApplication.\n@param {string} [options.dropKeyPath=null]  Path within advancement configuration where dropped items are stored.\n                                            If populated, will enable default drop & delete behavior.\n/\nexport default class AdvancementConfig extends FormApplication {\n  constructor(advancement, options={}) {\n    super(advancement, options);\n    this.#advancementId = advancement.id;\n    this.item = advancement.item;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe ID of the advancement being created or edited.\n@type {string}\n/\n  #advancementId;\n\n  /* -------------------------------------------- */\n\n  /**\nParent item to which this advancement belongs.\n@type {Item5e}\n/\n  item;\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static get defaultOptions() {\n    return foundry.utils.mergeObject(super.defaultOptions, {\n      classes: [\"dnd5e\", \"advancement\", \"dialog\"],\n      template: \"systems/dnd5e/templates/advancement/advancement-config.hbs\",\n      width: 400,\n      height: \"auto\",\n      submitOnChange: true,\n      closeOnSubmit: false,\n      dropKeyPath: null\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe advancement being created or edited.\n@type {Advancement}\n/\n  get advancement() {\n    return this.item.advancement.byId[this.#advancementId];\n  }\n\n  /* --------------------------------------------",
      "action": "",
      "force": ""
    },
    "AdvancementConfirmationDialog": {
      "class": "",
      "dialog": ""
    },
    "AdvancementFlow": {
      "options": "",
      "item": "",
      "_advancementId": "",
      "level": "",
      "retainedData": "",
      "static _customElements": ""
    },
    "AdvancementManager": {
      "options": "",
      "actor": "",
      "clone": "",
      "visualizer": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "advancing": "",
      "parts": "Internal type used to manage each step within the advancement process.\n@typedef {object} AdvancementStep\n@property {string} type                Step type from \"forward\", \"reverse\", \"restore\", or \"delete\".\n@property {AdvancementFlow} [flow]     Flow object for the advancement being applied by this step. In the case of\n                                       \"delete\" steps, this flow indicates the advancement flow that originally\n                                       deleted the item.\n@property {Item5e} [item]              For \"delete\" steps only, the item to be removed.\n@property {object} [class]             Contains data on class if step was triggered by class level change.\n@property {Item5e} [class.item]        Class item that caused this advancement step.\n@property {number} [class.level]       Level the class should be during this step.\n@property {boolean} [automatic=false]  Should the manager attempt to apply this step without user interaction?\n@property {boolean} [synthetic=false]  Was this step created as a result of an item introduced or deleted?\n/\n\n/**\n@typedef AdvancementManagerConfiguration\n@property {boolean} [automaticApplication=false]  Apply advancement steps automatically if no user input is required.\n@property {boolean} [showVisualizer=false]        Display the step debugging application.\n/\n\n/**\nApplication for controlling the advancement workflow and displaying the interface.\n@param {Actor5e} actor        Actor on which this advancement is being performed.\n@param {object} [options={}]  Additional application options.\n/\nexport default class AdvancementManager extends Application5e {\n  constructor(actor, options={}) {\n    super(options);\n    this.actor = actor;\n    this.clone = actor.clone();\n    if ( this.options.showVisualizer ) this.#visualizer = new AdvancementVisualizer({ manager: this });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"advancement\", \"manager\"],\n    window: {\n      icon: \"fa-solid fa-forward\",\n      title: \"DND5E.ADVANCEMENT.Manager.Title.Default\"\n    },\n    actions: {\n      complete: AdvancementManager.#process,\n      next: AdvancementManager.#process,\n      previous: AdvancementManager.#process,\n      restart: AdvancementManager.#process\n    },\n    position: {\n      width: 460\n    },\n    automaticApplication: false,\n    showVisualizer: false\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    manager: {\n      template: \"systems/dnd5e/templates/advancement/advancement-manager.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nThe original actor to which changes will be applied when the process is complete.\n@type {Actor5e}\n/\n  actor;\n\n  /* -------------------------------------------- */\n\n  /**\nIs the prompt currently advancing through un-rendered steps?\n@type {boolean}\n/\n  #advancing = false;\n\n  /* -------------------------------------------- */\n\n  /**\nA clone of the original actor to which the changes can be applied during the advancement process.\n@type {Actor5e}\n/\n  clone;\n\n  /* --------------------------------------------",
      "item": "",
      "level": "",
      "visibleSteps": "",
      "visibleIndex": "",
      "stepIndex": "",
      "steps": "",
      "nextIndex": "",
      "clonedItem": "",
      "currentLevel": "",
      "minimumLevel": "",
      "oldFlows": "",
      "flow": "",
      "advancementArray": "",
      "a": "",
      "value": "",
      "newFlows": "",
      "dataClone": "",
      "_id": "",
      "type": "",
      "targetLevel": "",
      "l": "",
      "flows": "",
      "f": "",
      "advancement": "",
      "raceItem": "",
      "pushSteps": "",
      "getItemFlows": "",
      "offset": "",
      "classLevel": "",
      "characterLevel": "",
      "stepData": "",
      "context": "",
      "forced": "",
      "allowed": "",
      "automaticData": "",
      "_element": "",
      "class": "",
      "disabled": "",
      "preEmbeddedItems": "",
      "automatic": "",
      "initialIds": "",
      "preIds": "",
      "postIds": "",
      "addedIds": "",
      "deletedIds": "",
      "handledLevel": "",
      "idx": "",
      "thisLevel": "",
      "nextLevel": "",
      "render": "",
      "modifiedIds": "",
      "restart": "",
      "s": "",
      "updates": "",
      "items": "",
      "id": "",
      "i": ""
    },
    "AdvancementVisualizer": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "steps": ""
    },
    "AdvancementMigrationDialog": {
      "advancementContext": "",
      "dialog": ""
    },
    "AdvancementSelection": {
      "dialogData": "",
      "item": "",
      "context": "Presents a list of advancement types to create when clicking the new advancement button.\nOnce a type is selected, this hands the process over to the advancement's individual editing interface.\n@param {Item5e} item             Item to which this advancement will be added.\n@param {object} [dialogData={}]  An object of dialog data which configures how the modal window is rendered.\n@param {object} [options={}]     Dialog rendering options.\n/\nexport default class AdvancementSelection extends Dialog {\n  constructor(item, dialogData={}, options={}) {\n    super(dialogData, options);\n\n    /**\nStore a reference to the Item to which this Advancement is being added.\n@type {Item5e}\n/\n    this.item = item;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static get defaultOptions() {\n    return foundry.utils.mergeObject(super.defaultOptions, {\n      classes: [\"dnd5e\", \"sheet\", \"advancement\"],\n      template: \"systems/dnd5e/templates/advancement/advancement-selection.hbs\",\n      title: \"DND5E.AdvancementSelectionTitle\",\n      width: 500,\n      height: \"auto\"\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get id() {\n    return `item-${this.item.id}-advancement-selection`;\n  }\n\n  /* --------------------------------------------",
      "advancement": "",
      "types": "",
      "submit": "",
      "disabled": "",
      "config": "",
      "type": ""
    },
    "HitPointsFlow": {
      "source": "Inline application that presents hit points selection upon level up.\n/\nexport default class HitPointsFlow extends AdvancementFlow {\n\n  /** @inheritDoc */\n  static get defaultOptions() {\n    return foundry.utils.mergeObject(super.defaultOptions, {\n      template: \"systems/dnd5e/templates/advancement/hit-points-flow.hbs\"\n    });\n  }\n\n  /* --------------------------------------------",
      "value": "",
      "useAverage": "",
      "lastValue": "",
      "level": "",
      "event": "",
      "disabled": "",
      "roll": "",
      "errorType": ""
    },
    "ItemChoiceConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "items": "",
      "abilityOptions": "",
      "choices": "",
      "levelRestrictionOptions": "",
      "showContainerWarning": "",
      "showSpellConfig": "",
      "showRequireSpellSlot": "",
      "typeOptions": "",
      "type": "",
      "typeRestriction": "",
      "pool": ""
    },
    "ItemChoiceFlow": {
      "replacement": "",
      "selected": "",
      "context": "",
      "i": "",
      "dropped": "",
      "uuid": "",
      "item": "",
      "levelConfig": "",
      "max": "",
      "replaceable": "",
      "noReplacement": "",
      "choices": "",
      "previousLevels": "",
      "previouslySelected": "",
      "added": "",
      "id": "",
      "replaced": "",
      "match": "",
      "items": "",
      "disabled": "",
      "validLevel": "",
      "available": "",
      "abilities": "",
      "tagName": "",
      "type": "",
      "name": "",
      "uuidToDelete": "",
      "data": "",
      "spellLevel": "",
      "spellcasting": "",
      "progression": "",
      "maxSpellLevel": "",
      "spells": ""
    },
    "ItemGrantConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "items": "",
      "abilityOptions": "",
      "showContainerWarning": "",
      "showSpellConfig": "",
      "showRequireSpellSlot": ""
    },
    "ItemGrantFlow": {
      "config": "",
      "added": "",
      "checked": "",
      "i": "",
      "optional": "",
      "options": "",
      "uuid": "",
      "item": "",
      "retainedData": ""
    },
    "ScaleValueConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "config": "",
      "type": "",
      "distanceOptions": "",
      "identifier": "",
      "hint": "",
      "levels": "",
      "lastValue": "",
      "value": "",
      "className": "",
      "name": "",
      "slug": "",
      "k": "",
      "scale": "",
      "typeChange": "",
      "OriginalType": "",
      "NewType": "",
      "original": ""
    },
    "ScaleValueFlow": {},
    "SizeConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "Configuration application for size advancement.\n/\nexport default class SizeConfig extends AdvancementConfig {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"size\"]\n  };\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static PARTS = {\n    ...super.PARTS,\n    details: {\n      template: \"systems/dnd5e/templates/advancement/size-config-details.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "sizes": ""
    },
    "SizeFlow": {
      "sizes": "",
      "size": ""
    },
    "SubclassFlow": {
      "uuid": "",
      "subclass": "",
      "context": "",
      "action": "",
      "filters": "",
      "result": "",
      "item": "",
      "data": ""
    },
    "TraitConfig": {
      "selected": "",
      "trait": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "pool": "",
      "context": "Configuration application for traits.\n/\nexport default class TraitConfig extends AdvancementConfig {\n  constructor(...args) {\n    super(...args);\n    this.selected = (this.config.choices.length && !this.config.grants.size) ? 0 : -1;\n    this.trait = this.types.first() ?? \"skills\";\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"trait\", \"trait-selector\"],\n    actions: {\n      addChoice: TraitConfig.#addChoice,\n      removeChoice: TraitConfig.#removeChoice\n    },\n    position: {\n      width: 680\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static PARTS = {\n    config: {\n      container: { classes: [\"column-container\"], id: \"column-left\" },\n      template: \"systems/dnd5e/templates/advancement/advancement-controls-section.hbs\"\n    },\n    details: {\n      container: { classes: [\"column-container\"], id: \"column-left\" },\n      template: \"systems/dnd5e/templates/advancement/trait-config-details.hbs\"\n    },\n    guaranteed: {\n      container: { classes: [\"column-container\"], id: \"column-left\" },\n      template: \"systems/dnd5e/templates/advancement/trait-config-guaranteed.hbs\"\n    },\n    choices: {\n      container: { classes: [\"column-container\"], id: \"column-left\" },\n      template: \"systems/dnd5e/templates/advancement/trait-config-choices.hbs\"\n    },\n    traits: {\n      container: { classes: [\"column-container\"], id: \"column-right\" },\n      template: \"systems/dnd5e/templates/advancement/trait-config-traits.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nShortcut to the configuration data on the advancement.\n@type {object}\n/\n  get config() {\n    return this.advancement.configuration;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIndex of the selected configuration, `-1` means `grants` array, any other number is equal\nto an index in `choices` array.\n@type {number}\n/\n  selected;\n\n  /* -------------------------------------------- */\n\n  /**\nTrait type to display in the selector interface.\n@type {string}\n/\n  trait;\n\n  /* -------------------------------------------- */\n\n  /**\nList of trait types for the current selected configuration.\n@type {Set<string>}\n/\n  get types() {\n    const pool = this.selected === -1 ? this.config.grants : this.config.choices[this.selected].pool;\n    return this.advancement.representedTraits([pool]);\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "grants": "",
      "choices": "",
      "chosen": "",
      "count": "",
      "selectedIndex": "",
      "rep": "",
      "disableAllowReplacements": "",
      "traitConfig": "",
      "title": "",
      "icon": "",
      "hint": "",
      "mode": "",
      "toCheck": "",
      "i": "",
      "input": "",
      "name": "",
      "types": "",
      "validTraitTypes": "",
      "configuration": "",
      "prefix": "",
      "filteredSelected": "",
      "current": "",
      "filteredPrevious": "",
      "c": "",
      "checkKey": ""
    },
    "TraitFlow": {
      "available": "",
      "s": "",
      "addedTrait": "",
      "tag": "",
      "chosen": "",
      "existingChosen": "Inline application that presents the player with a trait choices.\n/\nexport default class TraitFlow extends AdvancementFlow {\n\n  /**\nArray of trait keys currently chosen.\n@type {Set<string>}\n/\n  chosen;\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static get defaultOptions() {\n    return foundry.utils.mergeObject(super.defaultOptions, {\n      template: \"systems/dnd5e/templates/advancement/trait-flow.hbs\"\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nTrait configuration from `CONFIG.TRAITS` for this advancement's trait type.\n@type {TraitConfiguration}\n/\n  get traitConfig() {\n    return CONFIG.DND5E.traits[this.advancement.configuration.type];\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async getData() {\n    this.chosen ??= await this.prepareInitialValue();\n    const available = await this.advancement.availableChoices(this.chosen);\n    return foundry.utils.mergeObject(super.getData(), {\n      hint: this.advancement.hint ? this.advancement.hint : Trait.localizedList({\n        grants: this.advancement.configuration.grants, choices: this.advancement.configuration.choices\n      }),\n      slots: this.prepareTraitSlots(available),\n      available\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  activateListeners(html) {\n    this.form.querySelectorAll(\"select\").forEach(s => s.addEventListener(\"change\", this._onSelectTrait.bind(this)));\n    this.form.querySelectorAll(\".remove\").forEach(s => s.addEventListener(\"click\", this._onRemoveTrait.bind(this)));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a trait to the value when one is selected.\n@param {Event} event  Triggering change to a select input.\n/\n  _onSelectTrait(event) {\n    const addedTrait = event.target.value;\n    if ( addedTrait === \"\" ) return;\n    this.chosen.add(addedTrait);\n    this.render();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRemove a trait for the value when the remove button is clicked.\n@param {Event} event  Triggering click.\n/\n  _onRemoveTrait(event) {\n    const tag = event.target.closest(\".trait-slot\");\n    this.chosen.delete(tag.dataset.key);\n    this.render();\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _updateObject(event, formData) {\n    if ( formData.chosen && !Array.isArray(formData.chosen) ) formData.chosen = [formData.chosen];\n    super._updateObject(event, formData);\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation Methods                    */\n  /* -------------------------------------------- */\n\n  /**\nWhen only a single choice is available, automatically select that choice provided value is empty.\n@returns {Set<string>}",
      "set": "",
      "size": "",
      "config": "Inline application that presents the player with a trait choices.\n/\nexport default class TraitFlow extends AdvancementFlow {\n\n  /**\nArray of trait keys currently chosen.\n@type {Set<string>}\n/\n  chosen;\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static get defaultOptions() {\n    return foundry.utils.mergeObject(super.defaultOptions, {\n      template: \"systems/dnd5e/templates/advancement/trait-flow.hbs\"\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nTrait configuration from `CONFIG.TRAITS` for this advancement's trait type.\n@type {TraitConfiguration}\n/\n  get traitConfig() {\n    return CONFIG.DND5E.traits[this.advancement.configuration.type];\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async getData() {\n    this.chosen ??= await this.prepareInitialValue();\n    const available = await this.advancement.availableChoices(this.chosen);\n    return foundry.utils.mergeObject(super.getData(), {\n      hint: this.advancement.hint ? this.advancement.hint : Trait.localizedList({\n        grants: this.advancement.configuration.grants, choices: this.advancement.configuration.choices\n      }),\n      slots: this.prepareTraitSlots(available),\n      available\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  activateListeners(html) {\n    this.form.querySelectorAll(\"select\").forEach(s => s.addEventListener(\"change\", this._onSelectTrait.bind(this)));\n    this.form.querySelectorAll(\".remove\").forEach(s => s.addEventListener(\"click\", this._onRemoveTrait.bind(this)));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdd a trait to the value when one is selected.\n@param {Event} event  Triggering change to a select input.\n/\n  _onSelectTrait(event) {\n    const addedTrait = event.target.value;\n    if ( addedTrait === \"\" ) return;\n    this.chosen.add(addedTrait);\n    this.render();\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRemove a trait for the value when the remove button is clicked.\n@param {Event} event  Triggering click.\n/\n  _onRemoveTrait(event) {\n    const tag = event.target.closest(\".trait-slot\");\n    this.chosen.delete(tag.dataset.key);\n    this.render();\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _updateObject(event, formData) {\n    if ( formData.chosen && !Array.isArray(formData.chosen) ) formData.chosen = [formData.chosen];\n    super._updateObject(event, formData);\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation Methods                    */\n  /* -------------------------------------------- */\n\n  /**\nWhen only a single choice is available, automatically select that choice provided value is empty.\n@returns {Set<string>}\n/\n  async prepareInitialValue() {\n    const existingChosen = this.retainedData?.chosen ?? this.advancement.value.chosen;\n    if ( existingChosen?.size ) return new Set(existingChosen);\n    const { available } = await this.advancement.unfulfilledChoices();\n    const chosen = new Set();\n    for ( const { choices } of available ) {\n      const set = choices.asSet();\n      if ( set.size === 1 ) chosen.add(set.first());\n    }\n    return chosen;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the list of slots to be populated by traits.\n@param {object} available  Trait availability returned by `prepareAvailableTraits`.\n@returns {object[]}",
      "count": "",
      "selectorShown": "",
      "slots": "",
      "i": "",
      "key": ""
    },
    "Dialog5e": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "tag": "Application for creating dnd5e dialogs.\n/\nexport default class Dialog5e extends Application5e {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    tag: \"dialog\",\n    window: {\n      contentTag: \"form\",\n      contentClasses: [\"standard-form\"],\n      minimizable: false\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    content: {\n      template: \"\"\n    },\n    footer: {\n      template: \"templates/generic/form-footer.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nForm element within the dialog.\n@type {HTMLFormElement|void}",
      "context": "",
      "partId": "",
      "buttons": ""
    },
    "PseudoDocumentSheet": {
      "options": "",
      "documentId": "",
      "documentType": "",
      "item": "",
      "static DEFAULT_OPTIONS": "",
      "frame": "",
      "autocomplete": "",
      "copyLabel": "",
      "copyId": "",
      "id": "",
      "type": "",
      "label": "",
      "submitData": "",
      "input": "",
      "updateData": "",
      "event": "",
      "formData": ""
    },
    "Award": {
      "_options": "",
      "origin": "",
      "options": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "primaryParty": "",
      "u": "",
      "value": "",
      "context": "",
      "currency": "",
      "destinations": "",
      "each": "",
      "hideXP": "",
      "noPrimaryParty": "",
      "xp": "",
      "icons": "",
      "doc": "",
      "formData": "",
      "data": "",
      "valid": "",
      "name": "",
      "results": "",
      "target": "",
      "config": "",
      "originCurrency": "",
      "remainingDestinations": "",
      "destinationUpdates": "",
      "result": "",
      "amount": "",
      "originUpdate": "",
      "perDestination": "",
      "cls": "",
      "messages": "",
      "entries": "",
      "label": "",
      "class": "",
      "content": "",
      "whisperTargets": "",
      "whisper": "",
      "messageData": "",
      "static COMMAND_PATTERN": "",
      "static VALUE_PATTERN": "",
      "roll": "",
      "savedDestinations": "",
      "app": "",
      "command": "",
      "party": "",
      "unrecognized": "",
      "part": ""
    },
    "BastionConfig": {},
    "CompendiumBrowserSourceConfig": {},
    "CompendiumBrowser": {
      "filters": "",
      "_mode": "",
      "isAdvanced": "",
      "tab": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "static TABS": "",
      "static MODES": "",
      "static BATCHING": "",
      "static SEARCH_DELAY": "",
      "source": "",
      "resultIndex": "",
      "renderThrottle": "",
      "selected": "",
      "max": "@typedef {ApplicationConfiguration} CompendiumBrowserConfiguration\n@property {{locked: CompendiumBrowserFilters, initial: CompendiumBrowserFilters}} filters  Filters to set to start.\n                                             Locked filters won't be able to be changed by the user. Initial filters\n                                             will be set to start but can be changed.\n@property {CompendiumBrowserSelectionConfiguration} selection  Configuration used to define document selections.\n/\n\n/**\n@typedef {object} CompendiumBrowserSelectionConfiguration\n@property {number|null} min                  Minimum number of documents that must be selected.\n@property {number|null} max                  Maximum number of documents that must be selected.\n/\n\n/**\n@typedef {object} CompendiumBrowserFilters\n@property {string} [documentClass]  Document type to fetch (e.g. Actor or Item).\n@property {Set<string>} [types]     Individual document subtypes to filter upon (e.g. \"loot\", \"class\", \"npc\").\n@property {object} [additional]     Additional type-specific filters applied.\n@property {FilterDescription[]} [arbitrary]  Additional arbitrary filters to apply, not displayed in the UI.\n                                    Only available as part of locked filters.\n@property {string} [name]           A substring to filter by Document name.\n/\n\n/**\nFilter definition object for additional filters in the Compendium Browser.\n@typedef {object} CompendiumBrowserFilterDefinitionEntry\n@property {string} label                                   Localizable label for the filter.\n@property {\"boolean\"|\"range\"|\"set\"} type                   Type of filter control to display.\n@property {object} config                                  Type-specific configuration data.\n@property {CompendiumBrowserCreateFilters} [createFilter]  Method that can be called to create filters.\n/\n\n/**\n@callback CompendiumBrowserFilterCreateFilters\n@param {FilterDescription[]} filters                        Array of filters to be applied that should be mutated.\n@param {*} value                                            Value of the filter.\n@param {CompendiumBrowserFilterDefinitionEntry} definition  Definition for this filter.\n/\n\n/**\n@typedef {Map<string, CompendiumBrowserFilterDefinitionEntry>} CompendiumBrowserFilterDefinition\n/\n\n/**\nApplication for browsing, filtering, and searching for content between multiple compendiums.\n@extends Application5e\n@template CompendiumBrowserConfiguration\n/\nexport default class CompendiumBrowser extends Application5e {\n  constructor(...args) {\n    super(...args);\n\n    this.#filters = this.options.filters?.initial ?? {};\n\n    if ( \"mode\" in this.options ) {\n      this._mode = this.options.mode;\n      this._applyModeFilters(this.options.mode);\n    }\n\n    const isAdvanced = this._mode === this.constructor.MODES.ADVANCED;\n    const tab = this.constructor.TABS.find(t => t.tab === this.options.tab);\n    if ( !tab || (!!tab.advanced !== isAdvanced) ) this.options.tab = isAdvanced ? \"actors\" : \"classes\";\n    this._applyTabFilters(this.options.tab);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    id: \"compendium-browser-{id}\",\n    classes: [\"compendium-browser\", \"vertical-tabs\"],\n    tag: \"form\",\n    window: {\n      title: \"DND5E.CompendiumBrowser.Title\",\n      minimizable: true,\n      resizable: true\n    },\n    actions: {\n      configureSources: CompendiumBrowser.#onConfigureSources,\n      clearName: CompendiumBrowser.#onClearName,\n      openLink: CompendiumBrowser.#onOpenLink,\n      setFilter: CompendiumBrowser.#onSetFilter,\n      setType: CompendiumBrowser.#onSetType,\n      toggleCollapse: CompendiumBrowser.#onToggleCollapse,\n      toggleMode: CompendiumBrowser.#onToggleMode\n    },\n    form: {\n      handler: CompendiumBrowser.#onHandleSubmit,\n      closeOnSubmit: true\n    },\n    position: {\n      width: 850,\n      height: 700\n    },\n    filters: {\n      locked: {},\n      initial: {\n        documentClass: \"Item\",\n        types: new Set([\"class\"])\n      }\n    },\n    selection: {\n      min: null,\n      max: null\n    },\n    tab: \"classes\"\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    header: {\n      id: \"header\",\n      classes: [\"header\"],\n      template: \"systems/dnd5e/templates/compendium/browser-header.hbs\"\n    },\n    search: {\n      id: \"sidebar-search\",\n      classes: [\"filter-element\"],\n      container: { id: \"sidebar\", classes: [\"sidebar\", \"flexcol\"] },\n      template: \"systems/dnd5e/templates/compendium/browser-sidebar-search.hbs\"\n    },\n    types: {\n      id: \"sidebar-types\",\n      container: { id: \"sidebar\", classes: [\"sidebar\", \"flexcol\"] },\n      template: \"systems/dnd5e/templates/compendium/browser-sidebar-types.hbs\"\n    },\n    filters: {\n      id: \"sidebar-filters\",\n      container: { id: \"sidebar\", classes: [\"sidebar\", \"flexcol\"] },\n      template: \"systems/dnd5e/templates/compendium/browser-sidebar-filters.hbs\",\n      templates: [\"systems/dnd5e/templates/compendium/browser-sidebar-filter-set.hbs\"]\n    },\n    results: {\n      id: \"results\",\n      classes: [\"results\"],\n      template: \"systems/dnd5e/templates/compendium/browser-results.hbs\",\n      templates: [\"systems/dnd5e/templates/compendium/browser-entry.hbs\"],\n      scrollable: [\"\"]\n    },\n    footer: {\n      id: \"footer\",\n      classes: [\"footer\"],\n      template: \"systems/dnd5e/templates/compendium/browser-footer.hbs\"\n    },\n    tabs: {\n      id: \"tabs\",\n      classes: [\"tabs\", \"tabs-left\"],\n      template: \"systems/dnd5e/templates/compendium/browser-tabs.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /**\n@typedef {SheetTabDescriptor5e} CompendiumBrowserTabDescriptor5e\n@property {string} documentClass  The class of Documents this tab contains.\n@property {string[]} [types]      The sub-types of Documents this tab contains, otherwise all types of the Document\n                                  class are assumed.\n@property {boolean} [advanced]    Is this tab only available in the advanced browsing mode.\n/\n\n  /**\nApplication tabs.\n@type {CompendiumBrowserTabDescriptor5e[]}\n/\n  static TABS = [\n    {\n      tab: \"classes\",\n      label: \"TYPES.Item.classPl\",\n      svg: \"systems/dnd5e/icons/svg/items/class.svg\",\n      documentClass: \"Item\",\n      types: [\"class\"]\n    },\n    {\n      tab: \"subclasses\",\n      label: \"TYPES.Item.subclassPl\",\n      svg: \"systems/dnd5e/icons/svg/items/subclass.svg\",\n      documentClass: \"Item\",\n      types: [\"subclass\"]\n    },\n    {\n      tab: \"races\",\n      label: \"TYPES.Item.racePl\",\n      svg: \"systems/dnd5e/icons/svg/items/race.svg\",\n      documentClass: \"Item\",\n      types: [\"race\"]\n    },\n    {\n      tab: \"feats\",\n      label: \"DND5E.CompendiumBrowser.Tabs.Feat.other\",\n      icon: \"fas fa-star\",\n      documentClass: \"Item\",\n      types: [\"feat\"]\n    },\n    {\n      tab: \"backgrounds\",\n      label: \"TYPES.Item.backgroundPl\",\n      svg: \"systems/dnd5e/icons/svg/items/background.svg\",\n      documentClass: \"Item\",\n      types: [\"background\"]\n    },\n    {\n      tab: \"physical\",\n      label: \"DND5E.CompendiumBrowser.Tabs.Item.other\",\n      svg: \"systems/dnd5e/icons/svg/backpack.svg\",\n      documentClass: \"Item\",\n      types: [\"physical\"]\n    },\n    {\n      tab: \"spells\",\n      label: \"TYPES.Item.spellPl\",\n      icon: \"fas fa-book\",\n      documentClass: \"Item\",\n      types: [\"spell\"]\n    },\n    {\n      tab: \"monsters\",\n      label: \"DND5E.CompendiumBrowser.Tabs.Monster.other\",\n      svg: \"systems/dnd5e/icons/svg/monster.svg\",\n      documentClass: \"Actor\",\n      types: [\"npc\"]\n    },\n    {\n      tab: \"vehicles\",\n      label: \"TYPES.Actor.vehiclePl\",\n      svg: \"systems/dnd5e/icons/svg/vehicle.svg\",\n      documentClass: \"Actor\",\n      types: [\"vehicle\"]\n    },\n    {\n      tab: \"actors\",\n      label: \"DOCUMENT.Actors\",\n      svg: \"systems/dnd5e/icons/svg/monster.svg\",\n      documentClass: \"Actor\",\n      advanced: true\n    },\n    {\n      tab: \"items\",\n      label: \"DOCUMENT.Items\",\n      svg: \"systems/dnd5e/icons/svg/backpack.svg\",\n      documentClass: \"Item\",\n      advanced: true\n    }\n  ];\n\n  /* -------------------------------------------- */\n\n  /**\nAvailable filtering modes.\n@enum {number}\n/\n  static MODES = {\n    BASIC: 1,\n    ADVANCED: 2\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nBatching configuration.\n@type {Record<string, number>}\n/\n  static BATCHING = {\n    /**\nThe number of pixels before reaching the end of the scroll container to begin loading additional entries.\n/\n    MARGIN: 50,\n\n    /**\nThe number of entries to load per batch.\n/\n    SIZE: 50\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nThe number of milliseconds to delay between user keypresses before executing a search.\n@type {number}\n/\n  static SEARCH_DELAY = 200;\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nShould the selection controls be displayed?\n@type {boolean}\n/\n  get displaySelection() {\n    return !!this.options.selection.min || !!this.options.selection.max;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCurrently defined filters.\n/\n  #filters;\n\n  /**\nCurrent filters selected.\n@type {CompendiumBrowserFilters}\n/\n  get currentFilters() {\n    const filters = foundry.utils.mergeObject(\n      this.#filters,\n      this.options.filters.locked,\n      { inplace: false }\n    );\n    filters.documentClass ??= \"Item\";\n    if ( filters.additional?.source ) {\n      filters.additional.source = Object.entries(filters.additional.source).reduce((obj, [k, v]) => {\n        obj[k.slugify({ strict: true })] = v;\n        return obj;\n      }, {});\n    }\n    return filters;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nFetched results.\n@type {Promise<object[]|Document[]>|object[]|Document[]}\n/\n  #results;\n\n  /* -------------------------------------------- */\n\n  /**\nThe index of the next result to render as part of batching.\n@type {number}\n/\n  #resultIndex = -1;\n\n  /* -------------------------------------------- */\n\n  /**\nWhether rendering is currently throttled.\n@type {boolean}\n/\n  #renderThrottle = false;\n\n  /* -------------------------------------------- */\n\n  /**\nUUIDs of currently selected documents.\n@type {Set<string>}\n/\n  #selected = new Set();\n\n  get selected() {\n    return this.#selected;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nSuffix used for localization selection messages based on min and max values.\n@type {string|null}",
      "min": "",
      "_debouncedSearch": "",
      "context": "",
      "dataModels": "",
      "filterDefinitions": "",
      "k": "",
      "value": "",
      "displaySelection": "",
      "invalid": "",
      "suffix": "",
      "summary": "",
      "showModeToggle": "",
      "isLocked": "",
      "types": "",
      "documentClass": "",
      "partId": "",
      "sort": "",
      "results": "",
      "tabs": "",
      "advanced": "",
      "activeTab": "",
      "active": "",
      "frame": "",
      "action": "",
      "subtitle": "",
      "html": "",
      "template": "",
      "innerHTML": "",
      "element": "",
      "tooltip": "",
      "tooltipClass": "",
      "rendered": "",
      "batchEnd": "",
      "i": "",
      "hidden": "",
      "part": "",
      "sources": "",
      "id": "",
      "locked": "",
      "filter": "",
      "options": "@typedef {ApplicationConfiguration} CompendiumBrowserConfiguration\n@property {{locked: CompendiumBrowserFilters, initial: CompendiumBrowserFilters}} filters  Filters to set to start.\n                                             Locked filters won't be able to be changed by the user. Initial filters\n                                             will be set to start but can be changed.\n@property {CompendiumBrowserSelectionConfiguration} selection  Configuration used to define document selections.\n/\n\n/**\n@typedef {object} CompendiumBrowserSelectionConfiguration\n@property {number|null} min                  Minimum number of documents that must be selected.\n@property {number|null} max                  Maximum number of documents that must be selected.\n/\n\n/**\n@typedef {object} CompendiumBrowserFilters\n@property {string} [documentClass]  Document type to fetch (e.g. Actor or Item).\n@property {Set<string>} [types]     Individual document subtypes to filter upon (e.g. \"loot\", \"class\", \"npc\").\n@property {object} [additional]     Additional type-specific filters applied.\n@property {FilterDescription[]} [arbitrary]  Additional arbitrary filters to apply, not displayed in the UI.\n                                    Only available as part of locked filters.\n@property {string} [name]           A substring to filter by Document name.\n/\n\n/**\nFilter definition object for additional filters in the Compendium Browser.\n@typedef {object} CompendiumBrowserFilterDefinitionEntry\n@property {string} label                                   Localizable label for the filter.\n@property {\"boolean\"|\"range\"|\"set\"} type                   Type of filter control to display.\n@property {object} config                                  Type-specific configuration data.\n@property {CompendiumBrowserCreateFilters} [createFilter]  Method that can be called to create filters.\n/\n\n/**\n@callback CompendiumBrowserFilterCreateFilters\n@param {FilterDescription[]} filters                        Array of filters to be applied that should be mutated.\n@param {*} value                                            Value of the filter.\n@param {CompendiumBrowserFilterDefinitionEntry} definition  Definition for this filter.\n/\n\n/**\n@typedef {Map<string, CompendiumBrowserFilterDefinitionEntry>} CompendiumBrowserFilterDefinition\n/\n\n/**\nApplication for browsing, filtering, and searching for content between multiple compendiums.\n@extends Application5e\n@template CompendiumBrowserConfiguration\n/\nexport default class CompendiumBrowser extends Application5e {\n  constructor(...args) {\n    super(...args);\n\n    this.#filters = this.options.filters?.initial ?? {};\n\n    if ( \"mode\" in this.options ) {\n      this._mode = this.options.mode;\n      this._applyModeFilters(this.options.mode);\n    }\n\n    const isAdvanced = this._mode === this.constructor.MODES.ADVANCED;\n    const tab = this.constructor.TABS.find(t => t.tab === this.options.tab);\n    if ( !tab || (!!tab.advanced !== isAdvanced) ) this.options.tab = isAdvanced ? \"actors\" : \"classes\";\n    this._applyTabFilters(this.options.tab);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    id: \"compendium-browser-{id}\",\n    classes: [\"compendium-browser\", \"vertical-tabs\"],\n    tag: \"form\",\n    window: {\n      title: \"DND5E.CompendiumBrowser.Title\",\n      minimizable: true,\n      resizable: true\n    },\n    actions: {\n      configureSources: CompendiumBrowser.#onConfigureSources,\n      clearName: CompendiumBrowser.#onClearName,\n      openLink: CompendiumBrowser.#onOpenLink,\n      setFilter: CompendiumBrowser.#onSetFilter,\n      setType: CompendiumBrowser.#onSetType,\n      toggleCollapse: CompendiumBrowser.#onToggleCollapse,\n      toggleMode: CompendiumBrowser.#onToggleMode\n    },\n    form: {\n      handler: CompendiumBrowser.#onHandleSubmit,\n      closeOnSubmit: true\n    },\n    position: {\n      width: 850,\n      height: 700\n    },\n    filters: {\n      locked: {},\n      initial: {\n        documentClass: \"Item\",\n        types: new Set([\"class\"])\n      }\n    },\n    selection: {\n      min: null,\n      max: null\n    },\n    tab: \"classes\"\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    header: {\n      id: \"header\",\n      classes: [\"header\"],\n      template: \"systems/dnd5e/templates/compendium/browser-header.hbs\"\n    },\n    search: {\n      id: \"sidebar-search\",\n      classes: [\"filter-element\"],\n      container: { id: \"sidebar\", classes: [\"sidebar\", \"flexcol\"] },\n      template: \"systems/dnd5e/templates/compendium/browser-sidebar-search.hbs\"\n    },\n    types: {\n      id: \"sidebar-types\",\n      container: { id: \"sidebar\", classes: [\"sidebar\", \"flexcol\"] },\n      template: \"systems/dnd5e/templates/compendium/browser-sidebar-types.hbs\"\n    },\n    filters: {\n      id: \"sidebar-filters\",\n      container: { id: \"sidebar\", classes: [\"sidebar\", \"flexcol\"] },\n      template: \"systems/dnd5e/templates/compendium/browser-sidebar-filters.hbs\",\n      templates: [\"systems/dnd5e/templates/compendium/browser-sidebar-filter-set.hbs\"]\n    },\n    results: {\n      id: \"results\",\n      classes: [\"results\"],\n      template: \"systems/dnd5e/templates/compendium/browser-results.hbs\",\n      templates: [\"systems/dnd5e/templates/compendium/browser-entry.hbs\"],\n      scrollable: [\"\"]\n    },\n    footer: {\n      id: \"footer\",\n      classes: [\"footer\"],\n      template: \"systems/dnd5e/templates/compendium/browser-footer.hbs\"\n    },\n    tabs: {\n      id: \"tabs\",\n      classes: [\"tabs\", \"tabs-left\"],\n      template: \"systems/dnd5e/templates/compendium/browser-tabs.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /**\n@typedef {SheetTabDescriptor5e} CompendiumBrowserTabDescriptor5e\n@property {string} documentClass  The class of Documents this tab contains.\n@property {string[]} [types]      The sub-types of Documents this tab contains, otherwise all types of the Document\n                                  class are assumed.\n@property {boolean} [advanced]    Is this tab only available in the advanced browsing mode.\n/\n\n  /**\nApplication tabs.\n@type {CompendiumBrowserTabDescriptor5e[]}\n/\n  static TABS = [\n    {\n      tab: \"classes\",\n      label: \"TYPES.Item.classPl\",\n      svg: \"systems/dnd5e/icons/svg/items/class.svg\",\n      documentClass: \"Item\",\n      types: [\"class\"]\n    },\n    {\n      tab: \"subclasses\",\n      label: \"TYPES.Item.subclassPl\",\n      svg: \"systems/dnd5e/icons/svg/items/subclass.svg\",\n      documentClass: \"Item\",\n      types: [\"subclass\"]\n    },\n    {\n      tab: \"races\",\n      label: \"TYPES.Item.racePl\",\n      svg: \"systems/dnd5e/icons/svg/items/race.svg\",\n      documentClass: \"Item\",\n      types: [\"race\"]\n    },\n    {\n      tab: \"feats\",\n      label: \"DND5E.CompendiumBrowser.Tabs.Feat.other\",\n      icon: \"fas fa-star\",\n      documentClass: \"Item\",\n      types: [\"feat\"]\n    },\n    {\n      tab: \"backgrounds\",\n      label: \"TYPES.Item.backgroundPl\",\n      svg: \"systems/dnd5e/icons/svg/items/background.svg\",\n      documentClass: \"Item\",\n      types: [\"background\"]\n    },\n    {\n      tab: \"physical\",\n      label: \"DND5E.CompendiumBrowser.Tabs.Item.other\",\n      svg: \"systems/dnd5e/icons/svg/backpack.svg\",\n      documentClass: \"Item\",\n      types: [\"physical\"]\n    },\n    {\n      tab: \"spells\",\n      label: \"TYPES.Item.spellPl\",\n      icon: \"fas fa-book\",\n      documentClass: \"Item\",\n      types: [\"spell\"]\n    },\n    {\n      tab: \"monsters\",\n      label: \"DND5E.CompendiumBrowser.Tabs.Monster.other\",\n      svg: \"systems/dnd5e/icons/svg/monster.svg\",\n      documentClass: \"Actor\",\n      types: [\"npc\"]\n    },\n    {\n      tab: \"vehicles\",\n      label: \"TYPES.Actor.vehiclePl\",\n      svg: \"systems/dnd5e/icons/svg/vehicle.svg\",\n      documentClass: \"Actor\",\n      types: [\"vehicle\"]\n    },\n    {\n      tab: \"actors\",\n      label: \"DOCUMENT.Actors\",\n      svg: \"systems/dnd5e/icons/svg/monster.svg\",\n      documentClass: \"Actor\",\n      advanced: true\n    },\n    {\n      tab: \"items\",\n      label: \"DOCUMENT.Items\",\n      svg: \"systems/dnd5e/icons/svg/backpack.svg\",\n      documentClass: \"Item\",\n      advanced: true\n    }\n  ];\n\n  /* -------------------------------------------- */\n\n  /**\nAvailable filtering modes.\n@enum {number}\n/\n  static MODES = {\n    BASIC: 1,\n    ADVANCED: 2\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nBatching configuration.\n@type {Record<string, number>}\n/\n  static BATCHING = {\n    /**\nThe number of pixels before reaching the end of the scroll container to begin loading additional entries.\n/\n    MARGIN: 50,\n\n    /**\nThe number of entries to load per batch.\n/\n    SIZE: 50\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nThe number of milliseconds to delay between user keypresses before executing a search.\n@type {number}\n/\n  static SEARCH_DELAY = 200;\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nShould the selection controls be displayed?\n@type {boolean}\n/\n  get displaySelection() {\n    return !!this.options.selection.min || !!this.options.selection.max;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCurrently defined filters.\n/\n  #filters;\n\n  /**\nCurrent filters selected.\n@type {CompendiumBrowserFilters}\n/\n  get currentFilters() {\n    const filters = foundry.utils.mergeObject(\n      this.#filters,\n      this.options.filters.locked,\n      { inplace: false }\n    );\n    filters.documentClass ??= \"Item\";\n    if ( filters.additional?.source ) {\n      filters.additional.source = Object.entries(filters.additional.source).reduce((obj, [k, v]) => {\n        obj[k.slugify({ strict: true })] = v;\n        return obj;\n      }, {});\n    }\n    return filters;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nFetched results.\n@type {Promise<object[]|Document[]>|object[]|Document[]}\n/\n  #results;\n\n  /* -------------------------------------------- */\n\n  /**\nThe index of the next result to render as part of batching.\n@type {number}\n/\n  #resultIndex = -1;\n\n  /* -------------------------------------------- */\n\n  /**\nWhether rendering is currently throttled.\n@type {boolean}\n/\n  #renderThrottle = false;\n\n  /* -------------------------------------------- */\n\n  /**\nUUIDs of currently selected documents.\n@type {Set<string>}\n/\n  #selected = new Set();\n\n  get selected() {\n    return this.#selected;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nSuffix used for localization selection messages based on min and max values.\n@type {string|null}\n/\n  get #selectionLocalizationSuffix() {\n    const max = this.options.selection.max;\n    const min = this.options.selection.min;\n    if ( !min && !max ) return null;\n    if ( !min && max ) return \"Max\";\n    if ( min && !max ) return \"Min\";\n    if ( min !== max ) return \"Range\";\n    return \"Single\";\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe cached set of available sources to filter on.\n@type {Record<string, string>}\n/\n  #sources;\n\n  /* -------------------------------------------- */\n\n  /**\nThe mode the browser is currently in.\n@type {CompendiumBrowser.MODES}\n/\n  _mode = this.constructor.MODES.BASIC;\n\n  /* -------------------------------------------- */\n\n  /**\nThe function to invoke when searching results by name.\n@type {Function}\n/\n  _debouncedSearch = foundry.utils.debounce(this._onSearchName.bind(this), this.constructor.SEARCH_DELAY);\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _configureRenderOptions(options) {\n    super._configureRenderOptions(options);\n    if ( options.isFirstRender ) {\n      const tab = this.constructor.TABS.find(t => t.tab === this.options.tab);\n      if ( tab ) foundry.utils.setProperty(options, \"dnd5e.browser.types\", tab.types);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _prepareContext(options) {\n    const context = await super._prepareContext(options);\n    context.filters = this.currentFilters;\n\n    let dataModels = Object.entries(CONFIG[context.filters.documentClass].dataModels);\n    if ( context.filters.types?.size ) dataModels = dataModels.filter(([type]) => context.filters.types.has(type));\n    context.filterDefinitions = dataModels\n      .map(([, d]) => d.compendiumBrowserFilters ?? new Map())\n      .reduce((first, second) => {\n        if ( !first ) return second;\n        return CompendiumBrowser.intersectFilters(first, second);\n      }, null) ?? new Map();\n    context.filterDefinitions.set(\"source\", {\n      label: \"DND5E.SOURCE.FIELDS.source.label\",\n      type: \"set\",\n      config: {\n        keyPath: \"system.source.slug\",\n        choices: foundry.utils.mergeObject(\n          this.#sources ?? {},\n          Object.fromEntries(Object.keys(this.options.filters?.locked?.additional?.source ?? {}).map(k => {\n            return [k.slugify({ strict: true }), CONFIG.DND5E.sourceBooks[k] ?? k];\n          })), { inplace: false }\n        )\n      }\n    });\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _preparePartContext(partId, context, options) {\n    await super._preparePartContext(partId, context, options);\n    switch ( partId ) {\n      case \"documentClass\":\n      case \"types\":\n      case \"filters\": return this._prepareSidebarContext(partId, context, options);\n      case \"results\": return this._prepareResultsContext(context, options);\n      case \"footer\": return this._prepareFooterContext(context, options);\n      case \"tabs\": return this._prepareTabsContext(context, options);\n      case \"header\": return this._prepareHeaderContext(context, options);\n    }\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the footer context.\n@param {ApplicationRenderContext} context     Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options      Options which configure application rendering behavior.\n@returns {Promise<ApplicationRenderContext>}  Context data for a specific part.\n@protected\n/\n  async _prepareFooterContext(context, options) {\n    const value = this.#selected.size;\n    const { max, min } = this.options.selection;\n\n    context.displaySelection = this.displaySelection;\n    context.invalid = (value < (min || -Infinity)) || (value > (max || Infinity)) ? \"invalid\" : \"\";\n    const suffix = this.#selectionLocalizationSuffix;\n    context.summary = suffix ? game.i18n.format(\n      `DND5E.CompendiumBrowser.Selection.Summary.${suffix}`, { max, min, value }\n    ) : value;\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the header context.\n@param {ApplicationRenderContext} context  Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options   Options which configure rendering behavior.\n@returns {Promise<ApplicationRenderContext>}\n@protected\n/\n  async _prepareHeaderContext(context, options) {\n    context.showModeToggle = foundry.utils.isEmpty(this.options.filters.locked);\n    context.isAdvanced = this._mode === this.constructor.MODES.ADVANCED;\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the sidebar context.\n@param {string} partId                        The part being rendered.\n@param {ApplicationRenderContext} context     Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options      Options which configure application rendering behavior.\n@returns {Promise<ApplicationRenderContext>}  Context data for a specific part.\n@protected\n/\n  async _prepareSidebarContext(partId, context, options) {\n    context.isLocked = {};\n    context.isLocked.filters = (\"additional\" in this.options.filters.locked);\n    context.isLocked.types = (\"types\" in this.options.filters.locked) || context.isLocked.filters;\n    context.isLocked.documentClass = (\"documentClass\" in this.options.filters.locked) || context.isLocked.types;\n    const types = foundry.utils.getProperty(options, \"dnd5e.browser.types\") ?? [];\n\n    if ( partId === \"types\" ) {\n      context.showTypes = (types.length !== 1) || (types[0] === \"physical\");\n      context.types = CONFIG[context.filters.documentClass].documentClass.compendiumBrowserTypes({\n        chosen: context.filters.types\n      });\n\n      // Special case handling for 'Items' tab in basic mode.\n      if ( types[0] === \"physical\" ) context.types = context.types.physical.children;\n\n      if ( context.isLocked.types ) {\n        for ( const [key, value] of Object.entries(context.types) ) {\n          if ( !value.children && !value.chosen ) delete context.types[key];\n          else if ( value.children ) {\n            for ( const [k, v] of Object.entries(value.children) ) {\n              if ( !v.chosen ) delete value.children[k];\n            }\n            if ( foundry.utils.isEmpty(value.children) ) delete context.types[key];\n          }\n        }\n      }\n    }\n\n    else if ( partId === \"filters\" ) {\n      context.additional = Array.from(context.filterDefinitions?.entries() ?? []).reduce((arr, [key, data]) => {\n        // Special case handling for 'Feats' tab in basic mode.\n        if ( (types[0] === \"feat\") && ((key === \"category\") || (key === \"subtype\")) ) return arr;\n\n        let sort = 0;\n        switch ( data.type ) {\n          case \"boolean\": sort = 1; break;\n          case \"range\": sort = 2; break;\n          case \"set\": sort = 3; break;\n        }\n\n        arr.push(foundry.utils.mergeObject(data, {\n          key, sort,\n          value: context.filters.additional?.[key],\n          locked: this.options.filters.locked?.additional?.[key]\n        }, { inplace: false }));\n        return arr;\n      }, []);\n\n      context.additional.sort((a, b) => a.sort - b.sort);\n    }\n\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the results context.\n@param {ApplicationRenderContext} context     Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options      Options which configure application rendering behavior.\n@returns {Promise<ApplicationRenderContext>}  Context data for a specific part.\n@protected\n/\n  async _prepareResultsContext(context, options) {\n    // TODO: Determine if new set of results need to be fetched, otherwise use old results and re-sort as necessary\n    // Sorting changes alone shouldn't require a re-fetch, but any change to filters will\n    const filters = CompendiumBrowser.applyFilters(context.filterDefinitions, context.filters.additional);\n    // Add the name & arbitrary filters\n    if ( this.#filters.name?.length ) filters.push({ k: \"name\", o: \"icontains\", v: this.#filters.name });\n    if ( context.filters.arbitrary?.length ) filters.push(...context.filters.arbitrary);\n    this.#results = CompendiumBrowser.fetch(CONFIG[context.filters.documentClass].documentClass, {\n      filters,\n      types: context.filters.types,\n      indexFields: new Set([\"system.source\"])\n    });\n    context.displaySelection = this.displaySelection;\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the tabs context.\n@param {ApplicationRenderContext} context  Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options   Options which configure application rendering behavior.\n@returns {Promise<ApplicationRenderContext>}\n@protected\n/\n  async _prepareTabsContext(context, options) {\n    // If we are locked to a particular filter, do not show tabs.\n    if ( !foundry.utils.isEmpty(this.options.filters.locked) ) {\n      context.tabs = [];\n      return context;\n    }\n\n    const advanced = this._mode === this.constructor.MODES.ADVANCED;\n    context.tabs = foundry.utils.deepClone(this.constructor.TABS.filter(t => !!t.advanced === advanced));\n    const tab = options.isFirstRender ? this.options.tab : this.tabGroups.primary;\n    const activeTab = context.tabs.find(t => t.tab === tab) ?? context.tabs[0];\n    activeTab.active = true;\n\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _renderFrame(options) {\n    const frame = await super._renderFrame(options);\n    if ( game.user.isGM ) {\n      frame.querySelector('[data-action=\"close\"]').insertAdjacentHTML(\"beforebegin\", `\n        <button type=\"button\" class=\"header-control fas fa-cog icon\" data-action=\"configureSources\"\n                data-tooltip=\"DND5E.CompendiumBrowser.Sources.Label\"\n                aria-label=\"${game.i18n.localize(\"DND5E.CompendiumBrowser.Sources.Label\")}\"></button>\n      `);\n    }\n    return frame;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRender a single result entry.\n@param {object|Document} entry  The entry.\n@param {string} documentClass   The entry's Document class.\n@returns {Promise<HTMLElement>}\n@protected\n/\n  async _renderResult(entry, documentClass) {\n    const { img, name, type, uuid, system } = entry;\n    // TODO: Provide more useful subtitles.\n    const subtitle = CONFIG[documentClass].typeLabels[type] ?? \"\";\n    const source = system?.source?.value ?? \"\";\n    const context = {\n      entry: { img, name, subtitle, uuid, source },\n      displaySelection: this.displaySelection,\n      selected: this.#selected.has(uuid)\n    };\n    const html = await renderTemplate(\"systems/dnd5e/templates/compendium/browser-entry.hbs\", context);\n    const template = document.createElement(\"template\");\n    template.innerHTML = html;\n    const element = template.content.firstElementChild;\n    if ( documentClass !== \"Item\" ) return element;\n    element.dataset.tooltip = `\n      <section class=\"loading\" data-uuid=\"${uuid}\">\n        <i class=\"fa-solid fa-spinner fa-spin-pulse\" inert></i>\n      </section>\n    `;\n    element.dataset.tooltipClass = \"dnd5e2 dnd5e-tooltip item-tooltip\";\n    element.dataset.tooltipDirection ??= \"RIGHT\";\n    return element;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRender results once loaded to avoid holding up initial app display.\n@protected\n/\n  async _renderResults() {\n    let rendered = [];\n    const { documentClass } = this.currentFilters;\n    const results = await this.#results;\n    this.#results = results;\n    const batchEnd = Math.min(this.constructor.BATCHING.SIZE, results.length);\n    for ( let i = 0; i < batchEnd; i++ ) {\n      rendered.push(this._renderResult(results[i], documentClass));\n    }\n    this.element.querySelector(\".results-loading\").hidden = true;\n    this.element.querySelector('[data-application-part=\"results\"] .item-list')\n      .replaceChildren(...(await Promise.all(rendered)));\n    this.#resultIndex = batchEnd;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShow a list of applicable source filters for the available results.\n@protected\n/\n  async _renderSourceFilters() {\n    const sources = [];\n    for ( const result of this.#results ) {\n      const source = foundry.utils.getProperty(result, \"system.source\");\n      if ( foundry.utils.getType(source) !== \"Object\" ) continue;\n      const { slug, value } = source;\n      sources.push({ slug, value: CONFIG.DND5E.sourceBooks[value] ?? value });\n    }\n    sources.sort((a, b) => a.value.localeCompare(b.value, game.i18n.lang));\n    this.#sources = Object.fromEntries(sources.map(({ slug, value }) => [slug, value]));\n    const filters = this.element.querySelector('[data-application-part=\"filters\"]');\n    filters.querySelector('[data-filter-id=\"source\"]')?.remove();\n    if ( !sources.length ) return;\n    const locked = Object.entries(this.options.filters?.locked?.additional?.source ?? {}).reduce((obj, [k, v]) => {\n      obj[k.slugify({ strict: true })] = v;\n      return obj;\n    }, {});\n    const filter = await renderTemplate(\"systems/dnd5e/templates/compendium/browser-sidebar-filter-set.hbs\", {\n      locked,\n      value: locked,\n      key: \"source\",\n      label: \"DND5E.SOURCE.FIELDS.source.label\",\n      config: { choices: this.#sources }\n    });\n    filters.insertAdjacentHTML(\"beforeend\", filter);\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers                */\n  /* --------------------------------------------",
      "target": "",
      "event": "",
      "group": "",
      "children": "",
      "e": "",
      "indeterminate": "",
      "checked": "",
      "name": "",
      "handler": "",
      "batchStart": "",
      "input": "",
      "pr": "",
      "existingValue": "",
      "tagName": "",
      "indexFields": "",
      "documents": "",
      "sortFunc": "",
      "def": "",
      "choices": "",
      "_blank": "",
      "v": "",
      "button": "@typedef {ApplicationConfiguration} CompendiumBrowserConfiguration\n@property {{locked: CompendiumBrowserFilters, initial: CompendiumBrowserFilters}} filters  Filters to set to start.\n                                             Locked filters won't be able to be changed by the user. Initial filters\n                                             will be set to start but can be changed.\n@property {CompendiumBrowserSelectionConfiguration} selection  Configuration used to define document selections.\n/\n\n/**\n@typedef {object} CompendiumBrowserSelectionConfiguration\n@property {number|null} min                  Minimum number of documents that must be selected.\n@property {number|null} max                  Maximum number of documents that must be selected.\n/\n\n/**\n@typedef {object} CompendiumBrowserFilters\n@property {string} [documentClass]  Document type to fetch (e.g. Actor or Item).\n@property {Set<string>} [types]     Individual document subtypes to filter upon (e.g. \"loot\", \"class\", \"npc\").\n@property {object} [additional]     Additional type-specific filters applied.\n@property {FilterDescription[]} [arbitrary]  Additional arbitrary filters to apply, not displayed in the UI.\n                                    Only available as part of locked filters.\n@property {string} [name]           A substring to filter by Document name.\n/\n\n/**\nFilter definition object for additional filters in the Compendium Browser.\n@typedef {object} CompendiumBrowserFilterDefinitionEntry\n@property {string} label                                   Localizable label for the filter.\n@property {\"boolean\"|\"range\"|\"set\"} type                   Type of filter control to display.\n@property {object} config                                  Type-specific configuration data.\n@property {CompendiumBrowserCreateFilters} [createFilter]  Method that can be called to create filters.\n/\n\n/**\n@callback CompendiumBrowserFilterCreateFilters\n@param {FilterDescription[]} filters                        Array of filters to be applied that should be mutated.\n@param {*} value                                            Value of the filter.\n@param {CompendiumBrowserFilterDefinitionEntry} definition  Definition for this filter.\n/\n\n/**\n@typedef {Map<string, CompendiumBrowserFilterDefinitionEntry>} CompendiumBrowserFilterDefinition\n/\n\n/**\nApplication for browsing, filtering, and searching for content between multiple compendiums.\n@extends Application5e\n@template CompendiumBrowserConfiguration\n/\nexport default class CompendiumBrowser extends Application5e {\n  constructor(...args) {\n    super(...args);\n\n    this.#filters = this.options.filters?.initial ?? {};\n\n    if ( \"mode\" in this.options ) {\n      this._mode = this.options.mode;\n      this._applyModeFilters(this.options.mode);\n    }\n\n    const isAdvanced = this._mode === this.constructor.MODES.ADVANCED;\n    const tab = this.constructor.TABS.find(t => t.tab === this.options.tab);\n    if ( !tab || (!!tab.advanced !== isAdvanced) ) this.options.tab = isAdvanced ? \"actors\" : \"classes\";\n    this._applyTabFilters(this.options.tab);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    id: \"compendium-browser-{id}\",\n    classes: [\"compendium-browser\", \"vertical-tabs\"],\n    tag: \"form\",\n    window: {\n      title: \"DND5E.CompendiumBrowser.Title\",\n      minimizable: true,\n      resizable: true\n    },\n    actions: {\n      configureSources: CompendiumBrowser.#onConfigureSources,\n      clearName: CompendiumBrowser.#onClearName,\n      openLink: CompendiumBrowser.#onOpenLink,\n      setFilter: CompendiumBrowser.#onSetFilter,\n      setType: CompendiumBrowser.#onSetType,\n      toggleCollapse: CompendiumBrowser.#onToggleCollapse,\n      toggleMode: CompendiumBrowser.#onToggleMode\n    },\n    form: {\n      handler: CompendiumBrowser.#onHandleSubmit,\n      closeOnSubmit: true\n    },\n    position: {\n      width: 850,\n      height: 700\n    },\n    filters: {\n      locked: {},\n      initial: {\n        documentClass: \"Item\",\n        types: new Set([\"class\"])\n      }\n    },\n    selection: {\n      min: null,\n      max: null\n    },\n    tab: \"classes\"\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    header: {\n      id: \"header\",\n      classes: [\"header\"],\n      template: \"systems/dnd5e/templates/compendium/browser-header.hbs\"\n    },\n    search: {\n      id: \"sidebar-search\",\n      classes: [\"filter-element\"],\n      container: { id: \"sidebar\", classes: [\"sidebar\", \"flexcol\"] },\n      template: \"systems/dnd5e/templates/compendium/browser-sidebar-search.hbs\"\n    },\n    types: {\n      id: \"sidebar-types\",\n      container: { id: \"sidebar\", classes: [\"sidebar\", \"flexcol\"] },\n      template: \"systems/dnd5e/templates/compendium/browser-sidebar-types.hbs\"\n    },\n    filters: {\n      id: \"sidebar-filters\",\n      container: { id: \"sidebar\", classes: [\"sidebar\", \"flexcol\"] },\n      template: \"systems/dnd5e/templates/compendium/browser-sidebar-filters.hbs\",\n      templates: [\"systems/dnd5e/templates/compendium/browser-sidebar-filter-set.hbs\"]\n    },\n    results: {\n      id: \"results\",\n      classes: [\"results\"],\n      template: \"systems/dnd5e/templates/compendium/browser-results.hbs\",\n      templates: [\"systems/dnd5e/templates/compendium/browser-entry.hbs\"],\n      scrollable: [\"\"]\n    },\n    footer: {\n      id: \"footer\",\n      classes: [\"footer\"],\n      template: \"systems/dnd5e/templates/compendium/browser-footer.hbs\"\n    },\n    tabs: {\n      id: \"tabs\",\n      classes: [\"tabs\", \"tabs-left\"],\n      template: \"systems/dnd5e/templates/compendium/browser-tabs.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /**\n@typedef {SheetTabDescriptor5e} CompendiumBrowserTabDescriptor5e\n@property {string} documentClass  The class of Documents this tab contains.\n@property {string[]} [types]      The sub-types of Documents this tab contains, otherwise all types of the Document\n                                  class are assumed.\n@property {boolean} [advanced]    Is this tab only available in the advanced browsing mode.\n/\n\n  /**\nApplication tabs.\n@type {CompendiumBrowserTabDescriptor5e[]}\n/\n  static TABS = [\n    {\n      tab: \"classes\",\n      label: \"TYPES.Item.classPl\",\n      svg: \"systems/dnd5e/icons/svg/items/class.svg\",\n      documentClass: \"Item\",\n      types: [\"class\"]\n    },\n    {\n      tab: \"subclasses\",\n      label: \"TYPES.Item.subclassPl\",\n      svg: \"systems/dnd5e/icons/svg/items/subclass.svg\",\n      documentClass: \"Item\",\n      types: [\"subclass\"]\n    },\n    {\n      tab: \"races\",\n      label: \"TYPES.Item.racePl\",\n      svg: \"systems/dnd5e/icons/svg/items/race.svg\",\n      documentClass: \"Item\",\n      types: [\"race\"]\n    },\n    {\n      tab: \"feats\",\n      label: \"DND5E.CompendiumBrowser.Tabs.Feat.other\",\n      icon: \"fas fa-star\",\n      documentClass: \"Item\",\n      types: [\"feat\"]\n    },\n    {\n      tab: \"backgrounds\",\n      label: \"TYPES.Item.backgroundPl\",\n      svg: \"systems/dnd5e/icons/svg/items/background.svg\",\n      documentClass: \"Item\",\n      types: [\"background\"]\n    },\n    {\n      tab: \"physical\",\n      label: \"DND5E.CompendiumBrowser.Tabs.Item.other\",\n      svg: \"systems/dnd5e/icons/svg/backpack.svg\",\n      documentClass: \"Item\",\n      types: [\"physical\"]\n    },\n    {\n      tab: \"spells\",\n      label: \"TYPES.Item.spellPl\",\n      icon: \"fas fa-book\",\n      documentClass: \"Item\",\n      types: [\"spell\"]\n    },\n    {\n      tab: \"monsters\",\n      label: \"DND5E.CompendiumBrowser.Tabs.Monster.other\",\n      svg: \"systems/dnd5e/icons/svg/monster.svg\",\n      documentClass: \"Actor\",\n      types: [\"npc\"]\n    },\n    {\n      tab: \"vehicles\",\n      label: \"TYPES.Actor.vehiclePl\",\n      svg: \"systems/dnd5e/icons/svg/vehicle.svg\",\n      documentClass: \"Actor\",\n      types: [\"vehicle\"]\n    },\n    {\n      tab: \"actors\",\n      label: \"DOCUMENT.Actors\",\n      svg: \"systems/dnd5e/icons/svg/monster.svg\",\n      documentClass: \"Actor\",\n      advanced: true\n    },\n    {\n      tab: \"items\",\n      label: \"DOCUMENT.Items\",\n      svg: \"systems/dnd5e/icons/svg/backpack.svg\",\n      documentClass: \"Item\",\n      advanced: true\n    }\n  ];\n\n  /* -------------------------------------------- */\n\n  /**\nAvailable filtering modes.\n@enum {number}\n/\n  static MODES = {\n    BASIC: 1,\n    ADVANCED: 2\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nBatching configuration.\n@type {Record<string, number>}\n/\n  static BATCHING = {\n    /**\nThe number of pixels before reaching the end of the scroll container to begin loading additional entries.\n/\n    MARGIN: 50,\n\n    /**\nThe number of entries to load per batch.\n/\n    SIZE: 50\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nThe number of milliseconds to delay between user keypresses before executing a search.\n@type {number}\n/\n  static SEARCH_DELAY = 200;\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nShould the selection controls be displayed?\n@type {boolean}\n/\n  get displaySelection() {\n    return !!this.options.selection.min || !!this.options.selection.max;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCurrently defined filters.\n/\n  #filters;\n\n  /**\nCurrent filters selected.\n@type {CompendiumBrowserFilters}\n/\n  get currentFilters() {\n    const filters = foundry.utils.mergeObject(\n      this.#filters,\n      this.options.filters.locked,\n      { inplace: false }\n    );\n    filters.documentClass ??= \"Item\";\n    if ( filters.additional?.source ) {\n      filters.additional.source = Object.entries(filters.additional.source).reduce((obj, [k, v]) => {\n        obj[k.slugify({ strict: true })] = v;\n        return obj;\n      }, {});\n    }\n    return filters;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nFetched results.\n@type {Promise<object[]|Document[]>|object[]|Document[]}\n/\n  #results;\n\n  /* -------------------------------------------- */\n\n  /**\nThe index of the next result to render as part of batching.\n@type {number}\n/\n  #resultIndex = -1;\n\n  /* -------------------------------------------- */\n\n  /**\nWhether rendering is currently throttled.\n@type {boolean}\n/\n  #renderThrottle = false;\n\n  /* -------------------------------------------- */\n\n  /**\nUUIDs of currently selected documents.\n@type {Set<string>}\n/\n  #selected = new Set();\n\n  get selected() {\n    return this.#selected;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nSuffix used for localization selection messages based on min and max values.\n@type {string|null}\n/\n  get #selectionLocalizationSuffix() {\n    const max = this.options.selection.max;\n    const min = this.options.selection.min;\n    if ( !min && !max ) return null;\n    if ( !min && max ) return \"Max\";\n    if ( min && !max ) return \"Min\";\n    if ( min !== max ) return \"Range\";\n    return \"Single\";\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe cached set of available sources to filter on.\n@type {Record<string, string>}\n/\n  #sources;\n\n  /* -------------------------------------------- */\n\n  /**\nThe mode the browser is currently in.\n@type {CompendiumBrowser.MODES}\n/\n  _mode = this.constructor.MODES.BASIC;\n\n  /* -------------------------------------------- */\n\n  /**\nThe function to invoke when searching results by name.\n@type {Function}\n/\n  _debouncedSearch = foundry.utils.debounce(this._onSearchName.bind(this), this.constructor.SEARCH_DELAY);\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _configureRenderOptions(options) {\n    super._configureRenderOptions(options);\n    if ( options.isFirstRender ) {\n      const tab = this.constructor.TABS.find(t => t.tab === this.options.tab);\n      if ( tab ) foundry.utils.setProperty(options, \"dnd5e.browser.types\", tab.types);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _prepareContext(options) {\n    const context = await super._prepareContext(options);\n    context.filters = this.currentFilters;\n\n    let dataModels = Object.entries(CONFIG[context.filters.documentClass].dataModels);\n    if ( context.filters.types?.size ) dataModels = dataModels.filter(([type]) => context.filters.types.has(type));\n    context.filterDefinitions = dataModels\n      .map(([, d]) => d.compendiumBrowserFilters ?? new Map())\n      .reduce((first, second) => {\n        if ( !first ) return second;\n        return CompendiumBrowser.intersectFilters(first, second);\n      }, null) ?? new Map();\n    context.filterDefinitions.set(\"source\", {\n      label: \"DND5E.SOURCE.FIELDS.source.label\",\n      type: \"set\",\n      config: {\n        keyPath: \"system.source.slug\",\n        choices: foundry.utils.mergeObject(\n          this.#sources ?? {},\n          Object.fromEntries(Object.keys(this.options.filters?.locked?.additional?.source ?? {}).map(k => {\n            return [k.slugify({ strict: true }), CONFIG.DND5E.sourceBooks[k] ?? k];\n          })), { inplace: false }\n        )\n      }\n    });\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _preparePartContext(partId, context, options) {\n    await super._preparePartContext(partId, context, options);\n    switch ( partId ) {\n      case \"documentClass\":\n      case \"types\":\n      case \"filters\": return this._prepareSidebarContext(partId, context, options);\n      case \"results\": return this._prepareResultsContext(context, options);\n      case \"footer\": return this._prepareFooterContext(context, options);\n      case \"tabs\": return this._prepareTabsContext(context, options);\n      case \"header\": return this._prepareHeaderContext(context, options);\n    }\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the footer context.\n@param {ApplicationRenderContext} context     Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options      Options which configure application rendering behavior.\n@returns {Promise<ApplicationRenderContext>}  Context data for a specific part.\n@protected\n/\n  async _prepareFooterContext(context, options) {\n    const value = this.#selected.size;\n    const { max, min } = this.options.selection;\n\n    context.displaySelection = this.displaySelection;\n    context.invalid = (value < (min || -Infinity)) || (value > (max || Infinity)) ? \"invalid\" : \"\";\n    const suffix = this.#selectionLocalizationSuffix;\n    context.summary = suffix ? game.i18n.format(\n      `DND5E.CompendiumBrowser.Selection.Summary.${suffix}`, { max, min, value }\n    ) : value;\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the header context.\n@param {ApplicationRenderContext} context  Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options   Options which configure rendering behavior.\n@returns {Promise<ApplicationRenderContext>}\n@protected\n/\n  async _prepareHeaderContext(context, options) {\n    context.showModeToggle = foundry.utils.isEmpty(this.options.filters.locked);\n    context.isAdvanced = this._mode === this.constructor.MODES.ADVANCED;\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the sidebar context.\n@param {string} partId                        The part being rendered.\n@param {ApplicationRenderContext} context     Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options      Options which configure application rendering behavior.\n@returns {Promise<ApplicationRenderContext>}  Context data for a specific part.\n@protected\n/\n  async _prepareSidebarContext(partId, context, options) {\n    context.isLocked = {};\n    context.isLocked.filters = (\"additional\" in this.options.filters.locked);\n    context.isLocked.types = (\"types\" in this.options.filters.locked) || context.isLocked.filters;\n    context.isLocked.documentClass = (\"documentClass\" in this.options.filters.locked) || context.isLocked.types;\n    const types = foundry.utils.getProperty(options, \"dnd5e.browser.types\") ?? [];\n\n    if ( partId === \"types\" ) {\n      context.showTypes = (types.length !== 1) || (types[0] === \"physical\");\n      context.types = CONFIG[context.filters.documentClass].documentClass.compendiumBrowserTypes({\n        chosen: context.filters.types\n      });\n\n      // Special case handling for 'Items' tab in basic mode.\n      if ( types[0] === \"physical\" ) context.types = context.types.physical.children;\n\n      if ( context.isLocked.types ) {\n        for ( const [key, value] of Object.entries(context.types) ) {\n          if ( !value.children && !value.chosen ) delete context.types[key];\n          else if ( value.children ) {\n            for ( const [k, v] of Object.entries(value.children) ) {\n              if ( !v.chosen ) delete value.children[k];\n            }\n            if ( foundry.utils.isEmpty(value.children) ) delete context.types[key];\n          }\n        }\n      }\n    }\n\n    else if ( partId === \"filters\" ) {\n      context.additional = Array.from(context.filterDefinitions?.entries() ?? []).reduce((arr, [key, data]) => {\n        // Special case handling for 'Feats' tab in basic mode.\n        if ( (types[0] === \"feat\") && ((key === \"category\") || (key === \"subtype\")) ) return arr;\n\n        let sort = 0;\n        switch ( data.type ) {\n          case \"boolean\": sort = 1; break;\n          case \"range\": sort = 2; break;\n          case \"set\": sort = 3; break;\n        }\n\n        arr.push(foundry.utils.mergeObject(data, {\n          key, sort,\n          value: context.filters.additional?.[key],\n          locked: this.options.filters.locked?.additional?.[key]\n        }, { inplace: false }));\n        return arr;\n      }, []);\n\n      context.additional.sort((a, b) => a.sort - b.sort);\n    }\n\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the results context.\n@param {ApplicationRenderContext} context     Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options      Options which configure application rendering behavior.\n@returns {Promise<ApplicationRenderContext>}  Context data for a specific part.\n@protected\n/\n  async _prepareResultsContext(context, options) {\n    // TODO: Determine if new set of results need to be fetched, otherwise use old results and re-sort as necessary\n    // Sorting changes alone shouldn't require a re-fetch, but any change to filters will\n    const filters = CompendiumBrowser.applyFilters(context.filterDefinitions, context.filters.additional);\n    // Add the name & arbitrary filters\n    if ( this.#filters.name?.length ) filters.push({ k: \"name\", o: \"icontains\", v: this.#filters.name });\n    if ( context.filters.arbitrary?.length ) filters.push(...context.filters.arbitrary);\n    this.#results = CompendiumBrowser.fetch(CONFIG[context.filters.documentClass].documentClass, {\n      filters,\n      types: context.filters.types,\n      indexFields: new Set([\"system.source\"])\n    });\n    context.displaySelection = this.displaySelection;\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare the tabs context.\n@param {ApplicationRenderContext} context  Shared context provided by _prepareContext.\n@param {HandlebarsRenderOptions} options   Options which configure application rendering behavior.\n@returns {Promise<ApplicationRenderContext>}\n@protected\n/\n  async _prepareTabsContext(context, options) {\n    // If we are locked to a particular filter, do not show tabs.\n    if ( !foundry.utils.isEmpty(this.options.filters.locked) ) {\n      context.tabs = [];\n      return context;\n    }\n\n    const advanced = this._mode === this.constructor.MODES.ADVANCED;\n    context.tabs = foundry.utils.deepClone(this.constructor.TABS.filter(t => !!t.advanced === advanced));\n    const tab = options.isFirstRender ? this.options.tab : this.tabGroups.primary;\n    const activeTab = context.tabs.find(t => t.tab === tab) ?? context.tabs[0];\n    activeTab.active = true;\n\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _renderFrame(options) {\n    const frame = await super._renderFrame(options);\n    if ( game.user.isGM ) {\n      frame.querySelector('[data-action=\"close\"]').insertAdjacentHTML(\"beforebegin\", `\n        <button type=\"button\" class=\"header-control fas fa-cog icon\" data-action=\"configureSources\"\n                data-tooltip=\"DND5E.CompendiumBrowser.Sources.Label\"\n                aria-label=\"${game.i18n.localize(\"DND5E.CompendiumBrowser.Sources.Label\")}\"></button>\n      `);\n    }\n    return frame;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRender a single result entry.\n@param {object|Document} entry  The entry.\n@param {string} documentClass   The entry's Document class.\n@returns {Promise<HTMLElement>}\n@protected\n/\n  async _renderResult(entry, documentClass) {\n    const { img, name, type, uuid, system } = entry;\n    // TODO: Provide more useful subtitles.\n    const subtitle = CONFIG[documentClass].typeLabels[type] ?? \"\";\n    const source = system?.source?.value ?? \"\";\n    const context = {\n      entry: { img, name, subtitle, uuid, source },\n      displaySelection: this.displaySelection,\n      selected: this.#selected.has(uuid)\n    };\n    const html = await renderTemplate(\"systems/dnd5e/templates/compendium/browser-entry.hbs\", context);\n    const template = document.createElement(\"template\");\n    template.innerHTML = html;\n    const element = template.content.firstElementChild;\n    if ( documentClass !== \"Item\" ) return element;\n    element.dataset.tooltip = `\n      <section class=\"loading\" data-uuid=\"${uuid}\">\n        <i class=\"fa-solid fa-spinner fa-spin-pulse\" inert></i>\n      </section>\n    `;\n    element.dataset.tooltipClass = \"dnd5e2 dnd5e-tooltip item-tooltip\";\n    element.dataset.tooltipDirection ??= \"RIGHT\";\n    return element;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRender results once loaded to avoid holding up initial app display.\n@protected\n/\n  async _renderResults() {\n    let rendered = [];\n    const { documentClass } = this.currentFilters;\n    const results = await this.#results;\n    this.#results = results;\n    const batchEnd = Math.min(this.constructor.BATCHING.SIZE, results.length);\n    for ( let i = 0; i < batchEnd; i++ ) {\n      rendered.push(this._renderResult(results[i], documentClass));\n    }\n    this.element.querySelector(\".results-loading\").hidden = true;\n    this.element.querySelector('[data-application-part=\"results\"] .item-list')\n      .replaceChildren(...(await Promise.all(rendered)));\n    this.#resultIndex = batchEnd;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShow a list of applicable source filters for the available results.\n@protected\n/\n  async _renderSourceFilters() {\n    const sources = [];\n    for ( const result of this.#results ) {\n      const source = foundry.utils.getProperty(result, \"system.source\");\n      if ( foundry.utils.getType(source) !== \"Object\" ) continue;\n      const { slug, value } = source;\n      sources.push({ slug, value: CONFIG.DND5E.sourceBooks[value] ?? value });\n    }\n    sources.sort((a, b) => a.value.localeCompare(b.value, game.i18n.lang));\n    this.#sources = Object.fromEntries(sources.map(({ slug, value }) => [slug, value]));\n    const filters = this.element.querySelector('[data-application-part=\"filters\"]');\n    filters.querySelector('[data-filter-id=\"source\"]')?.remove();\n    if ( !sources.length ) return;\n    const locked = Object.entries(this.options.filters?.locked?.additional?.source ?? {}).reduce((obj, [k, v]) => {\n      obj[k.slugify({ strict: true })] = v;\n      return obj;\n    }, {});\n    const filter = await renderTemplate(\"systems/dnd5e/templates/compendium/browser-sidebar-filter-set.hbs\", {\n      locked,\n      value: locked,\n      key: \"source\",\n      label: \"DND5E.SOURCE.FIELDS.source.label\",\n      config: { choices: this.#sources }\n    });\n    filters.insertAdjacentHTML(\"beforeend\", filter);\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners and Handlers                */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  changeTab(tab, group, options={}) {\n    super.changeTab(tab, group, options);\n    const target = this.element.querySelector(`nav.tabs [data-group=\"${group}\"][data-tab=\"${tab}\"]`);\n    let { types } = target.dataset;\n    types = types ? types.split(\",\") : [];\n    this._applyTabFilters(tab);\n    this.render({ parts: [\"results\", \"filters\", \"types\"], dnd5e: { browser: { types } }, changedTab: true });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _attachFrameListeners() {\n    super._attachFrameListeners();\n    this.element.addEventListener(\"scroll\", this._onScrollResults.bind(this), { capture: true, passive: true });\n    this.element.addEventListener(\"dragstart\", this._onDragStart.bind(this));\n    this.element.addEventListener(\"keydown\", this._debouncedSearch, { passive: true });\n    this.element.addEventListener(\"keydown\", this._onKeyAction.bind(this), { passive: true });\n    this.element.addEventListener(\"pointerdown\", event => {\n      if ( (event.button === 1) && document.getElementById(\"tooltip\")?.classList.contains(\"active\") ) {\n        event.preventDefault();\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _attachPartListeners(partId, htmlElement, options) {\n    super._attachPartListeners(partId, htmlElement, options);\n    if ( partId === \"results\" ) this._renderResults().then(() => {\n      if ( options.isFirstRender || options.changedTab ) this._renderSourceFilters();\n    });\n    else if ( partId === \"types\" ) this.#adjustCheckboxStates(htmlElement);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nApply filters based on the compendium browser's mode.\n@param {CompendiumBrowser.MODES} mode  The mode.\n@protected\n/\n  _applyModeFilters(mode) {\n    const isAdvanced = mode === this.constructor.MODES.ADVANCED;\n    delete this.#filters.types;\n    delete this.#filters.additional;\n    if ( isAdvanced ) this.#filters.documentClass = \"Actor\";\n    else {\n      this.#filters.documentClass = \"Item\";\n      this.#filters.types = new Set([\"class\"]);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nApply filters based on the selected tab.\n@param {string} id  The tab ID.\n@protected\n/\n  _applyTabFilters(id) {\n    const tab = this.constructor.TABS.find(t => t.tab === id);\n    if ( !tab ) return;\n    const { documentClass, types } = tab;\n    delete this.#filters.additional;\n    this.#filters.documentClass = documentClass;\n    this.#filters.types = new Set(types);\n\n    // Special case handling for 'Items' tab in basic mode.\n    if ( id === \"physical\" ) {\n      const physical = Item.implementation.compendiumBrowserTypes().physical.children;\n      Object.keys(physical).forEach(this.#filters.types.add, this.#filters.types);\n    }\n\n    // Special case handling for 'Feats' tab in basic mode.\n    if ( id === \"feats\" ) this.#filters.additional = { category: { feat: 1 } };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAdjust the states of group checkboxes to make then indeterminate if only some of their children are selected.\n@param {HTMLElement} htmlElement  Element within which to find groups.\n/\n  #adjustCheckboxStates(htmlElement) {\n    for ( const groupArea of htmlElement.querySelectorAll(\".type-group\") ) {\n      const group = groupArea.querySelector(\".type-group-header dnd5e-checkbox\");\n      const children = groupArea.querySelectorAll(\".wrapper dnd5e-checkbox\");\n      if ( Array.from(children).every(e => e.checked) ) {\n        group.checked = true;\n        group.indeterminate = false;\n      } else {\n        group.checked = group.indeterminate = Array.from(children).some(e => e.checked);\n      }\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  _onChangeForm(formConfig, event) {\n    if ( event.target.name === \"selected\" ) {\n      if ( event.target.checked ) this.#selected.add(event.target.value);\n      else this.#selected.delete(event.target.value);\n      event.target.closest(\".item\").classList.toggle(\"selected\", event.target.checked);\n      this.render({ parts: [\"footer\"] });\n    }\n    if ( event.target.name?.startsWith(\"additional.\") ) CompendiumBrowser.#onSetFilter.call(this, event, event.target);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle dragging an entry.\n@param {DragEvent} event  The drag event.\n@protected\n/\n  _onDragStart(event) {\n    const { uuid } = event.target.closest(\"[data-uuid]\")?.dataset ?? {};\n    try {\n      const { type } = foundry.utils.parseUuid(uuid);\n      event.dataTransfer.setData(\"text/plain\", JSON.stringify({ type, uuid }));\n    } catch(e) {\n      console.error(e);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle triggering an action via keyboard.\n@param {KeyboardEvent} event  The originating event.\n@protected\n/\n  _onKeyAction(event) {\n    const target = event.target.closest(\"[data-action]\");\n    if ( (event.key !== \" \") || !target ) return;\n    const { action } = target.dataset;\n    const handler = this.options.actions[action];\n    if ( handler ) handler.call(this, event, target);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle rendering a new batch of results when the user scrolls to the bottom of the list.\n@param {Event} event  The originating scroll event.\n@protected\n/\n  async _onScrollResults(event) {\n    if ( this.#renderThrottle || !event.target.matches('[data-application-part=\"results\"]') ) return;\n    if ( (this.#results instanceof Promise) || (this.#resultIndex >= this.#results.length) ) return;\n    const { scrollTop, scrollHeight, clientHeight } = event.target;\n    if ( scrollTop + clientHeight < scrollHeight - this.constructor.BATCHING.MARGIN ) return;\n    this.#renderThrottle = true;\n    const { documentClass } = this.currentFilters;\n    const rendered = [];\n    const batchStart = this.#resultIndex;\n    const batchEnd = Math.min(batchStart + this.constructor.BATCHING.SIZE, this.#results.length);\n    for ( let i = batchStart; i < batchEnd; i++ ) {\n      rendered.push(this._renderResult(this.#results[i], documentClass));\n    }\n    this.element.querySelector('[data-application-part=\"results\"] .item-list').append(...(await Promise.all(rendered)));\n    this.#resultIndex = batchEnd;\n    this.#renderThrottle = false;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle searching for a Document by name.\n@param {KeyboardEvent} event  The triggering event.\n@protected\n/\n  _onSearchName(event) {\n    if ( !event.target.matches(\"search > input\") ) return;\n    this.#filters.name = event.target.value;\n    this.render({ parts: [\"results\"] });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle configuring compendium browser sources.\n@this {CompendiumBrowser}\n/\n  static #onConfigureSources() {\n    new CompendiumBrowserSettingsConfig().render({ force: true });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle clearing the name filter.\n@this {CompendiumBrowser}\n@param {PointerEvent} event  The originating click event.\n@param {HTMLElement} target  The target of the click event.\n/\n  static async #onClearName(event, target) {\n    const input = target.closest(\"search\").querySelector(\":scope > input\");\n    input.value = this.#filters.name = \"\";\n    this.render({ parts: [\"results\"] });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle form submission with selection.\n@this {CompendiumBrowser}\n@param {SubmitEvent} event          The form submission event.\n@param {HTMLFormElement} form       The submitted form element.\n@param {FormDataExtended} formData  The data from the submitted form.\n/\n  static async #onHandleSubmit(event, form, formData) {\n    if ( !this.displaySelection ) return;\n\n    const value = this.#selected.size;\n    const { max, min } = this.options.selection;\n    if ( (value < (min || -Infinity)) || (value > (max || Infinity)) ) {\n      const suffix = this.#selectionLocalizationSuffix;\n      const pr = new Intl.PluralRules(game.i18n.lang);\n      throw new Error(game.i18n.format(`DND5E.CompendiumBrowser.Selection.Warning.${suffix}`, {\n        max, min, value,\n        document: game.i18n.localize(`DND5E.CompendiumBrowser.Selection.Warning.Document.${pr.select(max || min)}`)\n      }));\n    }\n\n    /**\nHook event that calls when a compendium browser is submitted with selected items.\n@function dnd5e.compendiumBrowserSelection\n@memberof hookEvents\n@param {CompendiumBrowser} browser  Compendium Browser application being submitted.\n@param {Set<string>} selected       Set of document UUIDs that are selected.\n/\n    Hooks.callAll(\"dnd5e.compendiumBrowserSelection\", this, this.#selected);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle opening a link to an item.\n@this {CompendiumBrowser}\n@param {PointerEvent} event  The originating click event.\n@param {HTMLElement} target  The capturing HTML element which defined a [data-action].\n/\n  static async #onOpenLink(event, target) {\n    (await fromUuid(target.closest(\"[data-uuid]\")?.dataset.uuid))?.sheet?.render(true);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle setting the document class or a filter.\n@this {CompendiumBrowser}\n@param {PointerEvent} event  The originating click event.\n@param {HTMLElement} target  The capturing HTML element which defined a [data-action].\n/\n  static async #onSetFilter(event, target) {\n    const name = target.name;\n    const value = target.value;\n    const existingValue = foundry.utils.getProperty(this.#filters, name);\n    if ( value === existingValue ) return;\n    foundry.utils.setProperty(this.#filters, name, value === \"\" ? undefined : value);\n\n    if ( target.tagName === \"BUTTON\" ) for ( const button of this.element.querySelectorAll(`[name=\"${name}\"]`) ) {\n      button.ariaPressed = button.value === value;\n    }\n\n    this.render({ parts: [\"results\"] });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle setting a type restriction.\n@this {CompendiumBrowser}\n@param {PointerEvent} event  The originating click event.\n@param {HTMLElement} target  The capturing HTML element which defined a [data-action].\n/\n  static async #onSetType(event, target) {\n    this.#filters.types ??= new Set();\n\n    if ( target.defaultValue ) {\n      if ( target.checked ) this.#filters.types.add(target.defaultValue);\n      else this.#filters.types.delete(target.defaultValue);\n      this.#adjustCheckboxStates(target.closest(\".sidebar\"));\n    }\n\n    else {\n      target.indeterminate = false;\n      for ( const child of target.closest(\".type-group\").querySelectorAll(\"dnd5e-checkbox[value]\") ) {\n        child.checked = target.checked;\n        if ( target.checked ) this.#filters.types.add(child.defaultValue);\n        else this.#filters.types.delete(child.defaultValue);\n      }\n    }\n\n    this.render({ parts: [\"filters\", \"results\"] });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle toggling the collapsed state of a collapsible section.\n@this {CompendiumBrowser}\n@param {PointerEvent} event  The originating click event.\n@param {HTMLElement} target  The capturing HTML element which defined a [data-action].\n/\n  static async #onToggleCollapse(event, target) {\n    target.closest(\".collapsible\")?.classList.toggle(\"collapsed\");\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle toggling the compendium browser mode.\n@this {CompendiumBrowser}\n@param {PointerEvent} event  The originating click event.\n@param {HTMLElement} target  The element that was clicked.\n/\n  static #onToggleMode(event, target) {\n    // TODO: Consider persisting this choice in a client setting.\n    this._mode = target.checked ? this.constructor.MODES.ADVANCED : this.constructor.MODES.BASIC;\n    const tabs = foundry.utils.deepClone(this.constructor.TABS.filter(t => !!t.advanced === target.checked));\n    const activeTab = tabs.find(t => t.tab === this.tabGroups.primary) ?? tabs[0];\n    const types = target.checked ? [] : (activeTab?.types ?? [\"class\"]);\n    this._applyModeFilters(this._mode);\n    this._applyTabFilters(activeTab?.tab);\n    this.render({ parts: [\"results\", \"filters\", \"types\", \"tabs\"], dnd5e: { browser: { types } }, changedTab: true });\n  }\n\n  /* -------------------------------------------- */\n  /*  Database Access                             */\n  /* -------------------------------------------- */\n\n  /**\nRetrieve a listing of documents from all compendiums for a specific Document type, with additional filters\noptionally applied.\n@param {typeof Document} documentClass  Document type to fetch (e.g. Actor or Item).\n@param {object} [options={}]\n@param {Set<string>} [options.types]    Individual document subtypes to filter upon (e.g. \"loot\", \"class\", \"npc\").\n@param {FilterDescription[]} [options.filters]  Filters to provide further filters.\n@param {boolean} [options.index=true]   Should only the index for each document be returned, or the whole thing?\n@param {Set<string>} [options.indexFields]  Key paths for fields to index.\n@param {boolean|string|Function} [options.sort=true]  Should the contents be sorted? By default sorting will be\n                                        performed using document names, but a key path can be provided to sort on\n                                        a specific property or a function to provide more advanced sorting.\n@returns {object[]|Document[]}\n/\n  static async fetch(documentClass, { types=new Set(), filters=[], index=true, indexFields=new Set(), sort=true }={}) {\n    // Nothing within containers should be shown\n    filters.push({ k: \"system.container\", o: \"in\", v: [null, undefined] });\n\n    // If filters are provided, merge their keys with any other fields needing to be indexed\n    if ( filters.length ) indexFields = indexFields.union(Filter.uniqueKeys(filters));\n\n    // Do not attempt to index derived fields as this will throw an error server-side.\n    indexFields.delete(\"system.source.slug\");\n\n    // Collate compendium sources.\n    const sources = CompendiumBrowserSettingsConfig.collateSources();\n\n    // Iterate over all packs\n    let documents = game.packs\n\n      // Skip packs that have the wrong document class\n      .filter(p => (p.metadata.type === documentClass.metadata.name)\n\n        // Do not show entries inside compendia that are not visible to the current user.\n        && p.visible\n\n        && sources.has(p.collection)\n\n        // If types are set and specified in compendium flag, only include those that include the correct types\n        && (!types.size || !p.metadata.flags.dnd5e?.types || new Set(p.metadata.flags.dnd5e.types).intersects(types)))\n\n      // Generate an index based on the needed fields\n      .map(async p => await Promise.all((await p.getIndex({ fields: Array.from(indexFields) })\n\n        // Apply module art to the new index\n        .then(index => game.dnd5e.moduleArt.apply(index)))\n\n        // Derive source values\n        .map(i => {\n          const source = foundry.utils.getProperty(i, \"system.source\");\n          if ( (foundry.utils.getType(source) === \"Object\") && i.uuid ) SourceField.prepareData.call(source, i.uuid);\n          return i;\n        })\n\n        // Remove any documents that don't match the specified types or the provided filters\n        .filter(i => (!types.size || types.has(i.type)) && (!filters.length || Filter.performCheck(i, filters)))\n\n        // If full documents are required, retrieve those, otherwise stick with the indices\n        .map(async i => index ? i : await fromUuid(i.uuid))\n      ));\n\n    // Wait for everything to finish loading and flatten the arrays\n    documents = (await Promise.all(documents)).flat();\n\n    if ( sort ) {\n      if ( sort === true ) sort = \"name\";\n      const sortFunc = foundry.utils.getType(sort) === \"function\" ? sort : (lhs, rhs) =>\n        String(foundry.utils.getProperty(lhs, sort))\n          .localeCompare(String(foundry.utils.getProperty(rhs, sort)), game.i18n.lang);\n      documents.sort(sortFunc);\n    }\n\n    return documents;\n  }\n\n  /* -------------------------------------------- */\n  /*  Factory Methods                             */\n  /* -------------------------------------------- */\n\n  /**\nFactory method used to spawn a compendium browser and wait for the results of a selection.\n@param {Partial<CompendiumBrowserConfiguration>} [options]\n@returns {Promise<Set<string>|null>}\n/\n  static async select(options={}) {\n    return new Promise((resolve, reject) => {\n      const browser = new CompendiumBrowser(options);\n      browser.addEventListener(\"close\", event => {\n        resolve(browser.selected?.size ? browser.selected : null);\n      }, { once: true });\n      browser.render({ force: true });\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nFactory method used to spawn a compendium browser and return a single selected item or null if canceled.\n@param {Partial<CompendiumBrowserConfiguration>} [options]\n@returns {Promise<string|null>}\n/\n  static async selectOne(options={}) {\n    const result = await this.select(\n      foundry.utils.mergeObject(options, { selection: { min: 1, max: 1 } }, { inplace: false })\n    );\n    return result?.size ? result.first() : null;\n  }\n\n  /* -------------------------------------------- */\n  /*  Helpers                                     */\n  /* -------------------------------------------- */\n\n  /**\nTransform filter definition and additional filters values into the final filters to apply.\n@param {CompendiumBrowserFilterDefinition} definition  Filter definition provided by type.\n@param {object} values                                 Values of currently selected filters.\n@returns {FilterDescription[]}\n/\n  static applyFilters(definition, values) {\n    const filters = [];\n    for ( const [key, value] of Object.entries(values ?? {}) ) {\n      const def = definition.get(key);\n      if ( !def ) continue;\n      if ( foundry.utils.getType(def.createFilter) === \"function\" ) {\n        def.createFilter(filters, value, def);\n        continue;\n      }\n      switch ( def.type ) {\n        case \"boolean\":\n          if ( value ) filters.push({ k: def.config.keyPath, v: value === 1 });\n          break;\n        case \"range\":\n          const min = Number(value.min);\n          const max = Number(value.max);\n          if ( Number.isFinite(min) ) filters.push({ k: def.config.keyPath, o: \"gte\", v: min });\n          if ( Number.isFinite(max) ) filters.push({ k: def.config.keyPath, o: \"lte\", v: max });\n          break;\n        case \"set\":\n          const choices = foundry.utils.deepClone(def.config.choices);\n          if ( def.config.blank ) choices._blank = \"\";\n          const [positive, negative] = Object.entries(value ?? {}).reduce(([positive, negative], [k, v]) => {\n            if ( k in choices ) {\n              if ( k === \"_blank\" ) k = \"\";\n              if ( v === 1 ) positive.push(k);\n              else if ( v === -1 ) negative.push(k);\n            }\n            return [positive, negative];\n          }, [[], []]);\n          if ( positive.length ) filters.push(\n            { k: def.config.keyPath, o: def.config.multiple ? \"hasall\" : \"in\", v: positive }\n          );\n          if ( negative.length ) filters.push(\n            { o: \"NOT\", v: { k: def.config.keyPath, o: def.config.multiple ? \"hasany\" : \"in\", v: negative } }\n          );\n          break;\n        default:\n          console.warn(`Filter type ${def.type} not handled.`);\n          break;\n      }\n    }\n    return filters;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nInject the compendium browser button into the compendium sidebar.\n@param {HTMLElement} html  HTML of the sidebar being rendered.",
      "type": "",
      "headerActions": "",
      "className": "",
      "final": "",
      "secondConfig": "",
      "finalConfig": ""
    },
    "AdoptedStyleSheetElement": {
      "static _stylesheets": "",
      "static CSS": "",
      "sheet": ""
    },
    "ChatTrayElement": {
      "static observedAttributes": "",
      "name": "",
      "popout": "",
      "height": ""
    },
    "CopyableTextElement": {
      "controller": "",
      "button": "",
      "ariaLabel": "",
      "tooltip": "",
      "innerHTML": "",
      "value": ""
    },
    "EffectsElement": {
      "app": "",
      "event": "",
      "MenuCls": "",
      "element": "",
      "menuItems": "",
      "options": "",
      "identified": "",
      "type": "",
      "hidden": "",
      "localizationPrefix": "",
      "isConcentrationEffect": "Custom element that handles displaying active effects lists.\n/\nexport default class EffectsElement extends HTMLElement {\n  connectedCallback() {\n    this.#app = ui.windows[this.closest(\".app\")?.dataset.appid];\n\n    for ( const control of this.querySelectorAll(\"[data-action]\") ) {\n      control.addEventListener(\"click\", event => {\n        this._onAction(event.currentTarget, event.currentTarget.dataset.action);\n      });\n    }\n\n    for ( const source of this.querySelectorAll(\".effect-source a\") ) {\n      source.addEventListener(\"click\", this._onClickEffectSource.bind(this));\n    }\n\n    for ( const control of this.querySelectorAll(\"[data-context-menu]\") ) {\n      control.addEventListener(\"click\", event => {\n        event.preventDefault();\n        event.stopPropagation();\n        const { clientX, clientY } = event;\n        event.currentTarget.closest(\"[data-effect-id]\").dispatchEvent(new PointerEvent(\"contextmenu\", {\n          view: window, bubbles: true, cancelable: true, clientX, clientY\n        }));\n      });\n    }\n\n    const MenuCls = this.hasAttribute(\"v2\") ? ContextMenu5e : ContextMenu;\n    new MenuCls(this, \"[data-effect-id]\", [], { onOpen: element => {\n      const effect = this.getEffect(element.dataset);\n      if ( !effect ) return;\n      ui.context.menuItems = this._getContextOptions(effect);\n      Hooks.call(\"dnd5e.getActiveEffectContextOptions\", effect, ui.context.menuItems);\n    }, jQuery: true });\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nReference to the application that contains this component.\n@type {Application}\n/\n  #app;\n\n  /**\nReference to the application that contains this component.\n@type {Application}\n@protected\n/\n  get _app() { return this.#app; }\n\n  /* -------------------------------------------- */\n\n  /**\nDocument whose effects are represented.\n@type {Actor5e|Item5e}\n/\n  get document() {\n    return this._app.document;\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /**\nPrepare the data structure for Active Effects which are currently applied to an Actor or Item.\n@param {ActiveEffect5e[]} effects         The array of Active Effect instances for which to prepare sheet data.\n@param {object} [options={}]\n@param {Actor5e|Item5e} [options.parent]  Document that owns these active effects.\n@returns {object}                  Data for rendering.\n/\n  static prepareCategories(effects, { parent }={}) {\n    // Define effect header categories\n    const categories = {\n      enchantment: {\n        type: \"enchantment\",\n        label: game.i18n.localize(\"DND5E.ENCHANTMENT.Category.General\"),\n        effects: [],\n        isEnchantment: true\n      },\n      temporary: {\n        type: \"temporary\",\n        label: game.i18n.localize(\"DND5E.EffectTemporary\"),\n        effects: []\n      },\n      enchantmentActive: {\n        type: \"activeEnchantment\",\n        label: game.i18n.localize(\"DND5E.ENCHANTMENT.Category.Active\"),\n        effects: [],\n        isEnchantment: true\n      },\n      passive: {\n        type: \"passive\",\n        label: game.i18n.localize(\"DND5E.EffectPassive\"),\n        effects: []\n      },\n      enchantmentInactive: {\n        type: \"inactiveEnchantment\",\n        label: game.i18n.localize(\"DND5E.ENCHANTMENT.Category.Inactive\"),\n        effects: [],\n        isEnchantment: true\n      },\n      inactive: {\n        type: \"inactive\",\n        label: game.i18n.localize(\"DND5E.EffectInactive\"),\n        effects: []\n      },\n      suppressed: {\n        type: \"suppressed\",\n        label: game.i18n.localize(\"DND5E.EffectUnavailable\"),\n        effects: [],\n        disabled: true,\n        info: [game.i18n.localize(\"DND5E.EffectUnavailableInfo\")]\n      }\n    };\n\n    // Iterate over active effects, classifying them into categories\n    for ( const e of effects ) {\n      if ( (e.parent.system?.identified === false) && !game.user.isGM ) continue;\n      if ( e.isAppliedEnchantment ) {\n        if ( e.disabled ) categories.enchantmentInactive.effects.push(e);\n        else categories.enchantmentActive.effects.push(e);\n      }\n      else if ( e.type === \"enchantment\" ) categories.enchantment.effects.push(e);\n      else if ( e.isSuppressed ) categories.suppressed.effects.push(e);\n      else if ( e.disabled ) categories.inactive.effects.push(e);\n      else if ( e.isTemporary ) categories.temporary.effects.push(e);\n      else categories.passive.effects.push(e);\n    }\n    categories.enchantment.hidden = !parent?.system.isEnchantment;\n    categories.enchantmentActive.hidden = !categories.enchantmentActive.effects.length;\n    categories.enchantmentInactive.hidden = !categories.enchantmentInactive.effects.length;\n    categories.suppressed.hidden = !categories.suppressed.effects.length;\n\n    for ( const category of Object.values(categories) ) {\n      category.localizationPrefix = category.isEnchantment ? \"DND5E.ENCHANTMENT.Action.\" : \"DND5E.Effect\";\n    }\n\n    return categories;\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Handlers                              */\n  /* -------------------------------------------- */\n\n  /**\nPrepare an array of context menu options which are available for owned ActiveEffect documents.\n@param {ActiveEffect5e} effect  The ActiveEffect for which the context menu is activated.\n@returns {ContextMenuEntry[]}   An array of context menu options offered for the ActiveEffect.\n@protected",
      "uuid": "",
      "isFavorited": "",
      "class": "",
      "action": "",
      "dataset": "",
      "effect": "",
      "existing": "",
      "li": "",
      "isActor": "",
      "isEnchantment": "",
      "effectType": "",
      "doc": ""
    },
    "EnchantmentApplicationElement": {
      "messageId": "",
      "chatMessage": "",
      "div": "",
      "innerHTML": "",
      "dropArea": "",
      "item": "",
      "scaling": "",
      "activity": "",
      "maxTargets": "",
      "countArea": "",
      "enchantedItems": "",
      "enchantmentUuid": "",
      "control": "",
      "ariaLabel": "",
      "action": "",
      "tooltip": "",
      "innerText": "",
      "data": "",
      "effect": "",
      "droppedItem": "",
      "errors": "",
      "err": "",
      "concentrationId": "",
      "concentration": "",
      "effectData": "",
      "origin": "",
      "applied": "",
      "enchantment": ""
    },
    "InventoryElement": {
      "app": "",
      "action": "",
      "type": "",
      "inputmode": "",
      "event": "",
      "e": "",
      "MenuCls": "",
      "filterLists": "",
      "state": "",
      "set": "",
      "filters": "",
      "f": "",
      "items": "",
      "elementMap": "",
      "el": "",
      "hidden": "",
      "compendiumLocked": "",
      "options": "",
      "li": "",
      "class": "",
      "mode": "",
      "uuid": "",
      "isFavorited": "",
      "expanded": "",
      "itemId": "",
      "item": "",
      "min": "",
      "max": "",
      "value": "",
      "input": "",
      "activity": "",
      "result": "",
      "name": "",
      "button": "",
      "inventoryEvent": "",
      "itemData": "",
      "summary": "",
      "chatData": "",
      "menuItems": ""
    },
    "ItemListControlsElement": {
      "app": "",
      "list": "",
      "state": "",
      "tab": "",
      "debouncedFilter": "",
      "static SORT_MODES": "",
      "static FILTER_DEBOUNCE_MS": "",
      "sortMode": "",
      "options": "",
      "search": "",
      "innerHTML": "",
      "controls": "",
      "item": "",
      "option": "",
      "groupLabel": "",
      "_inputElement": "",
      "_filterItems": "",
      "_controls": "",
      "el": "",
      "value": "",
      "className": "",
      "tooltip": "",
      "entries": "",
      "elementMap": "",
      "hidden": "",
      "group": "",
      "sections": "",
      "section": "",
      "items": "",
      "element": "",
      "itemPreparationMode": "",
      "target": "",
      "filter": "",
      "flag": "",
      "current": "",
      "action": "",
      "index": "",
      "name": ""
    },
    "SlideToggleElement": {
      "role": "A custom HTML element that represents a checkbox-like input that is displayed as a slide toggle.\n@fires change\n/\nexport default class SlideToggleElement extends CheckboxElement {\n  /** @inheritDoc",
      "static tagName": "",
      "static useShadowRoot": "",
      "track": "",
      "thumb": ""
    },
    "TargetedApplicationElement": {
      "selectedTokensHook": "",
      "pressed": "",
      "mode": "",
      "toPress": "",
      "currentlyPressed": "",
      "ariaPressed": "",
      "targetSourceControl": "",
      "innerHTML": "",
      "b": "",
      "hidden": "",
      "targetList": "",
      "targetedTokens": "",
      "t": "",
      "targets": "",
      "li": "",
      "innerText": "",
      "targetingMode": ""
    },
    "CurrencyManager": {
      "_options": "",
      "document": "",
      "options": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "tabGroups": "",
      "destinations": "",
      "actor": "",
      "b": "",
      "primaryParty": "",
      "context": "Application for performing currency conversions & transfers.\n/\nexport default class CurrencyManager extends Application5e {\n  constructor(options, _options={}) {\n    if ( options instanceof foundry.abstract.Document ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `CurrencyManager` document should now be passed within the options object as `document`.\",\n        { since: \"DnD5e 4.3\", until: \"DnD5e 4.5\" }\n      );\n      _options.document = options;\n      options = _options;\n    }\n    super(options);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    actions: {\n      setAll: CurrencyManager.#setTransferValue,\n      setHalf: CurrencyManager.#setTransferValue\n    },\n    classes: [\"currency-manager\", \"standard-form\"],\n    document: null,\n    form: {\n      closeOnSubmit: true,\n      handler: CurrencyManager.#handleFormSubmission\n    },\n    position: {\n      width: 350\n    },\n    tag: \"form\",\n    window: {\n      title: \"DND5E.CurrencyManager.Title\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    tabs: {\n      template: \"templates/generic/tab-navigation.hbs\"\n    },\n    convert: {\n      template: \"systems/dnd5e/templates/apps/currency-manager-convert.hbs\"\n    },\n    transfer: {\n      template: \"systems/dnd5e/templates/apps/currency-manager-transfer.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  tabGroups = {\n    primary: \"transfer\"\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nDocument for which the currency is being managed.\n@type {Actor5e|Item5e}\n/\n  get document() {\n    return this.options.document;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDestinations to which currency can be transferred.\n@type {(Actor5e|Item5e)[]}\n/\n  get transferDestinations() {\n    const destinations = [];\n    const actor = this.document instanceof Actor ? this.document : this.document.parent;\n    if ( actor && (actor !== this.document) ) destinations.push(actor);\n    destinations.push(...(actor?.system.transferDestinations ?? []));\n    destinations.push(...(actor?.itemTypes.container.filter(b => b !== this.document) ?? []));\n    if ( game.user.isGM ) {\n      const primaryParty = game.settings.get(\"dnd5e\", \"primaryParty\")?.actor;\n      if ( primaryParty && (this.document !== primaryParty) && !destinations.includes(primaryParty) ) {\n        destinations.push(primaryParty);\n      }\n    }\n    return destinations;\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "currency": "",
      "tabs": "",
      "tab": "",
      "primary": "",
      "action": "",
      "input": "",
      "value": "",
      "formData": "",
      "data": "",
      "valid": "",
      "name": "",
      "currencies": "",
      "basis": "",
      "amount": "",
      "recursive": "",
      "updates": "",
      "priority": "",
      "baseConversion": "",
      "multiplier": "",
      "deduct": ""
    },
    "AttackRollConfigurationDialog": {
      "static DEFAULT_OPTIONS": "",
      "context": "",
      "optionsFields": "",
      "fields": ""
    },
    "D20RollConfigurationDialog": {
      "defaultButton": "",
      "advantage": "",
      "disadvantage": "",
      "advantageMode": "",
      "buttons": "",
      "action": "",
      "roll": ""
    },
    "DamageRollConfigurationDialog": {
      "static PARTS": "",
      "allowCritical": "",
      "defaultCritical": "",
      "buttons": "",
      "context": "",
      "allTypes": "",
      "rolls": "",
      "_": "",
      "config": "Dialog for configuring damage rolls.\n@param {DamageRollProcessConfiguration} [config={}]        Initial roll configuration.\n@param {BasicRollMessageConfiguration} [message={}]        Message configuration.\n@param {BasicRollConfigurationDialogOptions} [options={}]  Dialog rendering options.\n/\nexport default class DamageRollConfigurationDialog extends RollConfigurationDialog {\n\n  /** @inheritDoc */\n  static PARTS = {\n    ...super.PARTS,\n    formulas: {\n      template: \"systems/dnd5e/templates/dice/damage-formulas.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static get rollType() {\n    return CONFIG.Dice.DamageRoll;\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @override */\n  async _prepareButtonsContext(context, options) {\n    const allowCritical = this.config.critical?.allow !== false;\n    const defaultCritical = allowCritical && (this.options.defaultButton === \"critical\");\n    context.buttons = {\n      critical: {\n        default: defaultCritical,\n        icon: '<i class=\"fa-solid fa-bomb\" inert></i>',\n        label: game.i18n.localize(\"DND5E.CriticalHit\")\n      },\n      normal: {\n        default: !defaultCritical,\n        icon: '<i class=\"fa-solid fa-dice\" inert></i>',\n        label: game.i18n.localize(allowCritical ? \"DND5E.Normal\" : \"DND5E.Roll\")\n      }\n    };\n    if ( !allowCritical ) delete context.buttons.critical;\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _prepareFormulasContext(context, options) {\n    context = await super._prepareFormulasContext(context, options);\n    const allTypes = foundry.utils.mergeObject(CONFIG.DND5E.damageTypes, CONFIG.DND5E.healingTypes, { inplace: false });\n    context.rolls = context.rolls.map(({ roll }) => ({\n      roll,\n      damageConfig: allTypes[roll.options.type] ?? allTypes[roll.options.types?.[0]],\n      damageTypes: roll.options.types?.length > 1 ? Object.entries(allTypes).map(([key, config]) => {\n        if ( !roll.options.types?.includes(key) ) return null;\n        return { value: key, label: config.label };\n      }).filter(_ => _) : null\n    }));\n    return context;\n  }\n\n  /* -------------------------------------------- */\n  /*  Roll Handling                               */\n  /* --------------------------------------------",
      "damageType": "",
      "type": "",
      "roll": ""
    },
    "RollConfigurationDialog": {
      "config": "",
      "message": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "dice": "",
      "shouldDisplay": "",
      "identifyTerm": "",
      "i": "",
      "identifyDice": "",
      "roll": "",
      "byDenom": "",
      "context": "",
      "buttons": "",
      "fields": "",
      "rolls": "",
      "RollType": "",
      "situational": "",
      "v": "",
      "rollMode": "",
      "formData": "",
      "options": ""
    },
    "SkillToolRollConfigurationDialog": {
      "static DEFAULT_OPTIONS": "",
      "context": "",
      "name": "",
      "ability": "",
      "abilityLabel": "",
      "flavor": ""
    },
    "ContainerSheet": {
      "_expanded": "",
      "options": "",
      "items": "",
      "capacity": "",
      "itemContext": "",
      "ctx": "",
      "totalWeight": "",
      "isExpanded": "",
      "isStack": "",
      "expanded": "",
      "isContainer": "",
      "inventory": "",
      "li": "",
      "item": "",
      "dragData": "",
      "data": "",
      "type": "",
      "folder": "",
      "recursiveWarning": "",
      "parentContainers": "",
      "containers": "",
      "container": "",
      "uuid": "",
      "toCreate": "",
      "d": "",
      "behavior": "",
      "created": "",
      "dropTarget": "",
      "contents": "",
      "target": "",
      "id": "",
      "siblings": "",
      "siblingId": "",
      "sortUpdates": "",
      "updateData": "",
      "_id": ""
    },
    "CreateScrollDialog": {
      "options": "",
      "config": "",
      "spell": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "anchor": "",
      "fields": "",
      "values": "",
      "valuePlaceholders": "",
      "level": "",
      "formData": "",
      "event": ""
    },
    "EnchantmentConfig": {},
    "StartingEquipmentConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "processEntry": "",
      "children": "",
      "type": "",
      "showRequireProficiency": "",
      "entries": "",
      "options": "",
      "submitData": "",
      "startingEquipment": "",
      "highestSort": "",
      "deleteIds": "",
      "getDeleteIds": "",
      "c": "",
      "i": "",
      "entry": "Configuration application for Starting Equipment.\n/\nexport default class StartingEquipmentConfig extends DocumentSheet5e {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"starting-equipment\"],\n    form: {\n      submitOnChange: true\n    },\n    position: {\n      width: 480\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    config: {\n      template: \"systems/dnd5e/templates/apps/starting-equipment-config.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /** @override */\n  get title() {\n    return game.i18n.localize(\"DND5E.StartingEquipment.Action.Configure\");\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _prepareContext(options) {\n    const context = await super._prepareContext(options);\n\n    const processEntry = async (entry, depth=1) => {\n      const data = {\n        id: entry._id, entry, depth,\n        groupType: entry.type in EquipmentEntryData.GROUPING_TYPES,\n        validTypes: depth < 3 ? EquipmentEntryData.TYPES : EquipmentEntryData.OPTION_TYPES\n      };\n      if ( entry.type in EquipmentEntryData.GROUPING_TYPES ) {\n        data.children = await Promise.all(entry.children.map(c => processEntry(c, depth + 1)));\n      } else if ( entry.type === \"linked\" ) {\n        data.linked = fromUuidSync(entry.key);\n        data.showRequireProficiency = [\"equipment\", \"tool\", \"weapon\"].includes(data.linked?.type);\n      }\n      return data;\n    };\n    context.entries = await Promise.all(\n      this.document.system.startingEquipment\n        .filter(e => !e.group)\n        .sort((lhs, rhs) => lhs.sort - rhs.sort)\n        .map(e => processEntry(e))\n    );\n\n    return context;\n  }\n\n  /* -------------------------------------------- */\n  /*  Life-Cycle Handlers                         */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _onRender(context, options) {\n    await super._onRender(context, options);\n    new DragDrop({\n      dragSelector: \".drag-bar\",\n      dropSelector: null,\n      callbacks: {\n        dragstart: this._onDragStart.bind(this),\n        drop: this._onDrop.bind(this)\n      }\n    }).bind(this.element);\n  }\n\n  /* -------------------------------------------- */\n  /*  Event Listeners                             */\n  /* -------------------------------------------- */\n\n  /**\nHandle an action.\n@param {HTMLElement} element       The element on which the action is being performed.\n@param {object} [options={}]\n@param {string} [options.action]   The specific action to perform.\n@param {number} [options.depth]    Depth of the element being acted upon.\n@param {string} [options.entryId]  ID of the entry to act upon.\n/\n  _onAction(element, { action, depth, entryId }={}) {\n    this.submit({ updateData: {\n      action: action ?? element.closest(\"[data-action]\")?.dataset.action,\n      depth: depth ?? (Number(event.target.closest(\"[data-depth]\")?.dataset.depth ?? 0) + 1),\n      entryId: entryId ?? element.closest(\"[data-entry-id]\")?.dataset.entryId\n    } });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  _onClickAction(event, target) {\n    this._onAction(target);\n  }\n\n  /* -------------------------------------------- */\n  /*  Form Handling                               */\n  /* -------------------------------------------- */\n\n  /** @override */\n  _prepareSubmitData(event, form, formData, updateData) {\n    const submitData = this._processFormData(event, form, formData);\n    if ( updateData ) foundry.utils.mergeObject(submitData, updateData, { inplace: true, performDeletions: true });\n    // Skip the validation step here because it causes a bunch of problems with providing array\n    // updates when using the `submit` method\n    return submitData;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _processSubmitData(event, form, submitData) {\n    let { action, depth, entryId, linkedUuid, startingEquipment } = submitData;\n    startingEquipment = Object.values(startingEquipment ?? {});\n\n    const highestSort = startingEquipment.reduce((sort, i) => i.sort > sort ? i.sort : sort, 0);\n    switch ( action ) {\n      case \"add-entry\":\n        startingEquipment.push({\n          _id: foundry.utils.randomID(),\n          group: entryId,\n          sort: highestSort + CONST.SORT_INTEGER_DENSITY,\n          type: (depth < 3) && !linkedUuid ? \"OR\" : \"linked\",\n          key: linkedUuid\n        });\n        break;\n      case \"delete-entry\":\n        const deleteIds = new Set();\n        const getDeleteIds = entry => {\n          deleteIds.add(entry._id);\n          entry.children?.forEach(c => getDeleteIds(c));\n        };\n        getDeleteIds(this.document.system.startingEquipment.find(i => i._id === entryId));\n        startingEquipment = startingEquipment.filter(e => !deleteIds.has(e._id));\n        break;\n    }\n\n    await super._processSubmitData(event, form, { \"system.startingEquipment\": startingEquipment });\n  }\n\n  /* -------------------------------------------- */\n  /*  Drag & Drop                                 */\n  /* --------------------------------------------",
      "box": "",
      "data": "",
      "uuid": "",
      "item": "",
      "closestDrop": "",
      "entryType": "",
      "dropArea": "",
      "dragEntry": "",
      "dropEntry": "",
      "_id": "",
      "depth": "",
      "updateData": "",
      "target": "",
      "group": "",
      "sortBefore": "",
      "sortedEntries": "",
      "siblings": "",
      "sortUpdates": ""
    },
    "SummoningConfig": {},
    "JournalEditor": {
      "_options": "",
      "options": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "@typedef JournalEditorConfiguration\n@property {string} textKeyPath  The path to the specific HTML field being edited.\n/\n\n/**\nPop out ProseMirror editor window for journal entries with multiple text areas that need editing.\n@extends {DocumentSheet5e<ApplicationConfiguration & JournalEditorConfiguration>}\n/\nexport default class JournalEditor extends DocumentSheet5e {\n  constructor(options, _options={}) {\n    if ( options instanceof JournalEntryPage ) {\n      foundry.utils.logCompatibilityWarning(\n        \"The `JournalEditor` now takes the document within its application options during construction.\",\n        { since: \"DnD5e 4.3\", until: \"DnD5e 5.0\" }\n      );\n      options = { ..._options, document: options };\n    }\n    super(options);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"journal-editor\"],\n    window: {\n      resizable: true\n    },\n    form: {\n      submitOnChange: true\n    },\n    position: {\n      width: 550,\n      height: 640\n    },\n    sheetConfig: false,\n    textKeyPath: null\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    editor: {\n      template: \"systems/dnd5e/templates/journal/journal-editor.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get title() {\n    return this.options.window.title ?? this.document.name;\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "rawText": ""
    },
    "SpellsUnlinkedConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "submitData": "Application for configuring a single unlinked spell in a spell list.\n/\nexport default class SpellsUnlinkedConfig extends DocumentSheet5e {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"unlinked-spell-config\"],\n    form: {\n      submitOnChange: true\n    },\n    position: {\n      width: 400\n    },\n    sheetConfig: false,\n    unlinkedId: null\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    spell: {\n      template: \"systems/dnd5e/templates/journal/page-spell-list-unlinked-spell.hbs\"\n    },\n    source: {\n      template: \"systems/dnd5e/templates/journal/page-spell-list-unlinked-source.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get title() {\n    return game.i18n.localize(\"JOURNALENTRYPAGE.DND5E.SpellList.UnlinkedSpells.Configuration\");\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async _prepareContext(options) {\n    const context = {\n      ...await super._prepareContext(options),\n      ...this.document.system.unlinkedSpells.find(u => u._id === this.options.unlinkedId),\n      fields: this.document.system.schema.fields.unlinkedSpells.element.fields,\n      spellLevelOptions: Object.entries(CONFIG.DND5E.spellLevels).map(([value, label]) => ({ value, label })),\n      spellSchoolOptions: Object.entries(CONFIG.DND5E.spellSchools).map(([value, { label }]) => ({ value, label }))\n    };\n    return context;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "unlinkedSpells": "",
      "editing": ""
    },
    "DragDropApplication": {
      "data": "",
      "dropEffect": "",
      "allowed": "",
      "behavior": "",
      "type": ""
    },
    "PropertyAttribution": {
      "options": "",
      "object": "",
      "attributions": "",
      "property": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "total": "",
      "sources": "",
      "entry": "",
      "mode": "",
      "value": "",
      "parts": ""
    },
    "BaseSettingsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "fields": "",
      "buttons": "",
      "setting": "",
      "Field": "",
      "data": "",
      "type": "",
      "options": ""
    },
    "BastionSettingsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "fields": "",
      "source": ""
    },
    "CombatSettingsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "fields": "",
      "legend": ""
    },
    "CompendiumBrowserSettingsConfig": {
      "selected": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "static FILTER_DELAY": "",
      "filter": "",
      "_debouncedFilter": "",
      "sources": "",
      "byPackage": "",
      "packageType": "",
      "entry": "",
      "packages": "",
      "world": "",
      "system": "",
      "modules": "",
      "id": "",
      "module": "",
      "packs": "",
      "all": "",
      "indeterminate": "",
      "documentName": "",
      "partId": "",
      "query": "",
      "item": "",
      "name": "",
      "pkg": "",
      "setting": "",
      "input": "",
      "value": ""
    },
    "ModuleArtSettingsConfig": {
      "object": "",
      "options": "",
      "config": "",
      "settings": "",
      "action": "",
      "item": "",
      "id": "",
      "configs": "",
      "key": "",
      "idx": "",
      "sortBefore": "",
      "target": "",
      "updates": "",
      "value": ""
    },
    "VariantRulesSettingsConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "An application for configuring variant rules settings.\n/\nexport default class VariantRulesSettingsConfig extends BaseSettingsConfig {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    window: {\n      title: \"SETTINGS.DND5E.VARIANT.Label\"\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    general: {\n      template: \"systems/dnd5e/templates/settings/base-config.hbs\"\n    },\n    encumbrance: {\n      template: \"systems/dnd5e/templates/settings/base-config.hbs\"\n    },\n    abilities: {\n      template: \"systems/dnd5e/templates/settings/base-config.hbs\"\n    },\n    footer: {\n      template: \"templates/generic/form-footer.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "fields": "",
      "legend": ""
    },
    "VisibilitySettingsConfig": {
      "static DEFAULT_OPTIONS": "",
      "context": "An application for configuring player visibility settings.\n/\nexport default class VisibilitySettingsConfig extends BaseSettingsConfig {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    window: {\n      title: \"SETTINGS.DND5E.VISIBILITY.Label\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "fields": ""
    },
    "CreatureTypeConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "",
      "source": "",
      "data": "",
      "fields": "",
      "keyPath": "",
      "swarmOptions": "",
      "typeOptions": "",
      "custom": "",
      "rows": "",
      "preview": ""
    },
    "MovementSensesConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "keyPath": "",
      "type": "",
      "options": "",
      "uniqueId": "",
      "context": "",
      "source": "",
      "placeholderData": "",
      "data": "",
      "fields": "",
      "extras": "",
      "types": "",
      "unitsOptions": ""
    },
    "SourceConfig": {
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "context": "Application for configuring the source data on actors and items.\n/\nexport default class SourceConfig extends DocumentSheet5e {\n  /** @override */\n  static DEFAULT_OPTIONS = {\n    classes: [\"source-config\", \"standard-form\"],\n    sheetConfig: false,\n    position: {\n      width: 400\n    },\n    form: {\n      closeOnSubmit: true\n    }\n  };\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static PARTS = {\n    source: {\n      template: \"systems/dnd5e/templates/apps/source-config.hbs\"\n    },\n    footer: {\n      template: \"templates/generic/form-footer.hbs\"\n    }\n  };\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /** @override */\n  get title() {\n    return game.i18n.localize(\"DND5E.SOURCE.Action.Configure\");\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "source": "",
      "buttons": "",
      "data": "",
      "fields": "",
      "keyPath": "",
      "sourceUuid": "",
      "sourceAnchor": "",
      "rulesVersions": "",
      "identifier": ""
    },
    "TokenPlacement": {
      "config": "",
      "currentPlacement": "",
      "moveTime": "",
      "throttle": "",
      "placement": "",
      "placements": "",
      "total": "",
      "uniqueTokens": "",
      "obj": "",
      "eventMode": "",
      "actorId": "",
      "index": "",
      "previews": "",
      "tokenData": "",
      "enabled": "",
      "_id": "",
      "src": "",
      "cls": "",
      "doc": "",
      "p": "",
      "events": "",
      "oncontextmenu": "",
      "onwheel": "",
      "idx": "",
      "preview": "",
      "clone": "",
      "local": "",
      "x": "",
      "y": "",
      "dest": "",
      "delta": "",
      "snap": "",
      "regex": "",
      "match": "",
      "name": ""
    },
    "ActorDataModel": {
      "static metadata": "",
      "primaryParty": "",
      "destinations": "",
      "scale": "",
      "deterministic": "",
      "prof": ""
    },
    "ItemDataModel": {
      "static metadata": "",
      "static ITEM_TOOLTIP_TEMPLATE": "",
      "sourceId": "",
      "enrichmentOptions": "",
      "rollData": "",
      "isIdentified": "",
      "chat": "",
      "description": "",
      "uses": "",
      "price": "",
      "subtitle": "",
      "context": "",
      "properties": "",
      "hasProperties": "",
      "baseItem": "",
      "gold": "",
      "valueInGP": "",
      "base": "",
      "costs": "",
      "deterministic": "",
      "data": ""
    },
    "AttackActivityData": {
      "ability": "",
      "availableAbilities": "",
      "size": "",
      "abilities": "",
      "type": "Data model for an attack activity.\n@property {object} attack\n@property {string} attack.ability              Ability used to make the attack and determine damage.\n@property {string} attack.bonus                Arbitrary bonus added to the attack.\n@property {object} attack.critical\n@property {number} attack.critical.threshold   Minimum value on the D20 needed to roll a critical hit.\n@property {boolean} attack.flat                Should the bonus be used in place of proficiency & ability modifier?\n@property {object} attack.type\n@property {string} attack.type.value           Is this a melee or ranged attack?\n@property {string} attack.type.classification  Is this a unarmed, weapon, or spell attack?\n@property {object} damage\n@property {object} damage.critical\n@property {string} damage.critical.bonus       Extra damage applied when a critical is rolled. Added to the base\n                                               damage or first damage part.\n@property {boolean} damage.includeBase         Should damage defined by the item be included with other damage parts?\n@property {DamageData[]} damage.parts          Parts of damage to inflict.\n/\nexport default class AttackActivityData extends BaseActivityData {\n  /** @inheritDoc */\n  static defineSchema() {\n    return {\n      ...super.defineSchema(),\n      attack: new SchemaField({\n        ability: new StringField(),\n        bonus: new FormulaField(),\n        critical: new SchemaField({\n          threshold: new NumberField({ integer: true, positive: true })\n        }),\n        flat: new BooleanField(),\n        type: new SchemaField({\n          value: new StringField(),\n          classification: new StringField()\n        })\n      }),\n      damage: new SchemaField({\n        critical: new SchemaField({\n          bonus: new FormulaField()\n        }),\n        includeBase: new BooleanField({ initial: true }),\n        parts: new ArrayField(new DamageField())\n      })\n    };\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /** @override */\n  get ability() {\n    if ( this.attack.ability === \"none\" ) return null;\n    if ( this.attack.ability === \"spellcasting\" ) return this.spellcastingAbility;\n    if ( this.attack.ability in CONFIG.DND5E.abilities ) return this.attack.ability;\n\n    const availableAbilities = this.availableAbilities;\n    if ( !availableAbilities?.size ) return null;\n    if ( availableAbilities?.size === 1 ) return availableAbilities.first();\n    const abilities = this.actor?.system.abilities ?? {};\n    return availableAbilities.reduce((largest, ability) =>\n      (abilities[ability]?.mod ?? -Infinity) > (abilities[largest]?.mod ?? -Infinity) ? ability : largest\n    , availableAbilities.first());\n  }\n\n  /* --------------------------------------------",
      "value": "",
      "labels": "",
      "reach": "",
      "classification": "",
      "melee": "",
      "ranged": "",
      "threshold": "",
      "sourceType": "",
      "damageParts": "",
      "hasBase": "",
      "parts": "",
      "part": "",
      "basePart": "",
      "base": "",
      "locked": "",
      "roll": "",
      "modifier": "",
      "formula": "",
      "toHit": "",
      "key": "",
      "attackModeLabel": "",
      "actionType": "",
      "actionTypeLabel": "",
      "isLegacy": "",
      "isUnarmed": "",
      "isSpell": "",
      "weaponType": "",
      "weaponTypeLabel": "",
      "config": "",
      "weapon": "",
      "ammo": "",
      "properties": "",
      "basePartIndex": "",
      "damage": "",
      "rollData": "",
      "range": "",
      "_": "",
      "index": "Data model for an attack activity.\n@property {object} attack\n@property {string} attack.ability              Ability used to make the attack and determine damage.\n@property {string} attack.bonus                Arbitrary bonus added to the attack.\n@property {object} attack.critical\n@property {number} attack.critical.threshold   Minimum value on the D20 needed to roll a critical hit.\n@property {boolean} attack.flat                Should the bonus be used in place of proficiency & ability modifier?\n@property {object} attack.type\n@property {string} attack.type.value           Is this a melee or ranged attack?\n@property {string} attack.type.classification  Is this a unarmed, weapon, or spell attack?\n@property {object} damage\n@property {object} damage.critical\n@property {string} damage.critical.bonus       Extra damage applied when a critical is rolled. Added to the base\n                                               damage or first damage part.\n@property {boolean} damage.includeBase         Should damage defined by the item be included with other damage parts?\n@property {DamageData[]} damage.parts          Parts of damage to inflict.\n/\nexport default class AttackActivityData extends BaseActivityData {\n  /** @inheritDoc */\n  static defineSchema() {\n    return {\n      ...super.defineSchema(),\n      attack: new SchemaField({\n        ability: new StringField(),\n        bonus: new FormulaField(),\n        critical: new SchemaField({\n          threshold: new NumberField({ integer: true, positive: true })\n        }),\n        flat: new BooleanField(),\n        type: new SchemaField({\n          value: new StringField(),\n          classification: new StringField()\n        })\n      }),\n      damage: new SchemaField({\n        critical: new SchemaField({\n          bonus: new FormulaField()\n        }),\n        includeBase: new BooleanField({ initial: true }),\n        parts: new ArrayField(new DamageField())\n      })\n    };\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /** @override */\n  get ability() {\n    if ( this.attack.ability === \"none\" ) return null;\n    if ( this.attack.ability === \"spellcasting\" ) return this.spellcastingAbility;\n    if ( this.attack.ability in CONFIG.DND5E.abilities ) return this.attack.ability;\n\n    const availableAbilities = this.availableAbilities;\n    if ( !availableAbilities?.size ) return null;\n    if ( availableAbilities?.size === 1 ) return availableAbilities.first();\n    const abilities = this.actor?.system.abilities ?? {};\n    return availableAbilities.reduce((largest, ability) =>\n      (abilities[ability]?.mod ?? -Infinity) > (abilities[largest]?.mod ?? -Infinity) ? ability : largest\n    , availableAbilities.first());\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  get actionType() {\n    const type = this.attack.type;\n    return `${type.value === \"ranged\" ? \"r\" : \"m\"}${type.classification === \"spell\" ? \"sak\" : \"wak\"}`;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get activationLabels() {\n    const labels = super.activationLabels;\n    if ( labels && (this.item.type === \"weapon\") && !this.range.override ) {\n      if ( this.item.labels?.range ) labels.range = this.item.labels.range;\n      if ( this.item.labels?.reach ) labels.reach = this.item.labels.reach;\n    }\n    return labels;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAbilities that could potentially be used with this attack. Unless a specific ability is specified then\nwhichever ability has the highest modifier will be selected when making an attack.\n@type {Set<string>}\n/\n  get availableAbilities() {\n    // Defer to item if available and matching attack classification\n    if ( this.item.system.availableAbilities && (this.item.type === this.attack.type.classification) ) {\n      return this.item.system.availableAbilities;\n    }\n\n    // Spell attack not associated with a single class, use highest spellcasting ability on actor\n    if ( this.attack.type.classification === \"spell\" ) return new Set(\n      this.actor?.system.attributes?.spellcasting\n        ? [this.actor.system.attributes.spellcasting]\n        : Object.values(this.actor?.spellcastingClasses ?? {}).map(c => c.spellcasting.ability)\n    );\n\n    // Weapon & unarmed attacks uses melee or ranged ability depending on type, or both if actor is an NPC\n    const melee = CONFIG.DND5E.defaultAbilities.meleeAttack;\n    const ranged = CONFIG.DND5E.defaultAbilities.rangedAttack;\n    return new Set([this.attack.type.value === \"melee\" ? melee : ranged]);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCritical threshold for attacks with this activity.\n@type {number}\n/\n  get criticalThreshold() {\n    let ammoThreshold;\n    // TODO: Fetch threshold from ammo\n    const threshold = Math.min(\n      this.attack.critical.threshold ?? Infinity,\n      this.item.system.criticalThreshold ?? Infinity,\n      ammoThreshold ?? Infinity\n    );\n    return threshold < Infinity ? threshold : 20;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPotential attack types when attacking with this activity.\n@type {Set<string>}\n/\n  get validAttackTypes() {\n    const sourceType = this._source.attack.type.value;\n    if ( sourceType ) return new Set([sourceType]);\n    return this.item.system.validAttackTypes ?? new Set();\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Migrations                             */\n  /* -------------------------------------------- */\n\n  /** @override */\n  static transformTypeData(source, activityData, options) {\n    // For weapons and ammunition, separate the first part from the rest to be used as the base damage and keep the rest\n    let damageParts = source.system.damage?.parts ?? [];\n    const hasBase = (source.type === \"weapon\")\n      || ((source.type === \"consumable\") && (source.system?.type?.value === \"ammo\"));\n    if ( hasBase && damageParts.length && !source.system.damage?.base ) {\n      const [base, ...rest] = damageParts;\n      source.system.damage.parts = [base];\n      damageParts = rest;\n    }\n\n    return foundry.utils.mergeObject(activityData, {\n      attack: {\n        ability: source.system.ability ?? \"\",\n        bonus: source.system.attack?.bonus ?? \"\",\n        critical: {\n          threshold: source.system.critical?.threshold\n        },\n        flat: source.system.attack?.flat ?? false,\n        type: {\n          value: source.system.actionType.startsWith(\"m\") ? \"melee\" : \"ranged\",\n          classification: source.system.actionType.endsWith(\"wak\") ? \"weapon\" : \"spell\"\n        }\n      },\n      damage: {\n        critical: {\n          bonus: source.system.critical?.damage\n        },\n        includeBase: true,\n        parts: damageParts.map(part => this.transformDamagePartData(source, part)) ?? []\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  prepareData() {\n    super.prepareData();\n    this.attack.type.value ||= this.item.system.attackType ?? \"melee\";\n    this.attack.type.classification ||= this.item.system.attackClassification ?? \"weapon\";\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  prepareFinalData(rollData) {\n    if ( this.damage.includeBase && this.item.system.offersBaseDamage && this.item.system.damage.base.formula ) {\n      const basePart = this.item.system.damage.base.clone(this.item.system.damage.base.toObject(false));\n      basePart.base = true;\n      basePart.locked = true;\n      this.damage.parts.unshift(basePart);\n    }\n\n    rollData ??= this.getRollData({ deterministic: true });\n    super.prepareFinalData(rollData);\n    this.prepareDamageLabel(this.damage.parts, rollData);\n\n    const { data, parts } = this.getAttackData();\n    const roll = new Roll(parts.join(\"+\"), data);\n    this.labels.modifier = simplifyRollFormula(roll.formula, { deterministic: true }) || \"0\";\n    const formula = simplifyRollFormula(roll.formula) || \"0\";\n    this.labels.toHit = !/^[+-]/.test(formula) ? `+${formula}` : formula;\n  }\n\n  /* -------------------------------------------- */\n  /*  Helpers                                     */\n  /* -------------------------------------------- */\n\n  /**\nThe game term label for this attack.\n@param {string} [attackMode]  The mode the attack was made with.\n@returns {string}\n/\n  getActionLabel(attackMode) {\n    let attackModeLabel;\n    if ( attackMode ) {\n      const key = attackMode.split(\"-\").map(s => s.capitalize()).join(\"\");\n      attackModeLabel = game.i18n.localize(`DND5E.ATTACK.Mode.${key}`);\n    }\n    const actionType = this.getActionType(attackMode);\n    let actionTypeLabel = game.i18n.localize(`DND5E.Action${actionType.toUpperCase()}`);\n    const isLegacy = game.settings.get(\"dnd5e\", \"rulesVersion\") === \"legacy\";\n    const isUnarmed = this.attack.type.classification === \"unarmed\";\n    if ( isUnarmed ) attackModeLabel = game.i18n.localize(\"DND5E.ATTACK.Classification.Unarmed\");\n    const isSpell = (actionType === \"rsak\") || (actionType === \"msak\");\n    if ( isLegacy || isSpell ) return [actionTypeLabel, attackModeLabel].filterJoin(\" &bull; \");\n    actionTypeLabel = game.i18n.localize(`DND5E.ATTACK.Attack.${actionType}`);\n    if ( isUnarmed ) return [actionTypeLabel, attackModeLabel].filterJoin(\" &bull; \");\n    const weaponType = CONFIG.DND5E.weaponTypeMap[this.item.system.type?.value];\n    const weaponTypeLabel = weaponType\n      ? game.i18n.localize(`DND5E.ATTACK.Weapon.${weaponType.capitalize()}`)\n      : CONFIG.DND5E.weaponTypes[this.item.system.type?.value];\n    return [actionTypeLabel, weaponTypeLabel, attackModeLabel].filterJoin(\" &bull; \");\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nGet the roll parts used to create the attack roll.\n@param {object} [config={}]\n@param {string} [config.ammunition]\n@param {string} [config.attackMode]\n@param {string} [config.situational]\n@returns {{ data: object, parts: string[] }}\n/\n  getAttackData({ ammunition, attackMode, situational }={}) {\n    const rollData = this.getRollData();\n    if ( this.attack.flat ) return CONFIG.Dice.BasicRoll.constructParts({ toHit: this.attack.bonus }, rollData);\n\n    const weapon = this.item.system;\n    const ammo = this.actor?.items.get(ammunition)?.system;\n    const { parts, data } = CONFIG.Dice.BasicRoll.constructParts({\n      mod: this.attack.ability !== \"none\" ? rollData.mod : null,\n      prof: weapon.prof?.term,\n      bonus: this.attack.bonus,\n      weaponMagic: weapon.magicAvailable ? weapon.magicalBonus : null,\n      ammoMagic: ammo?.magicAvailable ? ammo.magicalBonus : null,\n      actorBonus: this.actor?.system.bonuses?.[this.getActionType(attackMode)]?.attack,\n      situational\n    }, rollData);\n\n    // Add exhaustion reduction\n    this.actor?.addRollExhaustion(parts, data);\n\n    return { data, parts };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\n@typedef {AttackDamageRollProcessConfiguration} [config={}]\n@property {Item5e} ammunition  Ammunition used with the attack.\n@property {\"oneHanded\"|\"twoHanded\"|\"offhand\"|\"thrown\"|\"thrown-offhand\"} attackMode  Attack mode.\n/\n\n  /**\nGet the roll parts used to create the damage rolls.\n@param {Partial<AttackDamageRollProcessConfiguration>} [config={}]\n@returns {AttackDamageRollProcessConfiguration}\n/\n  getDamageConfig(config={}) {\n    const rollConfig = super.getDamageConfig(config);\n\n    // Handle ammunition\n    const ammo = config.ammunition?.system;\n    if ( ammo ) {\n      const properties = Array.from(ammo.properties).filter(p => CONFIG.DND5E.itemProperties[p]?.isPhysical);\n      if ( this.item.system.properties?.has(\"mgc\") && !properties.includes(\"mgc\") ) properties.push(\"mgc\");\n\n      // Add any new physical properties from the ammunition to the damage properties\n      for ( const roll of rollConfig.rolls ) {\n        for ( const property of properties ) {\n          if ( !roll.options.properties.includes(property) ) roll.options.properties.push(property);\n        }\n      }\n\n      // Add the ammunition's damage\n      if ( ammo.damage.base.formula ) {\n        const basePartIndex = rollConfig.rolls.findIndex(i => i.base);\n        const damage = ammo.damage.base.clone(ammo.damage.base);\n        const rollData = this.getRollData();\n\n        // If mode is \"replace\" and base part is present, replace the base part\n        if ( ammo.damage.replace & (basePartIndex !== -1) ) {\n          damage.base = true;\n          rollConfig.rolls.splice(basePartIndex, 1, this._processDamagePart(damage, config, rollData, basePartIndex));\n        }\n\n        // Otherwise stick the ammo damage after base part (or as first part)\n        else {\n          damage.ammo = true;\n          rollConfig.rolls.splice(\n            basePartIndex + 1, 0, this._processDamagePart(damage, rollConfig, rollData, basePartIndex + 1)\n          );\n        }\n      }\n    }\n\n    if ( this.damage.critical.bonus && !rollConfig.rolls[0]?.options?.critical?.bonusDamage ) {\n      foundry.utils.setProperty(rollConfig.rolls[0], \"options.critical.bonusDamage\", this.damage.critical.bonus);\n    }\n\n    return rollConfig;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreate a label based on this activity's settings and, if contained in a weapon, additional details from the weapon.\n@returns {string}\n/\n  getRangeLabel() {\n    if ( this.item.type !== \"weapon\" ) return this.labels?.range ?? \"\";\n\n    const parts = [];\n\n    // Add reach for melee weapons, unless the activity is explicitly specified as a ranged attack\n    if ( this.validAttackTypes.has(\"melee\") ) {\n      let { reach, units } = this.item.system.range;\n      if ( !reach ) reach = convertLength(5, \"ft\", units);\n      parts.push(game.i18n.format(\"DND5E.RANGE.Formatted.Reach\", {\n        reach: formatLength(reach, units, { strict: false })\n      }));\n    }\n\n    // Add range for ranged or thrown weapons, unless the activity is explicitly specified as melee\n    if ( this.validAttackTypes.has(\"ranged\") ) {\n      let range;\n      if ( this.range.override ) range = `${this.range.value} ${this.range.units ?? \"\"}`;\n      else {\n        const { value, long, units } = this.item.system.range;\n        if ( long && (value !== long) ) range = `${value}/${formatLength(long, units, { strict: false })}`;\n        else range = formatLength(value, units, { strict: false });\n      }\n      parts.push(game.i18n.format(\"DND5E.RANGE.Formatted.Range\", { range }));\n    }\n\n    return game.i18n.getListFormatter({ type: \"disjunction\" }).format(parts.filter(_ => _));\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "attackMode": "",
      "types": "",
      "includeMod": "",
      "p": "",
      "magicalBonus": "",
      "ammoBonus": "",
      "criticalBonusDice": ""
    },
    "CastActivityData": {
      "schema": "",
      "spell": "",
      "name": "",
      "img": ""
    },
    "CheckActivityData": {
      "calculation": "",
      "ability": "",
      "value": "",
      "type": ""
    },
    "DamageActivityData": {
      "part": "",
      "config": ""
    },
    "EnchantActivityData": {
      "keyPath": "",
      "level": "",
      "e": "",
      "effects": ""
    },
    "AppliedEffectField": {
      "fields": "",
      "options": "Field for storing an active effects applied by an activity.\n@property {string} _id  ID of the effect to apply.\n/\nexport default class AppliedEffectField extends SchemaField {\n  constructor(fields={}, options={}) {\n    super({\n      _id: new DocumentIdField(),\n      ...fields\n    }, options);\n  }\n\n  /* --------------------------------------------",
      "item": ""
    },
    "ConsumptionTargetsField": {
      "options": ""
    },
    "ConsumptionError": {
      "name": ""
    },
    "ForwardActivityData": {
      "schema": ""
    },
    "HealActivityData": {
      "config": "",
      "rollConfig": "",
      "rollData": "",
      "rolls": ""
    },
    "OrderActivityData": {
      "img": "Data model for an order activity.\n@property {string} order  The issued order.\n/\nexport default class OrderActivityData extends BaseActivityData {\n  /** @override */\n  static defineSchema() {\n    return {\n      _id: new DocumentIdField({ initial: () => foundry.utils.randomID() }),\n      type: new StringField({\n        blank: false, required: true, readOnly: true, initial: () => this.metadata.type\n      }),\n      name: new StringField({ initial: undefined }),\n      img: new FilePathField({ initial: undefined, categories: [\"IMAGE\"], base64: false }),\n      order: new StringField({ required: true, blank: false, nullable: false })\n    };\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc"
    },
    "SaveActivityData": {
      "calculation": "",
      "ability": "",
      "type": "",
      "onSave": "",
      "bonus": "",
      "value": "",
      "save": "",
      "config": ""
    },
    "SummonActivityData": {
      "level": "",
      "e": "",
      "keyPath": "",
      "i": ""
    },
    "UtilityActivityData": {},
    "CharacterData": {
      "static LOCALIZATION_PREFIXES": "",
      "static metadata": "",
      "static _systemType": "",
      "hd": "",
      "level": "",
      "value": "",
      "type": "",
      "prof": "",
      "max": "",
      "min": "",
      "required": "",
      "pct": "",
      "overflow": "",
      "boonsEarned": "",
      "progress": "",
      "rollData": "",
      "hpOptions": "",
      "bonus": "",
      "mod": "",
      "f": "",
      "maxSort": "",
      "favorites": ""
    },
    "DamageTraitField": {
      "fields": ""
    },
    "SimpleTraitField": {
      "fields": ""
    },
    "NPCData": {
      "static LOCALIZATION_PREFIXES": "",
      "static metadata": "",
      "static _systemType": "",
      "value": "",
      "v": "",
      "custom": "",
      "source": "",
      "original": "",
      "type": "",
      "pattern": "",
      "match": "",
      "typeLc": "",
      "typeMatch": "",
      "subtype": "",
      "sizeLc": "",
      "sizeMatch": "",
      "swarm": "",
      "level": "@typedef NPCHabitatData\n@property {string} type       The habitat category.\n@property {string} [subtype]  An optional discriminator for the main category.\n/\n\n/**\nSystem data definition for NPCs.\n@property {object} attributes\n@property {object} attributes.hd\n@property {number} attributes.hd.spent        Number of hit dice spent.\n@property {object} attributes.hp\n@property {number} attributes.hp.value        Current hit points.\n@property {number} attributes.hp.max          Maximum allowed HP value.\n@property {number} attributes.hp.temp         Temporary HP applied on top of value.\n@property {number} attributes.hp.tempmax      Temporary change to the maximum HP.\n@property {string} attributes.hp.formula      Formula used to determine hit points.\n@property {object} attributes.death\n@property {object} attributes.death.bonuses\n@property {string} attributes.death.bonuses.save   Numeric or dice bonus to death saving throws.\n@property {number} attributes.death.success        Number of successful death saves.\n@property {number} attributes.death.failure        Number of failed death saves.\n@property {object} attributes.spell\n@property {number} attributes.spell.level     Spellcasting level of this NPC.\n@property {object} details\n@property {TypeData} details.type             Creature type of this NPC.\n@property {string} details.type.value         NPC's type as defined in the system configuration.\n@property {string} details.type.subtype       NPC's subtype usually displayed in parenthesis after main type.\n@property {string} details.type.swarm         Size of the individual creatures in a swarm, if a swarm.\n@property {string} details.type.custom        Custom type beyond what is available in the configuration.\n@property {object} details.habitat\n@property {NPCHabitatData[]} details.habitat.value  Common habitats in which this NPC is found.\n@property {string} details.habitat.custom     Custom habitats.\n@property {object} details.treasure\n@property {Set<string>} details.treasure.value  Random treasure generation categories for this NPC.\n@property {number} details.cr                 NPC's challenge rating.\n@property {object} resources\n@property {object} resources.legact           NPC's legendary actions.\n@property {number} resources.legact.value     Currently available legendary actions.\n@property {number} resources.legact.max       Maximum number of legendary actions.\n@property {object} resources.legres           NPC's legendary resistances.\n@property {number} resources.legres.value     Currently available legendary resistances.\n@property {number} resources.legres.max       Maximum number of legendary resistances.\n@property {object} resources.lair             NPC's lair actions.\n@property {boolean} resources.lair.value      This creature can possess a lair (2024) or take lair actions (2014).\n@property {number} resources.lair.initiative  Initiative count when lair actions are triggered.\n@property {boolean} resources.lair.inside     This actor is currently inside its lair.\n@property {SourceData} source                 Adventure or sourcebook where this NPC originated.\n/\nexport default class NPCData extends CreatureTemplate {\n\n  /* -------------------------------------------- */\n  /*  Model Configuration                         */\n  /* -------------------------------------------- */\n\n  /** @override */\n  static LOCALIZATION_PREFIXES = [\"DND5E.NPC\", \"DND5E.BONUSES\", \"DND5E.SOURCE\"];\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static metadata = Object.freeze(foundry.utils.mergeObject(super.metadata, {\n    supportsAdvancement: true\n  }, {inplace: false}));\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static _systemType = \"npc\";\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static defineSchema() {\n    return this.mergeSchema(super.defineSchema(), {\n      attributes: new SchemaField({\n        ...AttributesFields.common,\n        ...AttributesFields.creature,\n        hd: new SchemaField({\n          spent: new NumberField({integer: true, min: 0, initial: 0})\n        }, {label: \"DND5E.HitDice\"}),\n        hp: new SchemaField({\n          value: new NumberField({\n            nullable: false, integer: true, min: 0, initial: 10, label: \"DND5E.HitPointsCurrent\"\n          }),\n          max: new NumberField({\n            nullable: false, integer: true, min: 0, initial: 10, label: \"DND5E.HitPointsMax\"\n          }),\n          temp: new NumberField({integer: true, initial: 0, min: 0, label: \"DND5E.HitPointsTemp\"}),\n          tempmax: new NumberField({\n            integer: true, initial: 0, label: \"DND5E.HitPointsTempMax\", hint: \"DND5E.HitPointsTempMaxHint\"\n          }),\n          formula: new FormulaField({required: true, label: \"DND5E.HPFormula\"})\n        }, {label: \"DND5E.HitPoints\"}),\n        death: new RollConfigField({\n          ability: false,\n          success: new NumberField({\n            required: true, nullable: false, integer: true, min: 0, initial: 0, label: \"DND5E.DeathSaveSuccesses\"\n          }),\n          failure: new NumberField({\n            required: true, nullable: false, integer: true, min: 0, initial: 0, label: \"DND5E.DeathSaveFailures\"\n          }),\n          bonuses: new SchemaField({\n            save: new FormulaField({ required: true, label: \"DND5E.DeathSaveBonus\" })\n          })\n        }, {label: \"DND5E.DeathSave\"}),\n        spell: new SchemaField({\n          level: new NumberField({\n            required: true, nullable: false, integer: true, min: 0, initial: 0, label: \"DND5E.SpellcasterLevel\"\n          })\n        })\n      }, {label: \"DND5E.Attributes\"}),\n      details: new SchemaField({\n        ...DetailsFields.common,\n        ...DetailsFields.creature,\n        type: new CreatureTypeField(),\n        habitat: new SchemaField({\n          value: new ArrayField(new SchemaField({\n            type: new StringField({ required: true }),\n            subtype: new StringField()\n          })),\n          custom: new StringField({ required: true })\n        }),\n        cr: new NumberField({\n          required: true, nullable: true, min: 0, initial: 1, label: \"DND5E.ChallengeRating\"\n        }),\n        treasure: new SchemaField({\n          value: new SetField(new StringField())\n        })\n      }, {label: \"DND5E.Details\"}),\n      resources: new SchemaField({\n        legact: new SchemaField({\n          value: new NumberField({\n            required: true, nullable: false, integer: true, min: 0, initial: 0, label: \"DND5E.LegendaryAction.Remaining\"\n          }),\n          max: new NumberField({\n            required: true, nullable: false, integer: true, min: 0, initial: 0, label: \"DND5E.LegendaryAction.Max\"\n          })\n        }, {label: \"DND5E.LegendaryAction.Label\"}),\n        legres: new SchemaField({\n          value: new NumberField({\n            required: true, nullable: false, integer: true, min: 0, initial: 0,\n            label: \"DND5E.LegendaryResistance.Remaining\"\n          }),\n          max: new NumberField({\n            required: true, nullable: false, integer: true, min: 0, initial: 0,\n            label: \"DND5E.LegendaryResistance.Max\"\n          })\n        }, {label: \"DND5E.LegendaryResistance.Label\"}),\n        lair: new SchemaField({\n          value: new BooleanField({required: true, label: \"DND5E.LAIR.Action.Uses\"}),\n          initiative: new NumberField({\n            required: true, integer: true, label: \"DND5E.LAIR.Action.Initiative\"\n          }),\n          inside: new BooleanField({ label: \"DND5E.LAIR.Inside\" })\n        }, {label: \"DND5E.LAIR.Action.Label\"})\n      }, {label: \"DND5E.Resources\"}),\n      source: new SourceField(),\n      traits: new SchemaField({\n        ...TraitsFields.common,\n        ...TraitsFields.creature,\n        important: new BooleanField()\n      }, {label: \"DND5E.Traits\"})\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  static get compendiumBrowserFilters() {\n    return new Map([\n      [\"size\", {\n        label: \"DND5E.Size\",\n        type: \"set\",\n        config: {\n          choices: CONFIG.DND5E.actorSizes,\n          keyPath: \"system.traits.size\"\n        }\n      }],\n      [\"type\", {\n        label: \"DND5E.CreatureType\",\n        type: \"set\",\n        config: {\n          choices: CONFIG.DND5E.creatureTypes,\n          keyPath: \"system.details.type.value\"\n        }\n      }],\n      [\"habitat\", {\n        label: \"DND5E.Habitat.Configuration.Label\",\n        type: \"set\",\n        config: {\n          choices: CONFIG.DND5E.habitats\n        },\n        createFilter: (filters, value, def) => {\n          const { include, exclude } = Object.entries(value).reduce((d, [key, value]) => {\n            if ( value === 1 ) d.include.push(key);\n            else if ( value === -1 ) d.exclude.push(key);\n            return d;\n          }, { include: [], exclude: [] });\n          if ( include.length ) filters.push({\n            k: \"system.details.habitat.value\", o: \"has\", v: { k: \"type\", o: \"in\", v: include }\n          });\n          if ( exclude.length ) filters.push({\n            o: \"NOT\", v: { k: \"system.details.habitat.value\", o: \"has\", v: { k: \"type\", o: \"in\", v: exclude } }\n          });\n        }\n      }],\n      [\"cr\", {\n        label: \"DND5E.ChallengeRating\",\n        type: \"range\",\n        config: {\n          keyPath: \"system.details.cr\",\n          min: 0,\n          max: 30\n        }\n      }],\n      [\"movement\", {\n        label: \"DND5E.Movement\",\n        type: \"set\",\n        config: {\n          choices: CONFIG.DND5E.movementTypes\n        },\n        createFilter: (filters, value, def) => {\n          for ( const [k, v] of Object.entries(value ?? {}) ) {\n            if ( v === 1 ) filters.push({ k: `system.attributes.movement.${k}`, o: \"gt\", v: 0 });\n            if ( v === -1 ) filters.push({ k: `system.attributes.movement.${k}`, v: 0 });\n          }\n        }\n      }]\n    ]);\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Migration                              */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static _migrateData(source) {\n    super._migrateData(source);\n    NPCData.#migrateEnvironment(source);\n    NPCData.#migrateSource(source);\n    NPCData.#migrateSpellLevel(source);\n    NPCData.#migrateTypeData(source);\n    AttributesFields._migrateInitiative(source.attributes);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConvert the plain string environment to a custom habitat.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #migrateEnvironment(source) {\n    const custom = source.details?.environment;\n    if ( (typeof custom === \"string\") && !(\"habitat\" in source.details) ) source.details.habitat = { custom };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConvert source string into custom object & move to top-level.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #migrateSource(source) {\n    let custom;\n    if ( (\"details\" in source) && (\"source\" in source.details) ) {\n      if ( foundry.utils.getType(source.details?.source) === \"string\" ) custom = source.details.source;\n      else source.source = { ...(source.source ?? {}), ...source.details.source };\n    }\n    if ( custom ) {\n      source.source ??= {};\n      source.source.custom = custom;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMove spell level from `details.spellLevel` to `attributes.spell.level`.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #migrateSpellLevel(source) {\n    if ( source.details?.spellLevel !== undefined ) {\n      source.attributes ??= {};\n      source.attributes.spell ??= {};\n      source.attributes.spell.level ??= source.details.spellLevel;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate the actor type string to type object.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #migrateTypeData(source) {\n    const original = source.type;\n    if ( typeof original !== \"string\" ) return;\n\n    source.type = {\n      value: \"\",\n      subtype: \"\",\n      swarm: \"\",\n      custom: \"\"\n    };\n\n    // Match the existing string\n    const pattern = /^(?:swarm of (?<size>[\\w-]+) )?(?<type>[^(]+?)(?:\\((?<subtype>[^)]+)\\))?$/i;\n    const match = original.trim().match(pattern);\n    if ( match ) {\n\n      // Match a known creature type\n      const typeLc = match.groups.type.trim().toLowerCase();\n      const typeMatch = Object.entries(CONFIG.DND5E.creatureTypes).find(([k, v]) => {\n        return (typeLc === k)\n          || (typeLc === game.i18n.localize(v.label).toLowerCase())\n          || (typeLc === game.i18n.localize(`${v.label}Pl`).toLowerCase());\n      });\n      if ( typeMatch ) source.type.value = typeMatch[0];\n      else {\n        source.type.value = \"custom\";\n        source.type.custom = match.groups.type.trim().titleCase();\n      }\n      source.type.subtype = match.groups.subtype?.trim().titleCase() ?? \"\";\n\n      // Match a swarm\n      if ( match.groups.size ) {\n        const sizeLc = match.groups.size ? match.groups.size.trim().toLowerCase() : \"tiny\";\n        const sizeMatch = Object.entries(CONFIG.DND5E.actorSizes).find(([k, v]) => {\n          return (sizeLc === k) || (sizeLc === game.i18n.localize(v.label).toLowerCase());\n        });\n        source.type.swarm = sizeMatch ? sizeMatch[0] : \"tiny\";\n      }\n      else source.type.swarm = \"\";\n    }\n\n    // No match found\n    else {\n      source.type.value = \"custom\";\n      source.type.custom = original;\n    }\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "max": "",
      "denomination": "",
      "lairAdjustment": "",
      "cr": "",
      "prof": "",
      "attributes": "",
      "rollData": "",
      "pct": "",
      "hpOptions": "",
      "label": "",
      "delta": "",
      "mode": "",
      "name": "",
      "pr": "",
      "rulesVersion": "",
      "i": "",
      "options": "",
      "context": "",
      "cite": "",
      "anchor": "",
      "template": "",
      "innerHTML": "",
      "formatter": "",
      "prepareMeasured": "",
      "prepareTrait": "",
      "prepared": "",
      "k": "",
      "entries": "",
      "category": "",
      "trait": "",
      "data": "",
      "list": "",
      "t": "",
      "description": "",
      "identifier": "",
      "openingTag": "",
      "uses": "",
      "key": ""
    },
    "AttributesFields": {
      "init": "",
      "bonus": "",
      "ac": "",
      "armor": "",
      "shield": "",
      "min": "",
      "encumbrance": "",
      "multipliers": "",
      "bonuses": "",
      "cfg": "",
      "calc": "",
      "flat": "",
      "value": "",
      "base": "",
      "formula": "",
      "armorData": "",
      "isHeavy": "",
      "dex": "",
      "equippedArmor": "",
      "replaced": "",
      "equippedShield": "",
      "cover": "",
      "abilityId": "",
      "ability": "",
      "save": "",
      "config": "",
      "baseUnits": "",
      "unitSystem": "",
      "weight": "",
      "currency": "",
      "numCoins": "",
      "currencyPerWeight": "",
      "keys": "",
      "index": "",
      "sizeConfig": "",
      "sizeMod": "",
      "calculateThreshold": "",
      "multiplier": "",
      "threshold": "",
      "type": "",
      "thresholds": "",
      "max": "",
      "mod": "",
      "stops": "",
      "pct": "",
      "encumbered": "",
      "exhaustion": "",
      "level": "",
      "options": "",
      "effectiveMax": "",
      "damage": "",
      "flags": "",
      "globalCheckBonus": "",
      "isLegacy": "",
      "prof": "",
      "joat": "",
      "ra": "",
      "alert": "",
      "initBonus": "",
      "abilityBonus": "",
      "total": "",
      "score": "",
      "statuses": "",
      "noMovement": "",
      "halfMovement": "",
      "heavilyEncumbered": "",
      "exceedingCarryingCapacity": "",
      "crawl": "",
      "units": "",
      "reduction": "",
      "speed": "",
      "hover": "",
      "special": "",
      "abilityLabel": "",
      "attack": "",
      "dc": ""
    },
    "CreatureTemplate": {
      "ability": "",
      "levels": "",
      "original": "A template for all actors that are creatures\n@property {object} bonuses\n@property {AttackBonusesData} bonuses.mwak        Bonuses to melee weapon attacks.\n@property {AttackBonusesData} bonuses.rwak        Bonuses to ranged weapon attacks.\n@property {AttackBonusesData} bonuses.msak        Bonuses to melee spell attacks.\n@property {AttackBonusesData} bonuses.rsak        Bonuses to ranged spell attacks.\n@property {object} bonuses.abilities              Bonuses to ability scores.\n@property {string} bonuses.abilities.check        Numeric or dice bonus to ability checks.\n@property {string} bonuses.abilities.save         Numeric or dice bonus to ability saves.\n@property {string} bonuses.abilities.skill        Numeric or dice bonus to skill checks.\n@property {object} bonuses.spell                  Bonuses to spells.\n@property {string} bonuses.spell.dc               Numeric bonus to spellcasting DC.\n@property {Record<string, ToolData>} tools        Actor's tools.\n@property {Record<string, SkillData>} skills      Actor's skills.\n@property {Record<string, SpellSlotData>} spells  Actor's spell slots.\n/\nexport default class CreatureTemplate extends CommonTemplate {\n  static defineSchema() {\n    return this.mergeSchema(super.defineSchema(), {\n      bonuses: new SchemaField({\n        mwak: makeAttackBonuses(),\n        rwak: makeAttackBonuses(),\n        msak: makeAttackBonuses(),\n        rsak: makeAttackBonuses(),\n        abilities: new SchemaField({\n          check: new FormulaField({ required: true }),\n          save: new FormulaField({ required: true }),\n          skill: new FormulaField({ required: true })\n        }),\n        spell: new SchemaField({\n          dc: new FormulaField({ required: true, deterministic: true })\n        })\n      }),\n      skills: new MappingField(new RollConfigField({\n        value: new NumberField({\n          required: true, nullable: false, min: 0, max: 2, step: 0.5, initial: 0, label: \"DND5E.ProficiencyLevel\"\n        }),\n        ability: \"dex\",\n        bonuses: new SchemaField({\n          check: new FormulaField({ required: true, label: \"DND5E.SkillBonusCheck\" }),\n          passive: new FormulaField({ required: true, label: \"DND5E.SkillBonusPassive\" })\n        }, { label: \"DND5E.SkillBonuses\" })\n      }), {\n        initialKeys: CONFIG.DND5E.skills, initialValue: this._initialSkillValue,\n        initialKeysOnly: true, label: \"DND5E.Skills\"\n      }),\n      tools: new MappingField(new RollConfigField({\n        value: new NumberField({\n          required: true, nullable: false, min: 0, max: 2, step: 0.5, initial: 1, label: \"DND5E.ProficiencyLevel\"\n        }),\n        ability: \"int\",\n        bonuses: new SchemaField({\n          check: new FormulaField({ required: true, label: \"DND5E.CheckBonus\" })\n        }, { label: \"DND5E.ToolBonuses\" })\n      })),\n      spells: new MappingField(new SchemaField({\n        value: new NumberField({\n          nullable: false, integer: true, min: 0, initial: 0, label: \"DND5E.SpellProgAvailable\"\n        }),\n        override: new NumberField({\n          integer: true, min: 0, label: \"DND5E.SpellProgOverride\"\n        })\n      }), { initialKeys: this._spellLevels, label: \"DND5E.SpellLevels\" })\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPopulate the proper initial abilities for the skills.\n@param {string} key      Key for which the initial data will be created.\n@param {object} initial  The initial skill object created by SkillData.\n@returns {object}        Initial skills object with the ability defined.\n@private\n/\n  static _initialSkillValue(key, initial) {\n    if ( CONFIG.DND5E.skills[key]?.ability ) initial.ability = CONFIG.DND5E.skills[key].ability;\n    return initial;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHelper for building the default list of spell levels.\n@type {string[]}\n@private\n/\n  static get _spellLevels() {\n    const levels = Object.keys(CONFIG.DND5E.spellLevels).filter(a => a !== \"0\").map(l => `spell${l}`);\n    return [...levels, \"pact\"];\n  }\n\n  /* -------------------------------------------- */\n  /*  Migrations                                  */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static _migrateData(source) {\n    super._migrateData(source);\n    CreatureTemplate.#migrateSensesData(source);\n    CreatureTemplate.#migrateToolData(source);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate the actor traits.senses string to attributes.senses object.\n@param {object} source  The candidate source data from which the model will be constructed.",
      "pattern": "",
      "wasMatched": "",
      "s": "",
      "match": "",
      "type": "",
      "special": "",
      "validProf": "",
      "options": "",
      "globalCheckBonus": "",
      "globalSkillBonus": "",
      "flags": "",
      "abilityData": "",
      "baseBonus": "",
      "value": "",
      "checkBonusAbl": "",
      "effectValue": "",
      "bonus": "",
      "mod": "",
      "prof": "",
      "total": "",
      "passive": "",
      "passiveBonus": "",
      "deterministic": "",
      "classes": "",
      "hitDice": "",
      "subclass": ""
    },
    "DetailsField": {},
    "TraitsField": {
      "schemaOptions": "",
      "languages": "",
      "labels": "",
      "processCategory": "",
      "topLevel": "",
      "data": "",
      "custom": "",
      "type": ""
    },
    "VehicleData": {
      "static LOCALIZATION_PREFIXES": "",
      "static _systemType": "",
      "custom": "",
      "source": "",
      "prof": "@import { SourceData } from \"../shared/source-field.mjs\"\n@import { ArmorClassData } from \"./templates/attributes.mjs\"\n/\n\n/**\nSystem data definition for Vehicles.\n@property {string} vehicleType                      Type of vehicle as defined in `DND5E.vehicleTypes`.\n@property {object} attributes\n@property {ArmorClassData} attributes.ac\n@property {string} attributes.ac.motionless         Changes to vehicle AC when not moving.\n@property {object} attributes.hp\n@property {number} attributes.hp.value              Current hit points.\n@property {number} attributes.hp.max                Maximum allowed HP value.\n@property {number} attributes.hp.temp               Temporary HP applied on top of value.\n@property {number} attributes.hp.tempmax            Temporary change to the maximum HP.\n@property {number} attributes.hp.dt                 Damage threshold.\n@property {number} attributes.hp.mt                 Mishap threshold.\n@property {object} attributes.actions               Information on how the vehicle performs actions.\n@property {boolean} attributes.actions.stations     Does this vehicle rely on action stations that required\n                                                    individual crewing rather than general crew thresholds?\n@property {number} attributes.actions.value         Maximum number of actions available with full crewing.\n@property {object} attributes.actions.thresholds    Crew thresholds needed to perform various actions.\n@property {number} attributes.actions.thresholds.2  Minimum crew needed to take full action complement.\n@property {number} attributes.actions.thresholds.1  Minimum crew needed to take reduced action complement.\n@property {number} attributes.actions.thresholds.0  Minimum crew needed to perform any actions.\n@property {object} attributes.capacity              Information on the vehicle's carrying capacity.\n@property {string} attributes.capacity.creature     Description of the number of creatures the vehicle can carry.\n@property {number} attributes.capacity.cargo        Cargo carrying capacity measured in tons.\n@property {object} traits\n@property {string} traits.dimensions                Width and length of the vehicle.\n@property {object} cargo                            Details on this vehicle's crew and cargo capacities.\n@property {PassengerData[]} cargo.crew              Creatures responsible for operating the vehicle.\n@property {PassengerData[]} cargo.passengers        Creatures just takin' a ride.\n@property {SourceData} source                       Adventure or sourcebook where this vehicle originated.\n/\nexport default class VehicleData extends CommonTemplate {\n\n  /* -------------------------------------------- */\n  /*  Model Configuration                         */\n  /* -------------------------------------------- */\n\n  /** @override */\n  static LOCALIZATION_PREFIXES = [\"DND5E.SOURCE\"];\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static _systemType = \"vehicle\";\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static defineSchema() {\n    return this.mergeSchema(super.defineSchema(), {\n      vehicleType: new StringField({ required: true, initial: \"water\", label: \"DND5E.VehicleType\" }),\n      attributes: new SchemaField({\n        ...AttributesFields.common,\n        ac: new SchemaField({\n          ...AttributesFields.armorClass,\n          motionless: new StringField({ required: true, label: \"DND5E.ArmorClassMotionless\" })\n        }, { label: \"DND5E.ArmorClass\" }),\n        hp: new SchemaField({\n          value: new NumberField({\n            nullable: true, integer: true, min: 0, initial: null, label: \"DND5E.HitPointsCurrent\"\n          }),\n          max: new NumberField({\n            nullable: true, integer: true, min: 0, initial: null, label: \"DND5E.HitPointsMax\"\n          }),\n          temp: new NumberField({ integer: true, initial: 0, min: 0, label: \"DND5E.HitPointsTemp\" }),\n          tempmax: new NumberField({\n            integer: true, initial: 0, label: \"DND5E.HitPointsTempMax\", hint: \"DND5E.HitPointsTempMaxHint\"\n          }),\n          dt: new NumberField({\n            required: true, integer: true, min: 0, label: \"DND5E.DamageThreshold\"\n          }),\n          mt: new NumberField({\n            required: true, integer: true, min: 0, label: \"DND5E.VehicleMishapThreshold\"\n          })\n        }, {label: \"DND5E.HitPoints\"}),\n        actions: new SchemaField({\n          stations: new BooleanField({ required: true, label: \"DND5E.VehicleActionStations\" }),\n          value: new NumberField({\n            required: true, nullable: false, integer: true, initial: 0, min: 0, label: \"DND5E.VehicleActionMax\"\n          }),\n          thresholds: new SchemaField({\n            2: new NumberField({\n              required: true, integer: true, min: 0, label: \"DND5E.VehicleActionThresholdsFull\"\n            }),\n            1: new NumberField({\n              required: true, integer: true, min: 0, label: \"DND5E.VehicleActionThresholdsMid\"\n            }),\n            0: new NumberField({\n              required: true, integer: true, min: 0, label: \"DND5E.VehicleActionThresholdsMin\"\n            })\n          }, {label: \"DND5E.VehicleActionThresholds\"})\n        }, {label: \"DND5E.VehicleActions\"}),\n        capacity: new SchemaField({\n          creature: new StringField({ required: true, label: \"DND5E.VehicleCreatureCapacity\" }),\n          cargo: new NumberField({\n            required: true, nullable: false, integer: true, initial: 0, min: 0, label: \"DND5E.VehicleCargoCapacity\"\n          })\n        }, { label: \"DND5E.VehicleCargoCrew\" })\n      }, { label: \"DND5E.Attributes\" }),\n      details: new SchemaField(DetailsFields.common, { label: \"DND5E.Details\" }),\n      source: new SourceField(),\n      traits: new SchemaField({\n        ...TraitsFields.common,\n        size: new StringField({ required: true, initial: \"lg\", label: \"DND5E.Size\" }),\n        di: new DamageTraitField({}, { label: \"DND5E.DamImm\", initialValue: [\"poison\", \"psychic\"] }),\n        ci: new SimpleTraitField({}, { label: \"DND5E.ConImm\", initialValue: [\n          \"blinded\", \"charmed\", \"deafened\", \"frightened\", \"paralyzed\",\n          \"petrified\", \"poisoned\", \"stunned\", \"unconscious\"\n        ] }),\n        dimensions: new StringField({ required: true, label: \"DND5E.Dimensions\" })\n      }, { label: \"DND5E.Traits\" }),\n      cargo: new SchemaField({\n        crew: new ArrayField(makePassengerData(), { label: \"DND5E.VehicleCrew\" }),\n        passengers: new ArrayField(makePassengerData(), { label: \"DND5E.VehiclePassengers\" })\n      }, { label: \"DND5E.VehicleCrewPassengers\" })\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static _migrateData(source) {\n    super._migrateData(source);\n    AttributesFields._migrateInitiative(source.attributes);\n    VehicleData.#migrateSource(source);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConvert source string into custom object & move to top-level.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #migrateSource(source) {\n    let custom;\n    if ( (\"details\" in source) && (\"source\" in source.details) ) {\n      if ( foundry.utils.getType(source.details?.source) === \"string\" ) custom = source.details.source;\n      else source.source = source.details.source;\n    }\n    if ( custom ) source.source = { custom };\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "calc": "",
      "rollData": "",
      "item": ""
    },
    "AbilityScoreImprovementValueData": {},
    "BaseAdvancement": {
      "v": "",
      "hint": ""
    },
    "ScaleValueTypeNumber": {
      "value": "Data model for the Scale Value advancement type.\n@property {string} identifier        Identifier used to select this scale value in roll formulas.\n@property {string} type              Type of data represented by this scale value.\n@property {object} [distance]\n@property {string} [distance.units]  If distance type is selected, the units each value uses.\n@property {Object<string, *>} scale  Scale values for each level. Value format is determined by type.\n/\nexport class ScaleValueConfigurationData extends foundry.abstract.DataModel {\n\n  /* -------------------------------------------- */\n  /*  Model Configuration                         */\n  /* -------------------------------------------- */\n\n  /** @override */\n  static LOCALIZATION_PREFIXES = [\"DND5E.ADVANCEMENT.ScaleValue\"];\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static defineSchema() {\n    return {\n      identifier: new IdentifierField({ required: true }),\n      type: new StringField({ required: true, initial: \"string\", choices: TYPES }),\n      distance: new SchemaField({ units: new StringField({ required: true }) }),\n      scale: new MappingField(new ScaleValueEntryField(), { required: true })\n    };\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Migrations                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static migrateData(source) {\n    super.migrateData(source);\n    if ( source.type === \"numeric\" ) source.type = \"number\";\n    Object.values(source.scale ?? {}).forEach(v => TYPES[source.type].migrateData(v));\n  }\n}\n\n\n/**\nData field that automatically selects the appropriate ScaleValueType based on the selected type.\n/\nexport class ScaleValueEntryField extends foundry.data.fields.ObjectField {\n  /** @override */\n  _cleanType(value, options) {\n    if ( !(typeof value === \"object\") ) value = {};\n\n    // Use a defined DataModel\n    const cls = TYPES[options.source?.type];\n    if ( cls ) return cls.cleanData(value, options);\n\n    return value;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  initialize(value, model, options={}) {\n    const cls = TYPES[model.type];\n    if ( !value || !cls ) return value;\n    return new cls(value, {parent: model, ...options});\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  toObject(value) {\n    return value.toObject(false);\n  }\n}\n\n\n/**\nBase scale value data type that stores generic string values.\n@property {string} value  String value.\n/\nexport class ScaleValueType extends foundry.abstract.DataModel {\n\n  /* -------------------------------------------- */\n  /*  Model Configuration                         */\n  /* -------------------------------------------- */\n\n  /** @override */\n  static LOCALIZATION_PREFIXES = [\"DND5E.ADVANCEMENT.ScaleValue.Type.String\"];\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static defineSchema() {\n    return {\n      value: new StringField({ required: true })\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nInformation on how a scale value of this type is configured.\n@typedef {object} ScaleValueTypeMetadata\n@property {string} label       Name of this type.\n@property {string} hint        Hint for this type shown in the scale value configuration.\n@property {string} identifier  Hint for the identifier for this type.\n@property {boolean} isNumeric  When using the default editing interface, should numeric inputs be used?\n/\n\n  /**\nConfiguration information for this scale value type.\n@type {ScaleValueTypeMetadata}\n/\n  static get metadata() {\n    return {\n      label: \"DND5E.ADVANCEMENT.ScaleValue.Type.String.Label\",\n      hint: \"DND5E.ADVANCEMENT.ScaleValue.Type.String.Hint\",\n      identifier: \"DND5E.ADVANCEMENT.ScaleValue.Type.String.Identifier\",\n      isNumeric: false\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAttempt to convert another scale value type to this one.\n@param {ScaleValueType} original  Original type to attempt to convert.\n@param {object} [options]         Options which affect DataModel construction.\n@returns {ScaleValueType|null}\n/\n  static convertFrom(original, options) {\n    return new this({ value: original.formula }, options);\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nThis scale value prepared to be used in roll formulas.\n@type {string|null}\n/\n  get formula() { return this.value; }\n\n  /* -------------------------------------------- */\n\n  /**\nThis scale value formatted for display.\n@type {string|null}\n/\n  get display() { return this.formula; }\n\n  /* -------------------------------------------- */\n\n  /**\nShortcut to the prepared value when used in roll formulas.\n@returns {string}\n/\n  toString() {\n    return this.formula;\n  }\n\n  /* -------------------------------------------- */\n  /*  Helpers                                     */\n  /* -------------------------------------------- */\n\n  /**\nRetrieve field data with associated values.\n@param {number} level                Level for which this data is being prepared.\n@param {ScaleValueType} [value]      Value for the field at this level.\n@param {ScaleValueType} [lastValue]  Previous value used to generate placeholders.\n@returns {Record<string, object>}\n/\n  static getFields(level, value, lastValue) {\n    const fields = {};\n    for ( const [name, field] of Object.entries(this.schema.fields) ) {\n      if ( field.options.hidden ) continue;\n      fields[name] = {\n        field,\n        input: field instanceof BooleanField ? createCheckboxInput : null,\n        name: `configuration.scale.${level}.${name}`,\n        placeholder: this.getPlaceholder(name, lastValue),\n        value: value?.[name]\n      };\n    }\n    return fields;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreate a placeholder value for the provided field.\n@param {string} name                 Name of the field.\n@param {ScaleValueType} [lastValue]  Scale value from a lower level.\n@returns {string}\n/\n  static getPlaceholder(name, lastValue) {\n    return lastValue?.[name] ?? \"\";\n  }\n}\n\n\n/**\nScale value data type that stores numeric values.\n@property {number} value  Numeric value.\n/\nexport class ScaleValueTypeNumber extends ScaleValueType {\n\n  /* -------------------------------------------- */\n  /*  Model Configuration                         */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static defineSchema() {\n    return {\n      value: new NumberField({ required: true })\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static get metadata() {\n    return foundry.utils.mergeObject(super.metadata, {\n      label: \"DND5E.ADVANCEMENT.ScaleValue.Type.Number.Label\",\n      hint: \"DND5E.ADVANCEMENT.ScaleValue.Type.Number.Hint\",\n      isNumeric: true\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc"
    },
    "ScaleValueTypeCR": {
      "static LOCALIZATION_PREFIXES": ""
    },
    "ScaleValueTypeDice": {
      "static LOCALIZATION_PREFIXES": "",
      "static FACES": "",
      "number": "",
      "faces": "",
      "fields": "",
      "options": "",
      "name": ""
    },
    "ScaleValueTypeDistance": {},
    "ActivationsField": {
      "i": "",
      "uuid": ""
    },
    "ActorDeltasField": {
      "deltas": "",
      "rolls": ""
    },
    "IndividualDeltaField": {
      "updates": "",
      "deltas": "",
      "currentValue": "",
      "delta": "",
      "rolls": "",
      "value": "",
      "roll": ""
    },
    "RestMessageData": {
      "static metadata": "",
      "context": "",
      "activities": "",
      "deltas": ""
    },
    "TurnMessageData": {
      "static metadata": "",
      "context": "",
      "activities": "",
      "deltas": ""
    },
    "ActivitiesField": {
      "activities": ""
    },
    "ActivityCollection": {
      "model": "",
      "types": "",
      "key": "",
      "source": ""
    },
    "EnchantmentField": {
      "options": ""
    },
    "EnchantmentError": {
      "name": ""
    },
    "SpellcastingField": {
      "fields": "",
      "max": "",
      "type": "",
      "actor": "",
      "levels": "",
      "ability": "",
      "mod": "",
      "modProf": "",
      "msak": "",
      "rsak": "",
      "attack": "",
      "save": ""
    },
    "SummonsField": {
      "options": ""
    },
    "ActionTemplate": {
      "ability": "",
      "bonus": "",
      "critical": "",
      "damage": "",
      "scaling": "",
      "dc": "",
      "ammoThreshold": "",
      "threshold": "",
      "actionType": "@deprecated since 4.0, targeted for removal in 4.4\n@mixin\n/\nexport default class ActionTemplate extends ItemDataModel {\n  /** @inheritDoc */\n  static defineSchema() {\n    foundry.utils.logCompatibilityWarning(\n      \"The `ActionTemplate` data model has been deprecated in favor of `ActivitiesTemplate`.\",\n      { since: \"DnD5e 4.0\", until: \"DnD5e 4.4\", once: true }\n    );\n    return {\n      ability: new StringField({required: true, nullable: true, initial: null, label: \"DND5E.AbilityModifier\"}),\n      actionType: new StringField({required: true, nullable: true, initial: null, label: \"DND5E.ItemActionType\"}),\n      attack: new SchemaField({\n        bonus: new FormulaField({required: true, label: \"DND5E.ItemAttackBonus\"}),\n        flat: new BooleanField({label: \"DND5E.ItemAttackFlat\"})\n      }),\n      chatFlavor: new StringField({required: true, label: \"DND5E.ChatFlavor\"}),\n      critical: new SchemaField({\n        threshold: new NumberField({\n          required: true, integer: true, initial: null, positive: true, label: \"DND5E.ItemCritThreshold\"\n        }),\n        damage: new FormulaField({required: true, label: \"DND5E.ItemCritExtraDamage\"})\n      }),\n      damage: new SchemaField({\n        parts: new ArrayField(new ArrayField(new StringField({nullable: true})), {required: true}),\n        versatile: new FormulaField({required: true, label: \"DND5E.VersatileDamage\"})\n      }, {label: \"DND5E.Damage\"}),\n      enchantment: new EnchantmentField(),\n      formula: new FormulaField({required: true, label: \"DND5E.OtherFormula\"}),\n      save: new SchemaField({\n        ability: new StringField({required: true, blank: true, label: \"DND5E.Ability\"}),\n        dc: new NumberField({required: true, min: 0, integer: true, label: \"DND5E.AbbreviationDC\"}),\n        scaling: new StringField({required: true, blank: false, initial: \"spell\", label: \"DND5E.ScalingFormula\"})\n      }, {label: \"DND5E.SavingThrow\"}),\n      summons: new SummonsField()\n    };\n  }\n\n  /* -------------------------------------------- */\n  /*  Migrations                                  */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static _migrateData(source) {\n    super._migrateData(source);\n    ActionTemplate.#migrateAbility(source);\n    ActionTemplate.#migrateAttack(source);\n    ActionTemplate.#migrateCritical(source);\n    ActionTemplate.#migrateSave(source);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate the ability field.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #migrateAbility(source) {\n    if ( Array.isArray(source.ability) ) source.ability = source.ability[0];\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMove 'attackBonus' to 'attack.bonus' and ensure a 0 or null is converted to an empty string rather than \"0\".\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #migrateAttack(source) {\n    if ( \"attackBonus\" in source ) {\n      source.attack ??= {};\n      source.attack.bonus ??= source.attackBonus;\n    }\n    if ( [0, \"0\", null].includes(source.attack?.bonus) ) source.attack.bonus = \"\";\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEnsure the critical field is an object.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #migrateCritical(source) {\n    if ( !(\"critical\" in source) ) return;\n    if ( (typeof source.critical !== \"object\") || (source.critical === null) ) source.critical = {\n      threshold: null,\n      damage: \"\"\n    };\n    if ( source.critical.damage === null ) source.critical.damage = \"\";\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate the save field.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #migrateSave(source) {\n    if ( !(\"save\" in source) ) return;\n    source.save ??= {};\n    if ( source.save.scaling === \"\" ) source.save.scaling = \"spell\";\n    if ( source.save.ability === null ) source.save.ability = \"\";\n    if ( typeof source.save.dc === \"string\" ) {\n      if ( source.save.dc === \"\" ) source.save.dc = null;\n      else if ( Number.isNumeric(source.save.dc) ) source.save.dc = Number(source.save.dc);\n    }\n  }\n\n  /* -------------------------------------------- */\n  /*  Getters                                     */\n  /* -------------------------------------------- */\n\n  /**\nWhich ability score modifier is used by this item?\n@type {string|null}\n/\n  get abilityMod() {\n    if ( this.ability === \"none\" ) return null;\n    return this.ability || this._typeAbilityMod || {\n      mwak: \"str\",\n      rwak: \"dex\",\n      msak: this.parent?.actor?.system.attributes.spellcasting || \"int\",\n      rsak: this.parent?.actor?.system.attributes.spellcasting || \"int\"\n    }[this.actionType] || null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDefault ability key defined for this type.\n@type {string|null}\n@internal\n/\n  get _typeAbilityMod() {\n    return null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nWhat is the critical hit threshold for this item? Uses the smallest value from among the following sources:\n - `critical.threshold` defined on the item\n - `critical.threshold` defined on ammunition, if consumption mode is set to ammo\n - Type-specific critical threshold\n@type {number|null}\n/\n  get criticalThreshold() {\n    if ( !this.hasAttack ) return null;\n    let ammoThreshold = Infinity;\n    if ( this.hasAmmo ) {\n      ammoThreshold = this.parent?.actor?.items.get(this.consume.target)?.system.critical.threshold ?? Infinity;\n    }\n    const threshold = Math.min(this.critical.threshold ?? Infinity, this._typeCriticalThreshold, ammoThreshold);\n    return threshold < Infinity ? threshold : 20;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDefault critical threshold for this type.\n@type {number}\n@internal\n/\n  get _typeCriticalThreshold() {\n    return Infinity;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item implement an ability check as part of its usage?\n@type {boolean}",
      "data": "",
      "key": "",
      "mod": ""
    },
    "ActivatedEffectTemplate": {
      "static ItemUsesField": "",
      "value": "",
      "units": "",
      "rollData": "",
      "duration": "",
      "concentrationDuration": "",
      "activation": "",
      "target": "",
      "range": "",
      "recharge": "",
      "item": "",
      "property": "",
      "formula": "",
      "roll": "",
      "message": "",
      "max": "",
      "long": "",
      "type": "",
      "amount": "",
      "consume": ""
    },
    "ItemUsesField": {
      "value": "",
      "units": "",
      "rollData": "",
      "duration": "",
      "concentrationDuration": "",
      "activation": "",
      "target": "",
      "range": "",
      "recharge": "",
      "item": "",
      "property": "",
      "formula": "",
      "roll": "",
      "message": "",
      "max": "",
      "long": "",
      "type": "",
      "amount": "",
      "consume": ""
    },
    "ActivitiesTemplate": {
      "static LOCALIZATION_PREFIXES": "",
      "activity": "",
      "a": "",
      "max": "",
      "charged": "",
      "spent": "",
      "per": "",
      "recovery": "",
      "uses": "",
      "type": "Data model template for items with activities.\n@property {ActivityCollection} activities  Activities on this item.\n@property {UsesData} uses                  Item's limited uses & recovery.\n@mixin\n/\nexport default class ActivitiesTemplate extends SystemDataModel {\n\n  /** @override */\n  static LOCALIZATION_PREFIXES = [\"DND5E.USES\"];\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static defineSchema() {\n    return {\n      activities: new ActivitiesField(),\n      uses: new UsesField()\n    };\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nWhich ability score modifier is used by this item?\n@type {string|null}\n/\n  get abilityMod() {\n    return this._typeAbilityMod || null;\n  }\n\n  /**\nDefault ability key defined for this type.\n@type {string|null}\n@internal\n/\n  get _typeAbilityMod() {\n    return null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEnchantments that have been applied by this item.\n@type {ActiveEffect5e[]}\n/\n  get appliedEnchantments() {\n    return dnd5e.registry.enchantments.applied(this.parent.uuid);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nValue on a d20 die needed to roll a critical hit with an attack from this item.\n@type {number|null}\n/\n  get criticalThreshold() {\n    return this._typeCriticalThreshold ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item implement an attack roll as part of its usage?\n@type {boolean}\n/\n  get hasAttack() {\n    return !!this.activities.getByType(\"attack\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this Item limited in its ability to be used by charges or by recharge?\n@type {boolean}\n/\n  get hasLimitedUses() {\n    return !!this._source.uses.max || !!this.uses.max;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item implement a saving throw as part of its usage?\n@type {boolean}\n/\n  get hasSave() {\n    return !!this.activities.getByType(\"save\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes this Item implement summoning as part of its usage?\n@type {boolean}\n/\n  get hasSummoning() {\n    const activity = this.activities.getByType(\"summon\")[0];\n    return activity && activity.profiles.length > 0;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this Item an activatable item?\n@type {boolean}\n/\n  get isActive() {\n    return this.activities.size > 0;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCan this item enchant other items?\n@type {boolean}\n/\n  get isEnchantment() {\n    return !!this.activities.getByType(\"enchant\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item provide an amount of healing instead of conventional damage?\n@type {boolean}\n/\n  get isHealing() {\n    return !!this.activities.getByType(\"heal\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreatures summoned by this item.\n@type {Actor5e[]}\n/\n  get summonedCreatures() {\n    if ( !this.actor ) return [];\n    return this.activities.getByType(\"summon\").map(a => a.summonedCreatures).flat();\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Migrations                             */\n  /* -------------------------------------------- */\n\n  /**\nMigrate the uses data structure from before activities.\n@param {object} source  Candidate source data to migrate.\n/\n  static migrateActivities(source) {\n    ActivitiesTemplate.#migrateUses(source);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate the uses to the new data structure.\n@param {object} source  Candidate source data to migrate.\n/\n  static #migrateUses(source) {\n    // Remove any old ternary operators from uses to prevent errors\n    if ( source.uses?.max?.includes?.(\" ? \") ) source.uses.max = \"\";\n    for ( const activity of Object.values(source.activities ?? {}) ) {\n      if ( activity?.uses?.max?.includes?.(\" ? \") ) activity.uses.max = \"\";\n    }\n\n    if ( Array.isArray(source.uses?.recovery) ) return;\n\n    const charged = source.recharge?.charged;\n    if ( (source.recharge?.value !== null) && (charged !== undefined) && !source.uses?.max ) {\n      source.uses ??= {};\n      source.uses.spent = charged ? 0 : 1;\n      source.uses.max = \"1\";\n    }\n\n    if ( foundry.utils.getType(source.uses?.recovery) !== \"string\" ) return;\n\n    // If period is charges, set the recovery type to `formula`\n    if ( source.uses?.per === \"charges\" ) {\n      if ( source.uses.recovery ) {\n        source.uses.recovery = [{ period: \"lr\", type: \"formula\", formula: source.uses.recovery }];\n      } else {\n        delete source.uses.recovery;\n      }\n    }\n\n    // If period is not blank, set an appropriate recovery type\n    else if ( source.uses?.per ) {\n      if ( CONFIG.DND5E.limitedUsePeriods[source.uses.per]?.formula && source.uses.recovery ) {\n        source.uses.recovery = [{ period: source.uses.per, type: \"formula\", formula: source.uses.recovery }];\n      }\n      else source.uses.recovery = [{ period: source.uses.per, type: \"recoverAll\" }];\n    }\n\n    // Otherwise, check to see if recharge is set\n    else if ( source.recharge?.value ) {\n      source.uses.recovery = [{ period: \"recharge\", formula: source.recharge.value }];\n    }\n\n    // Prevent a string value for uses recovery from being cleaned into a default recovery entry\n    else if ( source.uses?.recovery === \"\" ) {\n      delete source.uses.recovery;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nModify data before initialization to create initial activity if necessary.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static initializeActivities(source) {\n    if ( this.#shouldCreateInitialActivity(source) ) this.#createInitialActivity(source);\n    const uses = source.system?.uses ?? {};\n    if ( source._id && source.type && (\"value\" in uses) && uses.max ) {\n      foundry.utils.setProperty(source, \"flags.dnd5e.migratedUses\", uses.value);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMethod to determine whether the activity creation migration should be performed. This migration should only be\nperformed on whole item data rather than partial updates, so check to ensure all of the necessary data is present.\n@param {object} source  The candidate source data from which the model will be constructed.\n@returns {boolean}\n/\n  static #shouldCreateInitialActivity(source) {\n    // Do not attempt to migrate partial source data.\n    if ( !source._id || !source.type || !source.system || !source.effects ) return false;\n\n    // If item doesn't have an action type or activation, then it doesn't need an activity\n    if ( !source.system.actionType && !source.system.activation?.type\n      && (source.type !== \"tool\") ) return false;\n\n    // If item was updated after `4.0.1`, it shouldn't need the migration\n    if ( !foundry.utils.isNewerVersion(\"4.0.1\", source._stats?.systemVersion ?? \"0.0.0\") ) return false;\n\n    // If the initial activity has already been created, no reason to create it again\n    if ( !foundry.utils.isEmpty(source.system.activities) ) return false;\n\n    return true;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate data from ActionTemplate and ActivatedEffectTemplate into a newly created activity.\n@param {object} source  The candidate source data from which the model will be constructed.",
      "cls": "",
      "labels": "Data model template for items with activities.\n@property {ActivityCollection} activities  Activities on this item.\n@property {UsesData} uses                  Item's limited uses & recovery.\n@mixin\n/\nexport default class ActivitiesTemplate extends SystemDataModel {\n\n  /** @override */\n  static LOCALIZATION_PREFIXES = [\"DND5E.USES\"];\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static defineSchema() {\n    return {\n      activities: new ActivitiesField(),\n      uses: new UsesField()\n    };\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nWhich ability score modifier is used by this item?\n@type {string|null}\n/\n  get abilityMod() {\n    return this._typeAbilityMod || null;\n  }\n\n  /**\nDefault ability key defined for this type.\n@type {string|null}\n@internal\n/\n  get _typeAbilityMod() {\n    return null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEnchantments that have been applied by this item.\n@type {ActiveEffect5e[]}\n/\n  get appliedEnchantments() {\n    return dnd5e.registry.enchantments.applied(this.parent.uuid);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nValue on a d20 die needed to roll a critical hit with an attack from this item.\n@type {number|null}\n/\n  get criticalThreshold() {\n    return this._typeCriticalThreshold ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item implement an attack roll as part of its usage?\n@type {boolean}\n/\n  get hasAttack() {\n    return !!this.activities.getByType(\"attack\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this Item limited in its ability to be used by charges or by recharge?\n@type {boolean}\n/\n  get hasLimitedUses() {\n    return !!this._source.uses.max || !!this.uses.max;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item implement a saving throw as part of its usage?\n@type {boolean}\n/\n  get hasSave() {\n    return !!this.activities.getByType(\"save\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes this Item implement summoning as part of its usage?\n@type {boolean}\n/\n  get hasSummoning() {\n    const activity = this.activities.getByType(\"summon\")[0];\n    return activity && activity.profiles.length > 0;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this Item an activatable item?\n@type {boolean}\n/\n  get isActive() {\n    return this.activities.size > 0;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCan this item enchant other items?\n@type {boolean}\n/\n  get isEnchantment() {\n    return !!this.activities.getByType(\"enchant\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item provide an amount of healing instead of conventional damage?\n@type {boolean}\n/\n  get isHealing() {\n    return !!this.activities.getByType(\"heal\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreatures summoned by this item.\n@type {Actor5e[]}\n/\n  get summonedCreatures() {\n    if ( !this.actor ) return [];\n    return this.activities.getByType(\"summon\").map(a => a.summonedCreatures).flat();\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Migrations                             */\n  /* -------------------------------------------- */\n\n  /**\nMigrate the uses data structure from before activities.\n@param {object} source  Candidate source data to migrate.\n/\n  static migrateActivities(source) {\n    ActivitiesTemplate.#migrateUses(source);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate the uses to the new data structure.\n@param {object} source  Candidate source data to migrate.\n/\n  static #migrateUses(source) {\n    // Remove any old ternary operators from uses to prevent errors\n    if ( source.uses?.max?.includes?.(\" ? \") ) source.uses.max = \"\";\n    for ( const activity of Object.values(source.activities ?? {}) ) {\n      if ( activity?.uses?.max?.includes?.(\" ? \") ) activity.uses.max = \"\";\n    }\n\n    if ( Array.isArray(source.uses?.recovery) ) return;\n\n    const charged = source.recharge?.charged;\n    if ( (source.recharge?.value !== null) && (charged !== undefined) && !source.uses?.max ) {\n      source.uses ??= {};\n      source.uses.spent = charged ? 0 : 1;\n      source.uses.max = \"1\";\n    }\n\n    if ( foundry.utils.getType(source.uses?.recovery) !== \"string\" ) return;\n\n    // If period is charges, set the recovery type to `formula`\n    if ( source.uses?.per === \"charges\" ) {\n      if ( source.uses.recovery ) {\n        source.uses.recovery = [{ period: \"lr\", type: \"formula\", formula: source.uses.recovery }];\n      } else {\n        delete source.uses.recovery;\n      }\n    }\n\n    // If period is not blank, set an appropriate recovery type\n    else if ( source.uses?.per ) {\n      if ( CONFIG.DND5E.limitedUsePeriods[source.uses.per]?.formula && source.uses.recovery ) {\n        source.uses.recovery = [{ period: source.uses.per, type: \"formula\", formula: source.uses.recovery }];\n      }\n      else source.uses.recovery = [{ period: source.uses.per, type: \"recoverAll\" }];\n    }\n\n    // Otherwise, check to see if recharge is set\n    else if ( source.recharge?.value ) {\n      source.uses.recovery = [{ period: \"recharge\", formula: source.recharge.value }];\n    }\n\n    // Prevent a string value for uses recovery from being cleaned into a default recovery entry\n    else if ( source.uses?.recovery === \"\" ) {\n      delete source.uses.recovery;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nModify data before initialization to create initial activity if necessary.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static initializeActivities(source) {\n    if ( this.#shouldCreateInitialActivity(source) ) this.#createInitialActivity(source);\n    const uses = source.system?.uses ?? {};\n    if ( source._id && source.type && (\"value\" in uses) && uses.max ) {\n      foundry.utils.setProperty(source, \"flags.dnd5e.migratedUses\", uses.value);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMethod to determine whether the activity creation migration should be performed. This migration should only be\nperformed on whole item data rather than partial updates, so check to ensure all of the necessary data is present.\n@param {object} source  The candidate source data from which the model will be constructed.\n@returns {boolean}\n/\n  static #shouldCreateInitialActivity(source) {\n    // Do not attempt to migrate partial source data.\n    if ( !source._id || !source.type || !source.system || !source.effects ) return false;\n\n    // If item doesn't have an action type or activation, then it doesn't need an activity\n    if ( !source.system.actionType && !source.system.activation?.type\n      && (source.type !== \"tool\") ) return false;\n\n    // If item was updated after `4.0.1`, it shouldn't need the migration\n    if ( !foundry.utils.isNewerVersion(\"4.0.1\", source._stats?.systemVersion ?? \"0.0.0\") ) return false;\n\n    // If the initial activity has already been created, no reason to create it again\n    if ( !foundry.utils.isEmpty(source.system.activities) ) return false;\n\n    return true;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate data from ActionTemplate and ActivatedEffectTemplate into a newly created activity.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #createInitialActivity(source) {\n    let type = {\n      mwak: \"attack\",\n      rwak: \"attack\",\n      msak: \"attack\",\n      rsak: \"attack\",\n      abil: \"check\",\n      save: \"save\",\n      ench: \"enchant\",\n      summ: \"summon\",\n      heal: \"heal\"\n    }[source.system.actionType] ?? \"utility\";\n    if ( (type === \"utility\") && source.system.damage?.parts?.length ) type = \"damage\";\n    if ( source.type === \"tool\" ) type = \"check\";\n\n    const cls = CONFIG.DND5E.activityTypes[type].documentClass;\n    cls.createInitialActivity(source);\n\n    if ( (type !== \"save\") && source.system.save?.ability ) {\n      CONFIG.DND5E.activityTypes.save.documentClass.createInitialActivity(source, { offset: 1 });\n    }\n    if ( (source.type !== \"weapon\") && source.system.damage?.versatile ) {\n      CONFIG.DND5E.activityTypes.damage.documentClass.createInitialActivity(source, { offset: 2, versatile: true });\n    }\n    if ( (type !== \"utility\") && source.system.formula ) {\n      CONFIG.DND5E.activityTypes.utility.documentClass.createInitialActivity(source, { offset: 3 });\n    }\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /**\nPrepare final data for the activities & uses.\n@param {object} rollData",
      "updates": "Data model template for items with activities.\n@property {ActivityCollection} activities  Activities on this item.\n@property {UsesData} uses                  Item's limited uses & recovery.\n@mixin\n/\nexport default class ActivitiesTemplate extends SystemDataModel {\n\n  /** @override */\n  static LOCALIZATION_PREFIXES = [\"DND5E.USES\"];\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static defineSchema() {\n    return {\n      activities: new ActivitiesField(),\n      uses: new UsesField()\n    };\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nWhich ability score modifier is used by this item?\n@type {string|null}\n/\n  get abilityMod() {\n    return this._typeAbilityMod || null;\n  }\n\n  /**\nDefault ability key defined for this type.\n@type {string|null}\n@internal\n/\n  get _typeAbilityMod() {\n    return null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nEnchantments that have been applied by this item.\n@type {ActiveEffect5e[]}\n/\n  get appliedEnchantments() {\n    return dnd5e.registry.enchantments.applied(this.parent.uuid);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nValue on a d20 die needed to roll a critical hit with an attack from this item.\n@type {number|null}\n/\n  get criticalThreshold() {\n    return this._typeCriticalThreshold ?? null;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item implement an attack roll as part of its usage?\n@type {boolean}\n/\n  get hasAttack() {\n    return !!this.activities.getByType(\"attack\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this Item limited in its ability to be used by charges or by recharge?\n@type {boolean}\n/\n  get hasLimitedUses() {\n    return !!this._source.uses.max || !!this.uses.max;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item implement a saving throw as part of its usage?\n@type {boolean}\n/\n  get hasSave() {\n    return !!this.activities.getByType(\"save\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes this Item implement summoning as part of its usage?\n@type {boolean}\n/\n  get hasSummoning() {\n    const activity = this.activities.getByType(\"summon\")[0];\n    return activity && activity.profiles.length > 0;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this Item an activatable item?\n@type {boolean}\n/\n  get isActive() {\n    return this.activities.size > 0;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCan this item enchant other items?\n@type {boolean}\n/\n  get isEnchantment() {\n    return !!this.activities.getByType(\"enchant\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDoes the Item provide an amount of healing instead of conventional damage?\n@type {boolean}\n/\n  get isHealing() {\n    return !!this.activities.getByType(\"heal\").length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreatures summoned by this item.\n@type {Actor5e[]}\n/\n  get summonedCreatures() {\n    if ( !this.actor ) return [];\n    return this.activities.getByType(\"summon\").map(a => a.summonedCreatures).flat();\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Migrations                             */\n  /* -------------------------------------------- */\n\n  /**\nMigrate the uses data structure from before activities.\n@param {object} source  Candidate source data to migrate.\n/\n  static migrateActivities(source) {\n    ActivitiesTemplate.#migrateUses(source);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate the uses to the new data structure.\n@param {object} source  Candidate source data to migrate.\n/\n  static #migrateUses(source) {\n    // Remove any old ternary operators from uses to prevent errors\n    if ( source.uses?.max?.includes?.(\" ? \") ) source.uses.max = \"\";\n    for ( const activity of Object.values(source.activities ?? {}) ) {\n      if ( activity?.uses?.max?.includes?.(\" ? \") ) activity.uses.max = \"\";\n    }\n\n    if ( Array.isArray(source.uses?.recovery) ) return;\n\n    const charged = source.recharge?.charged;\n    if ( (source.recharge?.value !== null) && (charged !== undefined) && !source.uses?.max ) {\n      source.uses ??= {};\n      source.uses.spent = charged ? 0 : 1;\n      source.uses.max = \"1\";\n    }\n\n    if ( foundry.utils.getType(source.uses?.recovery) !== \"string\" ) return;\n\n    // If period is charges, set the recovery type to `formula`\n    if ( source.uses?.per === \"charges\" ) {\n      if ( source.uses.recovery ) {\n        source.uses.recovery = [{ period: \"lr\", type: \"formula\", formula: source.uses.recovery }];\n      } else {\n        delete source.uses.recovery;\n      }\n    }\n\n    // If period is not blank, set an appropriate recovery type\n    else if ( source.uses?.per ) {\n      if ( CONFIG.DND5E.limitedUsePeriods[source.uses.per]?.formula && source.uses.recovery ) {\n        source.uses.recovery = [{ period: source.uses.per, type: \"formula\", formula: source.uses.recovery }];\n      }\n      else source.uses.recovery = [{ period: source.uses.per, type: \"recoverAll\" }];\n    }\n\n    // Otherwise, check to see if recharge is set\n    else if ( source.recharge?.value ) {\n      source.uses.recovery = [{ period: \"recharge\", formula: source.recharge.value }];\n    }\n\n    // Prevent a string value for uses recovery from being cleaned into a default recovery entry\n    else if ( source.uses?.recovery === \"\" ) {\n      delete source.uses.recovery;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nModify data before initialization to create initial activity if necessary.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static initializeActivities(source) {\n    if ( this.#shouldCreateInitialActivity(source) ) this.#createInitialActivity(source);\n    const uses = source.system?.uses ?? {};\n    if ( source._id && source.type && (\"value\" in uses) && uses.max ) {\n      foundry.utils.setProperty(source, \"flags.dnd5e.migratedUses\", uses.value);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMethod to determine whether the activity creation migration should be performed. This migration should only be\nperformed on whole item data rather than partial updates, so check to ensure all of the necessary data is present.\n@param {object} source  The candidate source data from which the model will be constructed.\n@returns {boolean}\n/\n  static #shouldCreateInitialActivity(source) {\n    // Do not attempt to migrate partial source data.\n    if ( !source._id || !source.type || !source.system || !source.effects ) return false;\n\n    // If item doesn't have an action type or activation, then it doesn't need an activity\n    if ( !source.system.actionType && !source.system.activation?.type\n      && (source.type !== \"tool\") ) return false;\n\n    // If item was updated after `4.0.1`, it shouldn't need the migration\n    if ( !foundry.utils.isNewerVersion(\"4.0.1\", source._stats?.systemVersion ?? \"0.0.0\") ) return false;\n\n    // If the initial activity has already been created, no reason to create it again\n    if ( !foundry.utils.isEmpty(source.system.activities) ) return false;\n\n    return true;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nMigrate data from ActionTemplate and ActivatedEffectTemplate into a newly created activity.\n@param {object} source  The candidate source data from which the model will be constructed.\n/\n  static #createInitialActivity(source) {\n    let type = {\n      mwak: \"attack\",\n      rwak: \"attack\",\n      msak: \"attack\",\n      rsak: \"attack\",\n      abil: \"check\",\n      save: \"save\",\n      ench: \"enchant\",\n      summ: \"summon\",\n      heal: \"heal\"\n    }[source.system.actionType] ?? \"utility\";\n    if ( (type === \"utility\") && source.system.damage?.parts?.length ) type = \"damage\";\n    if ( source.type === \"tool\" ) type = \"check\";\n\n    const cls = CONFIG.DND5E.activityTypes[type].documentClass;\n    cls.createInitialActivity(source);\n\n    if ( (type !== \"save\") && source.system.save?.ability ) {\n      CONFIG.DND5E.activityTypes.save.documentClass.createInitialActivity(source, { offset: 1 });\n    }\n    if ( (source.type !== \"weapon\") && source.system.damage?.versatile ) {\n      CONFIG.DND5E.activityTypes.damage.documentClass.createInitialActivity(source, { offset: 2, versatile: true });\n    }\n    if ( (type !== \"utility\") && source.system.formula ) {\n      CONFIG.DND5E.activityTypes.utility.documentClass.createInitialActivity(source, { offset: 3 });\n    }\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /**\nPrepare final data for the activities & uses.\n@param {object} rollData\n/\n  prepareFinalActivityData(rollData) {\n    const labels = this.parent.labels;\n    UsesField.prepareData.call(this, rollData, labels);\n    for ( const activity of this.activities ) activity.prepareFinalData();\n  }\n\n  /* -------------------------------------------- */\n  /*  Helpers                                     */\n  /* -------------------------------------------- */\n\n  /**\nRetrieve information on available uses for display.\n@returns {{value: number, max: number, name: string}}\n/\n  getUsesData() {\n    return { value: this.uses.value, max: this.uses.max, name: \"system.uses.value\" };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPerform any item & activity uses recovery.\n@param {string[]} periods  Recovery periods to check.\n@param {object} rollData   Roll data to use when evaluating recover formulas.\n@returns {Promise<{ updates: object, rolls: BasicRoll[] }>}",
      "rolls": "",
      "autoRecharge": "",
      "shouldRecharge": "",
      "recharge": "",
      "message": "",
      "result": "",
      "spells": "",
      "cloneChanges": "",
      "riders": "",
      "effect": "",
      "removed": "",
      "_": "",
      "cachedInserts": "",
      "existingSpell": "",
      "enchantment": "",
      "cached": "",
      "spellIds": "",
      "shim": "",
      "addShims": "",
      "firstActivity": "",
      "d": "",
      "activation": "",
      "consumption": "",
      "target": "",
      "consume": ""
    },
    "EquippableItemTemplate": {
      "value": "",
      "filter": "",
      "attuned": "",
      "attunement": "",
      "equipped": "",
      "type": ""
    },
    "IdentifiableTemplate": {
      "description": "",
      "name": "",
      "fetchName": "",
      "fetchDesc": "",
      "baseItem": ""
    },
    "ItemDescriptionTemplate": {
      "source": "",
      "uuid": ""
    },
    "ItemTypeTemplate": {
      "oldType": ""
    },
    "MountableTemplate": {},
    "PhysicalItemTemplate": {
      "static MAX_DEPTH": "",
      "hasPrice": "",
      "multiplier": "",
      "valueInGP": "",
      "price": "",
      "rarity": "",
      "weight": "",
      "options": "",
      "c": "",
      "a": "",
      "former": "",
      "formerContainer": "",
      "item": "",
      "depth": "",
      "containers": "",
      "container": "",
      "w": ""
    },
    "StartingEquipmentTemplate": {
      "topLevel": "",
      "e": ""
    },
    "ActivationField": {
      "fields": "",
      "scalar": "",
      "value": "",
      "activation": ""
    },
    "CurrencyTemplate": {
      "count": "",
      "currencyPerWeight": ""
    },
    "DamageField": {},
    "DurationField": {
      "fields": "",
      "scalar": "",
      "value": "",
      "duration": "",
      "concentrationDuration": ""
    },
    "RangeField": {
      "fields": "",
      "scalar": "",
      "value": "",
      "range": "",
      "rangeParts": ""
    },
    "SourceField": {
      "fields": "",
      "pkg": "@typedef {object} SourceData\n@property {string} book      Book/publication where the item originated.\n@property {string} page      Page or section where the item can be found.\n@property {string} custom    Fully custom source label.\n@property {string} license   Type of license that covers this item.\n@property {number} revision  Revision count for this item.\n@property {string} rules     Version of the rules for this document (e.g. 2014 vs. 2024).\n/\n\n/**\nData fields that stores information on the adventure or sourcebook where this document originated.\n/\nexport default class SourceField extends SchemaField {\n  constructor(fields={}, options={}) {\n    fields = {\n      book: new StringField(),\n      page: new StringField(),\n      custom: new StringField(),\n      license: new StringField(),\n      revision: new NumberField({ initial: 1 }),\n      rules: new StringField({ initial: \"2024\" }),\n      ...fields\n    };\n    Object.entries(fields).forEach(([k, v]) => !v ? delete fields[k] : null);\n    super(fields, { label: \"DND5E.SOURCE.FIELDS.source.label\", ...options });\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /**\nPrepare the source label.\n@this {SourceData}\n@param {string} uuid  Compendium source or document UUID.",
      "bookPlaceholder": "",
      "book": "",
      "label": "",
      "page": "",
      "value": "",
      "slug": "",
      "sourceBooks": "",
      "keys": "",
      "pack": "",
      "source": ""
    },
    "TargetField": {
      "fields": "",
      "scalar": "",
      "count": "",
      "dimensions": "",
      "size": "",
      "width": "",
      "height": "",
      "pr": "",
      "templateConfig": "",
      "parts": "",
      "label": "",
      "affectsConfig": "",
      "labels": "",
      "target": "",
      "sizes": ""
    },
    "UsesField": {
      "fields": "",
      "value": "",
      "periods": "",
      "period": "",
      "type": "",
      "recharge": "",
      "config": "",
      "recovery": "",
      "label": "",
      "min": "",
      "max": "",
      "updates": "",
      "rolls": "",
      "item": "",
      "delta": "",
      "roll": "",
      "total": "",
      "newSpent": "",
      "spent": "",
      "oldReturn": "",
      "apply": "",
      "rollConfig": "",
      "hookNames": "",
      "subject": "",
      "dialogConfig": "",
      "messageConfig": "",
      "hookData": "",
      "data": "",
      "target": "",
      "create": "",
      "flavor": ""
    },
    "BasicRoll": {
      "static DefaultConfigurationDialog": "",
      "formula": "",
      "data": "Configuration data for the process of creating one or more basic rolls.\n@typedef {object} BasicRollProcessConfiguration\n@property {BasicRollConfiguration[]} rolls  Configuration data for individual rolls.\n@property {boolean} [evaluate=true]         Should the rolls be evaluated? If set to `false`, then no chat message\n                                            will be created regardless of message configuration.\n@property {Event} [event]                   Event that triggered the rolls.\n@property {string[]} [hookNames]            Name suffixes for configuration hooks called.\n@property {Document} [subject]              Document that initiated this roll.\n@property {number} [target]                 Default target value for all rolls.\n/\n\n/**\nConfiguration data for an individual roll.\n@typedef {object} BasicRollConfiguration\n@property {string[]} [parts=[]]         Parts used to construct the roll formula.\n@property {object} [data={}]            Data used to resolve placeholders in the formula.\n@property {boolean} [situational=true]  Whether the situational bonus can be added to this roll in the prompt.\n@property {BasicRollOptions} [options]  Additional options passed through to the created roll.\n/\n\n/**\nOptions allowed on a basic roll.\n@typedef {object} BasicRollOptions\n@property {number} [target]  The total roll result that must be met for the roll to be considered a success.\n/\n\n/* -------------------------------------------- */\n\n/**\nConfiguration data for the roll prompt.\n@typedef {object} BasicRollDialogConfiguration\n@property {boolean} [configure=true]  Display a configuration dialog for the rolling process.\n@property {typeof RollConfigurationDialog} [applicationClass]  Alternate configuration application to use.\n@property {BasicRollConfigurationDialogOptions} [options]      Additional options passed to the dialog.\n/\n\n/* -------------------------------------------- */\n\n/**\nConfiguration data for creating a roll message.\n@typedef {object} BasicRollMessageConfiguration\n@property {boolean} [create=true]     Create a message when the rolling is complete.\n@property {ChatMessage5e} [document]  Final created chat message document once process is completed.\n@property {string} [rollMode]         The roll mode to apply to this message from `CONFIG.Dice.rollModes`.\n@property {object} [data={}]          Additional data used when creating the message.\n/\n\n/* -------------------------------------------- */\n\n/**\nCustom base roll type with methods for building rolls, presenting prompts, and creating messages.\n/\nexport default class BasicRoll extends Roll {\n\n  /**\nDefault application used for the roll configuration prompt.\n@type {typeof RollConfigurationDialog}\n/\n  static DefaultConfigurationDialog = RollConfigurationDialog;\n\n  /* -------------------------------------------- */\n  /*  Static Construction                         */\n  /* -------------------------------------------- */\n\n  /**\nCreate a roll instance from a roll config.\n@param {BasicRollConfiguration} config          Configuration info for the roll.\n@param {BasicRollProcessConfiguration} process  Configuration info for the whole rolling process.\n@returns {BasicRoll}\n/\n  static fromConfig(config, process) {\n    const formula = (config.parts ?? []).join(\" + \");\n    config.options ??= {};\n    config.options.target ??= process.target;\n    return new this(formula, config.data, config.options);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct roll parts and populate its data object.\n@param {object} parts   Information on the parts to be constructed.\n@param {object} [data]  Roll data to use and populate while constructing the parts.\n@returns {{ parts: string[], data: object }}",
      "config": "",
      "configure": "",
      "DialogClass": "",
      "rolls": "",
      "rollType": "",
      "roll": "",
      "name": "",
      "messageId": "",
      "document": "",
      "create": "",
      "messageData": "",
      "cls": "",
      "msg": "",
      "options": "",
      "terms": "",
      "number": "",
      "preCalculateOptions": "",
      "currentModifiers": "",
      "keep": "",
      "drop": "",
      "validModifiers": "",
      "matchedModifier": "",
      "rgx": "",
      "match": "",
      "command": "",
      "amount": "",
      "n": "",
      "_number": "",
      "f": "",
      "_faces": "",
      "flavor": "",
      "other": "Configuration data for the process of creating one or more basic rolls.\n@typedef {object} BasicRollProcessConfiguration\n@property {BasicRollConfiguration[]} rolls  Configuration data for individual rolls.\n@property {boolean} [evaluate=true]         Should the rolls be evaluated? If set to `false`, then no chat message\n                                            will be created regardless of message configuration.\n@property {Event} [event]                   Event that triggered the rolls.\n@property {string[]} [hookNames]            Name suffixes for configuration hooks called.\n@property {Document} [subject]              Document that initiated this roll.\n@property {number} [target]                 Default target value for all rolls.\n/\n\n/**\nConfiguration data for an individual roll.\n@typedef {object} BasicRollConfiguration\n@property {string[]} [parts=[]]         Parts used to construct the roll formula.\n@property {object} [data={}]            Data used to resolve placeholders in the formula.\n@property {boolean} [situational=true]  Whether the situational bonus can be added to this roll in the prompt.\n@property {BasicRollOptions} [options]  Additional options passed through to the created roll.\n/\n\n/**\nOptions allowed on a basic roll.\n@typedef {object} BasicRollOptions\n@property {number} [target]  The total roll result that must be met for the roll to be considered a success.\n/\n\n/* -------------------------------------------- */\n\n/**\nConfiguration data for the roll prompt.\n@typedef {object} BasicRollDialogConfiguration\n@property {boolean} [configure=true]  Display a configuration dialog for the rolling process.\n@property {typeof RollConfigurationDialog} [applicationClass]  Alternate configuration application to use.\n@property {BasicRollConfigurationDialogOptions} [options]      Additional options passed to the dialog.\n/\n\n/* -------------------------------------------- */\n\n/**\nConfiguration data for creating a roll message.\n@typedef {object} BasicRollMessageConfiguration\n@property {boolean} [create=true]     Create a message when the rolling is complete.\n@property {ChatMessage5e} [document]  Final created chat message document once process is completed.\n@property {string} [rollMode]         The roll mode to apply to this message from `CONFIG.Dice.rollModes`.\n@property {object} [data={}]          Additional data used when creating the message.\n/\n\n/* -------------------------------------------- */\n\n/**\nCustom base roll type with methods for building rolls, presenting prompts, and creating messages.\n/\nexport default class BasicRoll extends Roll {\n\n  /**\nDefault application used for the roll configuration prompt.\n@type {typeof RollConfigurationDialog}\n/\n  static DefaultConfigurationDialog = RollConfigurationDialog;\n\n  /* -------------------------------------------- */\n  /*  Static Construction                         */\n  /* -------------------------------------------- */\n\n  /**\nCreate a roll instance from a roll config.\n@param {BasicRollConfiguration} config          Configuration info for the roll.\n@param {BasicRollProcessConfiguration} process  Configuration info for the whole rolling process.\n@returns {BasicRoll}\n/\n  static fromConfig(config, process) {\n    const formula = (config.parts ?? []).join(\" + \");\n    config.options ??= {};\n    config.options.target ??= process.target;\n    return new this(formula, config.data, config.options);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct roll parts and populate its data object.\n@param {object} parts   Information on the parts to be constructed.\n@param {object} [data]  Roll data to use and populate while constructing the parts.\n@returns {{ parts: string[], data: object }}\n/\n  static constructParts(parts, data={}) {\n    const finalParts = [];\n    for ( const [key, value] of Object.entries(parts) ) {\n      if ( !value && (value !== 0) ) continue;\n      finalParts.push(`@${key}`);\n      foundry.utils.setProperty(\n        data, key, foundry.utils.getType(value) === \"string\" ? Roll.replaceFormulaData(value, data) : value\n      );\n    }\n    return { parts: finalParts, data };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nConstruct and perform a roll through the standard workflow.\n@param {BasicRollProcessConfiguration} [config={}]   Configuration for the rolls.\n@param {BasicRollDialogConfiguration} [dialog={}]    Configuration for roll prompt.\n@param {BasicRollMessageConfiguration} [message={}]  Configuration for message creation.\n@returns {BasicRoll[]}\n/\n  static async build(config={}, dialog={}, message={}) {\n    const rolls = await this.buildConfigure(config, dialog, message);\n    await this.buildEvaluate(rolls, config, message);\n    await this.buildPost(rolls, config, message);\n    return rolls;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStage one of the standard rolling workflow, configuring the roll.\n@param {BasicRollProcessConfiguration} [config={}]   Configuration for the rolls.\n@param {BasicRollDialogConfiguration} [dialog={}]    Configuration for roll prompt.\n@param {BasicRollMessageConfiguration} [message={}]  Configuration for message creation.\n@returns {Promise<BasicRoll[]>}\n/\n  static async buildConfigure(config={}, dialog={}, message={}) {\n    config.hookNames = [...(config.hookNames ?? []), \"\"];\n\n    /**\nA hook event that fires before a roll is performed. Multiple hooks may be called depending on the rolling\nmethod (e.g. `dnd5e.preRollSkillV2`, `dnd5e.preRollAbilityCheckV2`, `dnd5e.preRollV2`). Exact contents of the\nconfiguration object will also change based on the roll type, but the same objects will always be present.\n@function dnd5e.preRollV2\n@memberof hookEvents\n@param {BasicRollProcessConfiguration} config   Configuration data for the pending roll.\n@param {BasicRollDialogConfiguration} dialog    Presentation data for the roll configuration dialog.\n@param {BasicRollMessageConfiguration} message  Configuration data for the roll's message.\n@returns {boolean}                              Explicitly return `false` to prevent the roll.\n/\n    for ( const hookName of config.hookNames ) {\n      if ( Hooks.call(`dnd5e.preRoll${hookName.capitalize()}V2`, config, dialog, message) === false ) return [];\n    }\n\n    this.applyKeybindings(config, dialog, message);\n\n    let rolls;\n    if ( dialog.configure === false ) {\n      rolls = config.rolls?.map((r, index) => {\n        dialog.options?.buildConfig?.(config, r, null, index);\n        return this.fromConfig(r, config);\n      }) ?? [];\n    } else {\n      const DialogClass = dialog.applicationClass ?? this.DefaultConfigurationDialog;\n      rolls = await DialogClass.configure(config, dialog, message);\n    }\n\n    // Store the roll type in roll.options so it can be accessed from only the roll\n    const rollType = foundry.utils.getProperty(message, \"data.flags.dnd5e.roll.type\");\n    if ( rollType ) rolls.forEach(roll => roll.options.rollType ??= rollType);\n\n    /**\nA hook event that fires after roll configuration is complete, but before the roll is evaluated.\nMultiple hooks may be called depending on the rolling method (e.g. `dnd5e.postSkillCheckRollConfiguration`,\n`dnd5e.postAbilityTestRollConfiguration`, and `dnd5e.postRollConfiguration` for skill checks). Exact contents of\nthe configuration object will also change based on the roll type, but the same objects will always be present.\n@function dnd5e.postRollConfiguration\n@memberof hookEvents\n@param {BasicRoll[]} rolls                      Rolls that have been constructed but not evaluated.\n@param {BasicRollProcessConfiguration} config   Configuration information for the roll.\n@param {BasicRollDialogConfiguration} dialog    Configuration for the roll dialog.\n@param {BasicRollMessageConfiguration} message  Configuration for the roll message.\n@returns {boolean}                              Explicitly return `false` to prevent rolls.\n/\n    for ( const hookName of config.hookNames ) {\n      const name = `dnd5e.post${hookName.capitalize()}RollConfiguration`;\n      if ( Hooks.call(name, rolls, config, dialog, message) === false ) return [];\n    }\n\n    return rolls;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStage two of the standard rolling workflow, evaluating the rolls.\n@param {BasicRoll[]} rolls                           Rolls to evaluate.\n@param {BasicRollProcessConfiguration} [config={}]   Configuration for the rolls.\n@param {BasicRollMessageConfiguration} [message={}]  Configuration for message creation.\n/\n  static async buildEvaluate(rolls, config={}, message={}) {\n    if ( config.evaluate !== false ) {\n      for ( const roll of rolls ) await roll.evaluate();\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStage three of the standard rolling workflow, posting a message to chat.\n@param {BasicRoll[]} rolls                      Rolls to evaluate.\n@param {BasicRollProcessConfiguration} config   Configuration for the rolls.\n@param {BasicRollMessageConfiguration} message  Configuration for message creation.\n@returns {ChatMessage5e|void}\n/\n  static async buildPost(rolls, config, message) {\n    message.data = foundry.utils.expandObject(message.data ?? {});\n    const messageId = config.event?.target.closest(\"[data-message-id]\")?.dataset.messageId;\n    if ( messageId ) foundry.utils.setProperty(message.data, \"flags.dnd5e.originatingMessage\", messageId);\n\n    if ( rolls?.length && (config.evaluate !== false) && (message.create !== false) ) {\n      message.document = await this.toMessage(rolls, message.data, { rollMode: message.rollMode });\n    }\n\n    return message.document;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nDetermines whether the roll process should be fast forwarded.\n@param {BasicRollProcessConfiguration} config   Roll configuration data.\n@param {BasicRollDialogConfiguration} dialog    Data for the roll configuration dialog.\n@param {BasicRollMessageConfiguration} message  Message configuration data.\n/\n  static applyKeybindings(config, dialog, message) {\n    dialog.configure ??= true;\n  }\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nIs the result of this roll a failure? Returns `undefined` if roll isn't evaluated.\n@type {boolean|void}\n/\n  get isFailure() {\n    if ( !this._evaluated ) return;\n    if ( !Number.isNumeric(this.options.target) ) return false;\n    return this.total < this.options.target;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs the result of this roll a success? Returns `undefined` if roll isn't evaluated.\n@type {boolean|void}\n/\n  get isSuccess() {\n    if ( !this._evaluated ) return;\n    if ( !Number.isNumeric(this.options.target) ) return false;\n    return this.total >= this.options.target;\n  }\n\n  /* -------------------------------------------- */\n  /*  Chat Messages                               */\n  /* -------------------------------------------- */\n\n  /**\nTransform a Roll instance into a ChatMessage, displaying the roll result.\nThis function can either create the ChatMessage directly, or return the data object that will be used to create it.\n@param {BasicRoll[]} rolls              Rolls to add to the message.\n@param {object} messageData             The data object to use when creating the message.\n@param {options} [options]              Additional options which modify the created message.\n@param {string} [options.rollMode]      The template roll mode to use for the message from CONFIG.Dice.rollModes\n@param {boolean} [options.create=true]  Whether to automatically create the chat message, or only return the\n                                        prepared chatData object.\n@returns {Promise<ChatMessage|object>}  A promise which resolves to the created ChatMessage document if create is\n                                        true, or the Object of prepared chatData otherwise.\n/\n  static async toMessage(rolls, messageData={}, { rollMode, create=true }={}) {\n    for ( const roll of rolls ) {\n      if ( !roll._evaluated ) await roll.evaluate({ allowInteractive: rollMode !== CONST.DICE_ROLL_MODES.BLIND });\n      rollMode ??= roll.options.rollMode;\n    }\n\n    // Prepare chat data\n    messageData = foundry.utils.mergeObject({ sound: CONFIG.sounds.dice }, messageData);\n    messageData.rolls = rolls;\n    this._prepareMessageData(rolls, messageData);\n\n    // Process the chat data\n    const cls = getDocumentClass(\"ChatMessage\");\n    const msg = new cls(messageData);\n\n    // Either create or return the data\n    if ( create ) return cls.create(msg.toObject(), { rollMode });\n    else {\n      if ( rollMode ) msg.applyRollMode(rollMode);\n      return msg.toObject();\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPerform specific changes to message data before creating message.\n@param {BasicRoll[]} rolls   Rolls to add to the message.\n@param {object} messageData  The data object to use when creating the message.\n@protected\n/\n  static _prepareMessageData(rolls, messageData) {}\n\n  /* -------------------------------------------- */\n  /*  Evaluate Methods                            */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async evaluate(options={}) {\n    this.preCalculateDiceTerms(options);\n    return super.evaluate(options);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  evaluateSync(options={}) {\n    this.preCalculateDiceTerms(options);\n    return super.evaluateSync(options);\n  }\n\n  /* -------------------------------------------- */\n  /*  Roll Formula Parsing                        */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static replaceFormulaData(formula, data, options) {\n    // This looks for the pattern `$!!$` and replaces it with just the value between the marks (the bang has\n    // been added to ensure this is a deliberate shim from the system, not a unintentional usage that should\n    // show an error).\n    return super.replaceFormulaData(formula, data, options).replaceAll(/\\$\"?!(.+?)!\"?\\$/g, \"$1\");\n  }\n\n  /* -------------------------------------------- */\n  /*  Maximize/Minimize Methods                   */\n  /* -------------------------------------------- */\n\n  /**\nReplaces all dice terms that have modifiers with their maximum/minimum value.\n@param {object} [options={}]            Extra optional arguments which describe or modify the BasicRoll.\n/\n  preCalculateDiceTerms(options={}) {\n    if ( this._evaluated || (!options.maximize && !options.minimize) ) return;\n    this.terms = this.terms.map(term => {\n      if ( (term instanceof DiceTerm) && term.modifiers.length ) {\n        const minimize = !options.maximize;\n        const number = this.constructor.preCalculateTerm(term, { minimize });\n        if ( Number.isFinite(number) ) return new NumericTerm({ number, options: term.options });\n      }\n      return term;\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nGets information from passed die and calculates the maximum or minimum value that could be rolled.\n@param {DiceTerm} die                            DiceTerm to get the maximum/minimum value.\n@param {object} [preCalculateOptions={}]         Additional options to modify preCalculate functionality.\n@param {boolean} [preCalculateOptions.minimize=false]  Calculate the minimum value instead of the maximum.\n@returns {number|null}                                 Maximum/Minimum value that could be rolled as an integer, or\n                                                       null if the modifiers could not be precalculated.\n/\n  static preCalculateTerm(die, { minimize=false }={}) {\n    let face = minimize ? 1 : die.faces;\n    let number = die.number;\n    const currentModifiers = foundry.utils.deepClone(die.modifiers);\n    const keep = new Set([\"k\", \"kh\", \"kl\"]);\n    const drop = new Set([\"d\", \"dh\", \"dl\"]);\n    const validModifiers = new Set([...keep, ...drop, \"max\", \"min\"]);\n    let matchedModifier = false;\n\n    for ( const modifier of currentModifiers ) {\n      const rgx = /(m[ai][xn]|[kd][hl]?)(\\d+)?/i;\n      const match = modifier.match(rgx);\n      if ( !match ) continue;\n      if ( match[0].length < match.input.length ) currentModifiers.push(match.input.slice(match[0].length));\n      let [, command, value] = match;\n      command = command.toLowerCase();\n      if ( !validModifiers.has(command) ) continue;\n\n      matchedModifier = true;\n      const amount = parseInt(value) || (command === \"max\" || command === \"min\" ? -1 : 1);\n      if ( amount > 0 ) {\n        if ( (command === \"max\" && minimize) || (command === \"min\" && !minimize) ) continue;\n        else if ( (command === \"max\" || command === \"min\") ) face = Math.min(die.faces, amount);\n        else if ( keep.has(command) ) number = Math.min(number, amount);\n        else if ( drop.has(command) ) number = Math.max(1, number - amount);\n      }\n    }\n\n    return matchedModifier ? face * number : null;\n  }\n\n  /* -------------------------------------------- */\n  /*  Simplification Methods                      */\n  /* -------------------------------------------- */\n\n  /**\nReplace number and faces of dice terms with numeric values where possible.\n/\n  simplify() {\n    for ( const die of this.dice ) {\n      const n = die._number;\n      if ( (n instanceof BasicRoll) && n.isDeterministic ) die._number = n.evaluateSync().total;\n      const f = die._faces;\n      if ( (f instanceof BasicRoll) && f.isDeterministic ) die._faces = f.evaluateSync().total;\n\n      // Preserve flavor.\n      if ( f.terms?.[0]?.flavor ) die.options.flavor = f.terms[0].flavor;\n    }\n\n    this.resetFormula();\n  }\n\n  /* -------------------------------------------- */\n  /*  Helpers                                     */\n  /* -------------------------------------------- */\n\n  /**\nMerge two roll configurations.\n@param {Partial<BasicRollConfiguration>} original  The initial configuration that will be merged into.\n@param {Partial<BasicRollConfiguration>} other     The configuration to merge.\n@returns {Partial<BasicRollConfiguration>}         The original instance."
    },
    "D20Die": {
      "number": "",
      "static CRITICAL_SUCCESS_TOTAL": "",
      "static CRITICAL_FAILURE_TOTAL": "",
      "faces": "",
      "advantageMode": "",
      "m": "",
      "isAdvantage": "",
      "flag": "",
      "index": "",
      "mod": ""
    },
    "D20Roll": {
      "static ADV_MODE": "",
      "static DefaultConfigurationDialog": "",
      "formula": "",
      "newRoll": "",
      "keys": "",
      "k": "",
      "advantage": "",
      "disadvantage": "",
      "advantageMode": "",
      "rtLabel": "",
      "r": "",
      "minimum": "",
      "elvenAccuracy": "",
      "halflingLucky": "",
      "criticalSuccess": "",
      "criticalFailure": "",
      "target": "",
      "configured": "",
      "defaultAction": "",
      "DialogClass": "",
      "defaultButton": ""
    },
    "DamageRoll": {
      "static DefaultConfigurationDialog": "",
      "config": "",
      "critical": "",
      "keys": "",
      "k": "",
      "isCritical": "",
      "nextTerm": "",
      "prevTerm": "",
      "formula": "",
      "newTerm": "",
      "term": "",
      "newFormula": "",
      "deleteCount": "",
      "preprocessed": "",
      "options": "",
      "flatBonus": "",
      "baseNumber": "",
      "number": "",
      "cm": "",
      "bonus": "",
      "flavor": "",
      "cb": "",
      "extra": "",
      "configured": "",
      "allowCritical": "",
      "data": "",
      "DialogClass": "",
      "r": ""
    },
    "ActiveEffect5e": {
      "static ID": "",
      "static FORMULA_FIELDS": "",
      "static LOCALIZATION_PREFIXES": "",
      "type": "",
      "id": "",
      "isSuppressed": "",
      "description": "",
      "options": "",
      "change": "",
      "field": "",
      "changes": "Extend the base ActiveEffect class to implement system-specific logic.\n/\nexport default class ActiveEffect5e extends ActiveEffect {\n  /**\nStatic ActiveEffect ID for various conditions.\n@type {Record<string, string>}\n/\n  static ID = {\n    BLOODIED: staticID(\"dnd5ebloodied\"),\n    ENCUMBERED: staticID(\"dnd5eencumbered\"),\n    EXHAUSTION: staticID(\"dnd5eexhaustion\")\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nAdditional key paths to properties added during base data preparation that should be treated as formula fields.\n@type {Set<string>}\n/\n  static FORMULA_FIELDS = new Set([\n    \"system.attributes.ac.bonus\",\n    \"system.attributes.ac.min\",\n    \"system.attributes.encumbrance.bonuses.encumbered\",\n    \"system.attributes.encumbrance.bonuses.heavilyEncumbered\",\n    \"system.attributes.encumbrance.bonuses.maximum\",\n    \"system.attributes.encumbrance.bonuses.overall\",\n    \"system.attributes.encumbrance.multipliers.encumbered\",\n    \"system.attributes.encumbrance.multipliers.heavilyEncumbered\",\n    \"system.attributes.encumbrance.multipliers.maximum\",\n    \"system.attributes.encumbrance.multipliers.overall\",\n    \"save.dc.bonus\"\n  ]);\n\n  /* -------------------------------------------- */\n\n  /** @inheritdoc */\n  static LOCALIZATION_PREFIXES = [...super.LOCALIZATION_PREFIXES, \"DND5E.ACTIVEEFFECT\"];\n\n  /* -------------------------------------------- */\n\n  /**\nIs this effect an enchantment on an item that accepts enchantment?\n@type {boolean}\n/\n  get isAppliedEnchantment() {\n    return (this.type === \"enchantment\") && !!this.origin && (this.origin !== this.parent.uuid);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShould this status effect be hidden from the current user?\n@type {boolean}\n/\n  get isConcealed() {\n    if ( this.target?.testUserPermission(game.user, \"OBSERVER\") ) return false;\n\n    // Hide bloodied status effect from players unless the token is friendly\n    if ( (this.id === this.constructor.ID.BLOODIED) && (game.settings.get(\"dnd5e\", \"bloodied\") === \"player\") ) {\n      return this.target?.token?.disposition !== foundry.CONST.TOKEN_DISPOSITIONS.FRIENDLY;\n    }\n\n    return false;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this active effect currently suppressed?\n@type {boolean}\n/\n  isSuppressed = false;\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get isTemporary() {\n    return super.isTemporary && !this.isConcealed;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRetrieve the source Actor or Item, or null if it could not be determined.\n@returns {Promise<Actor5e|Item5e|null>}\n/\n  async getSource() {\n    if ( (this.target instanceof dnd5e.documents.Actor5e) && (this.parent instanceof dnd5e.documents.Item5e) ) {\n      return this.parent;\n    }\n    return fromUuid(this.origin);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static async _fromStatusEffect(statusId, { reference, ...effectData }, options) {\n    if ( !(\"description\" in effectData) && reference ) effectData.description = `@Embed[${reference} inline]`;\n    return super._fromStatusEffect?.(statusId, effectData, options) ?? new this(effectData, options);\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Migration                              */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _initializeSource(data, options={}) {\n    if ( data instanceof foundry.abstract.DataModel ) data = data.toObject();\n\n    if ( data.flags?.dnd5e?.type === \"enchantment\" ) {\n      data.type = \"enchantment\";\n      delete data.flags.dnd5e.type;\n    }\n\n    return super._initializeSource(data, options);\n  }\n\n  /* -------------------------------------------- */\n  /*  Effect Application                          */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  apply(doc, change) {\n    // Ensure changes targeting flags use the proper types\n    if ( change.key.startsWith(\"flags.dnd5e.\") ) change = this._prepareFlagChange(doc, change);\n\n    // Properly handle formulas that don't exist as part of the data model\n    if ( ActiveEffect5e.FORMULA_FIELDS.has(change.key) ) {\n      const field = new FormulaField({ deterministic: true });\n      return { [change.key]: this.constructor.applyField(doc, change, field) };\n    }\n\n    // Handle activity-targeted changes\n    if ( (change.key.startsWith(\"activities[\") || change.key.startsWith(\"system.activities.\"))\n      && (doc instanceof Item) ) return this.applyActivity(doc, change);\n\n    return super.apply(doc, change);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nApply a change to activities on this item.\n@param {Item5e} item              The Item to whom this change should be applied.\n@param {EffectChangeData} change  The change data being applied.\n@returns {Record<string, *>}      An object of property paths and their updated values.",
      "apply": "",
      "activity": "",
      "current": "",
      "modes": "",
      "mode": "",
      "mappingField": "",
      "keyPath": "",
      "created": "",
      "handle": "",
      "item": "",
      "data": "",
      "initialValue": "",
      "value": "",
      "config": "",
      "level": "",
      "img": "",
      "name": "",
      "s": "",
      "riders": "Extend the base ActiveEffect class to implement system-specific logic.\n/\nexport default class ActiveEffect5e extends ActiveEffect {\n  /**\nStatic ActiveEffect ID for various conditions.\n@type {Record<string, string>}\n/\n  static ID = {\n    BLOODIED: staticID(\"dnd5ebloodied\"),\n    ENCUMBERED: staticID(\"dnd5eencumbered\"),\n    EXHAUSTION: staticID(\"dnd5eexhaustion\")\n  };\n\n  /* -------------------------------------------- */\n\n  /**\nAdditional key paths to properties added during base data preparation that should be treated as formula fields.\n@type {Set<string>}\n/\n  static FORMULA_FIELDS = new Set([\n    \"system.attributes.ac.bonus\",\n    \"system.attributes.ac.min\",\n    \"system.attributes.encumbrance.bonuses.encumbered\",\n    \"system.attributes.encumbrance.bonuses.heavilyEncumbered\",\n    \"system.attributes.encumbrance.bonuses.maximum\",\n    \"system.attributes.encumbrance.bonuses.overall\",\n    \"system.attributes.encumbrance.multipliers.encumbered\",\n    \"system.attributes.encumbrance.multipliers.heavilyEncumbered\",\n    \"system.attributes.encumbrance.multipliers.maximum\",\n    \"system.attributes.encumbrance.multipliers.overall\",\n    \"save.dc.bonus\"\n  ]);\n\n  /* -------------------------------------------- */\n\n  /** @inheritdoc */\n  static LOCALIZATION_PREFIXES = [...super.LOCALIZATION_PREFIXES, \"DND5E.ACTIVEEFFECT\"];\n\n  /* -------------------------------------------- */\n\n  /**\nIs this effect an enchantment on an item that accepts enchantment?\n@type {boolean}\n/\n  get isAppliedEnchantment() {\n    return (this.type === \"enchantment\") && !!this.origin && (this.origin !== this.parent.uuid);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShould this status effect be hidden from the current user?\n@type {boolean}\n/\n  get isConcealed() {\n    if ( this.target?.testUserPermission(game.user, \"OBSERVER\") ) return false;\n\n    // Hide bloodied status effect from players unless the token is friendly\n    if ( (this.id === this.constructor.ID.BLOODIED) && (game.settings.get(\"dnd5e\", \"bloodied\") === \"player\") ) {\n      return this.target?.token?.disposition !== foundry.CONST.TOKEN_DISPOSITIONS.FRIENDLY;\n    }\n\n    return false;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nIs this active effect currently suppressed?\n@type {boolean}\n/\n  isSuppressed = false;\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get isTemporary() {\n    return super.isTemporary && !this.isConcealed;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nRetrieve the source Actor or Item, or null if it could not be determined.\n@returns {Promise<Actor5e|Item5e|null>}\n/\n  async getSource() {\n    if ( (this.target instanceof dnd5e.documents.Actor5e) && (this.parent instanceof dnd5e.documents.Item5e) ) {\n      return this.parent;\n    }\n    return fromUuid(this.origin);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static async _fromStatusEffect(statusId, { reference, ...effectData }, options) {\n    if ( !(\"description\" in effectData) && reference ) effectData.description = `@Embed[${reference} inline]`;\n    return super._fromStatusEffect?.(statusId, effectData, options) ?? new this(effectData, options);\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Migration                              */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _initializeSource(data, options={}) {\n    if ( data instanceof foundry.abstract.DataModel ) data = data.toObject();\n\n    if ( data.flags?.dnd5e?.type === \"enchantment\" ) {\n      data.type = \"enchantment\";\n      delete data.flags.dnd5e.type;\n    }\n\n    return super._initializeSource(data, options);\n  }\n\n  /* -------------------------------------------- */\n  /*  Effect Application                          */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  apply(doc, change) {\n    // Ensure changes targeting flags use the proper types\n    if ( change.key.startsWith(\"flags.dnd5e.\") ) change = this._prepareFlagChange(doc, change);\n\n    // Properly handle formulas that don't exist as part of the data model\n    if ( ActiveEffect5e.FORMULA_FIELDS.has(change.key) ) {\n      const field = new FormulaField({ deterministic: true });\n      return { [change.key]: this.constructor.applyField(doc, change, field) };\n    }\n\n    // Handle activity-targeted changes\n    if ( (change.key.startsWith(\"activities[\") || change.key.startsWith(\"system.activities.\"))\n      && (doc instanceof Item) ) return this.applyActivity(doc, change);\n\n    return super.apply(doc, change);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nApply a change to activities on this item.\n@param {Item5e} item              The Item to whom this change should be applied.\n@param {EffectChangeData} change  The change data being applied.\n@returns {Record<string, *>}      An object of property paths and their updated values.\n/\n  applyActivity(item, change) {\n    const changes = {};\n    const apply = (activity, key) => {\n      const c = this.apply(activity, { ...change, key });\n      Object.entries(c).forEach(([k, v]) => changes[`system.activities.${activity.id}.${k}`] = v);\n    };\n    if ( change.key.startsWith(\"system.activities.\") ) {\n      const [, , id, ...keyPath] = change.key.split(\".\");\n      const activity = item.system.activities?.get(id);\n      if ( activity ) apply(activity, keyPath.join(\".\"));\n    } else {\n      const { type, key } = change.key.match(/activities\\[(?<type>[^\\]]+)]\\.(?<key>.+)/)?.groups ?? {};\n      item.system.activities?.getByType(type)?.forEach(activity => apply(activity, key));\n    }\n    return changes;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static applyField(model, change, field) {\n    field ??= model.schema.getField(change.key);\n    change = foundry.utils.deepClone(change);\n    const current = foundry.utils.getProperty(model, change.key);\n    const modes = CONST.ACTIVE_EFFECT_MODES;\n\n    // Replace value when using string interpolation syntax\n    if ( (field instanceof StringField) && (change.mode === modes.OVERRIDE) && change.value.includes(\"{}\") ) {\n      change.value = change.value.replace(\"{}\", current ?? \"\");\n    }\n\n    // If current value is `null`, UPGRADE & DOWNGRADE should always just set the value\n    if ( (current === null) && [modes.UPGRADE, modes.DOWNGRADE].includes(change.mode) ) change.mode = modes.OVERRIDE;\n\n    // Handle removing entries from sets\n    if ( (field instanceof SetField) && (change.mode === modes.ADD) && (foundry.utils.getType(current) === \"Set\") ) {\n      for ( const value of field._castChangeDelta(change.value) ) {\n        const neg = value.replace(/^\\s*-\\s*/, \"\");\n        if ( neg !== value ) current.delete(neg);\n        else current.add(value);\n      }\n      return current;\n    }\n\n    // If attempting to apply active effect to empty MappingField entry, create it\n    if ( (current === undefined) && change.key.startsWith(\"system.\") ) {\n      let keyPath = change.key;\n      let mappingField = field;\n      while ( !(mappingField instanceof MappingField) && mappingField ) {\n        if ( mappingField.name ) keyPath = keyPath.substring(0, keyPath.length - mappingField.name.length - 1);\n        mappingField = mappingField.parent;\n      }\n      if ( mappingField && (foundry.utils.getProperty(model, keyPath) === undefined) ) {\n        const created = mappingField.model.initialize(mappingField.model.getInitialValue(), mappingField);\n        foundry.utils.setProperty(model, keyPath, created);\n      }\n    }\n\n    // Parse any JSON provided when targeting an object\n    if ( (field instanceof ObjectField) || (field instanceof SchemaField) ) {\n      change = { ...change, value: parseOrString(change.value) };\n    }\n\n    return super.applyField(model, change, field);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _applyAdd(actor, change, current, delta, changes) {\n    if ( current instanceof Set ) {\n      const handle = v => {\n        const neg = v.replace(/^\\s*-\\s*/, \"\");\n        if ( neg !== v ) current.delete(neg);\n        else current.add(v);\n      };\n      if ( Array.isArray(delta) ) delta.forEach(item => handle(item));\n      else handle(delta);\n      return;\n    }\n    super._applyAdd(actor, change, current, delta, changes);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  _applyLegacy(actor, change, changes) {\n    if ( this.system._applyLegacy?.(actor, change, changes) === false ) return;\n    super._applyLegacy(actor, change, changes);\n  }\n\n  /* --------------------------------------------- */\n\n  /** @inheritDoc */\n  _applyUpgrade(actor, change, current, delta, changes) {\n    if ( current === null ) return this._applyOverride(actor, change, current, delta, changes);\n    return super._applyUpgrade(actor, change, current, delta, changes);\n  }\n\n  /* --------------------------------------------- */\n\n  /**\nTransform the data type of the change to match the type expected for flags.\n@param {Actor5e} actor            The Actor to whom this effect should be applied.\n@param {EffectChangeData} change  The change being applied.\n@returns {EffectChangeData}       The change with altered types if necessary.\n/\n  _prepareFlagChange(actor, change) {\n    const { key, value } = change;\n    const data = CONFIG.DND5E.characterFlags[key.replace(\"flags.dnd5e.\", \"\")];\n    if ( !data ) return change;\n\n    // Set flag to initial value if it isn't present\n    const current = foundry.utils.getProperty(actor, key) ?? null;\n    if ( current === null ) {\n      let initialValue = null;\n      if ( data.placeholder ) initialValue = data.placeholder;\n      else if ( data.type === Boolean ) initialValue = false;\n      else if ( data.type === Number ) initialValue = 0;\n      foundry.utils.setProperty(actor, key, initialValue);\n    }\n\n    // Coerce change data into the correct type\n    if ( data.type === Boolean ) {\n      if ( value === \"false\" ) change.value = false;\n      else change.value = Boolean(value);\n    }\n    return change;\n  }\n\n  /* --------------------------------------------- */\n\n  /**\nDetermine whether this Active Effect is suppressed or not.\n/\n  determineSuppression() {\n    this.isSuppressed = false;\n    if ( this.type === \"enchantment\" ) return;\n    if ( this.parent instanceof dnd5e.documents.Item5e ) this.isSuppressed = this.parent.areEffectsSuppressed;\n  }\n\n  /* -------------------------------------------- */\n  /*  Lifecycle                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  prepareDerivedData() {\n    super.prepareDerivedData();\n    if ( this.id === this.constructor.ID.EXHAUSTION ) this._prepareExhaustionLevel();\n    if ( this.isAppliedEnchantment ) dnd5e.registry.enchantments.track(this.origin, this.uuid);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nModify the ActiveEffect's attributes based on the exhaustion level.\n@protected\n/\n  _prepareExhaustionLevel() {\n    const config = CONFIG.DND5E.conditionTypes.exhaustion;\n    let level = this.getFlag(\"dnd5e\", \"exhaustionLevel\");\n    if ( !Number.isFinite(level) ) level = 1;\n    this.img = this.constructor._getExhaustionImage(level);\n    this.name = `${game.i18n.localize(\"DND5E.Exhaustion\")} ${level}`;\n    if ( level >= config.levels ) {\n      this.statuses.add(\"dead\");\n      CONFIG.DND5E.statusEffects.dead.statuses?.forEach(s => this.statuses.add(s));\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPrepare effect favorite data.\n@returns {Promise<FavoriteData5e>}\n/\n  async getFavoriteData() {\n    return {\n      img: this.img,\n      title: this.name,\n      subtitle: this.duration.remaining ? this.duration.label : \"\",\n      toggle: !this.disabled,\n      suppressed: this.isSuppressed\n    };\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreate conditions that are applied separately from an effect.\n@returns {Promise<ActiveEffect5e[]>}      Created rider effects.",
      "r": "",
      "createRider": "",
      "effect": "",
      "effectData": "",
      "_": "",
      "message": "",
      "profile": "",
      "origin": "",
      "riderActivities": "",
      "riderEffects": "",
      "activityData": "",
      "_id": "",
      "createdActivities": "",
      "a": "",
      "createdEffects": "",
      "createdItems": "",
      "riderItems": "",
      "activityId": "",
      "keepOrigin": "",
      "errors": "",
      "err": "",
      "userId": "",
      "originalLevel": "",
      "newLevel": "",
      "originalEncumbrance": "",
      "newEncumbrance": "",
      "increase": "",
      "dependents": "",
      "user": "",
      "uuid": "",
      "statusEffect": "",
      "html": "",
      "element": "",
      "tab": "",
      "actor": "",
      "elem": "",
      "objectPosition": "",
      "background": "",
      "split": "",
      "ext": "",
      "path": "",
      "button": "",
      "max": "",
      "size": "",
      "choices": "",
      "content": "",
      "source": "",
      "d": "",
      "delta": "",
      "enrichmentOptions": "",
      "p": "",
      "dialogOptions": ""
    },
    "SourcedItemsMap": {
      "remap": ""
    },
    "Bastion": {
      "static ATTACK_TEMPLATE": "",
      "static TURN_TEMPLATE": "",
      "haveBastions": "",
      "duration": "",
      "order": "",
      "gold": "",
      "content": "",
      "value": "",
      "newProgress": "",
      "updates": "",
      "summary": "",
      "roll": "",
      "deaths": "",
      "defenders": "",
      "undefended": "",
      "event": "",
      "actor": "",
      "el": "",
      "item": "",
      "draggable": "",
      "sizes": "",
      "index": "",
      "operation": "",
      "sold": "",
      "allDefenders": "",
      "results": "",
      "gp": "",
      "claimed": "",
      "slain": "",
      "i": "",
      "a": "",
      "special": "",
      "damaged": "",
      "resolved": "",
      "context": "",
      "plurals": "",
      "key": "",
      "description": "",
      "buttons": "",
      "class": "",
      "facility": "",
      "items": "",
      "_": "",
      "orders": "",
      "supplements": "",
      "proceed": "",
      "turnButton": "",
      "v12": "",
      "type": "",
      "formula": ""
    },
    "BastionAttackDialog": {
      "actor": "",
      "static DEFAULT_OPTIONS": "",
      "static PARTS": "",
      "formula": "",
      "context": "",
      "options": "",
      "resolve": ""
    },
    "HitDice": {
      "actor": "",
      "value": "",
      "max": "",
      "sizes": "",
      "classes": "",
      "bySize": "",
      "hd": "",
      "cls": "",
      "fraction": "",
      "updateItems": "",
      "recovered": "",
      "used": "",
      "delta": ""
    },
    "Proficiency": {
      "roundDown": "",
      "multiplier": "",
      "rounding": "",
      "deterministic": "",
      "roundMethod": "",
      "_baseProficiency": "",
      "roundTerm": "",
      "updates": ""
    },
    "SelectChoices": {
      "choices": "",
      "category": "",
      "children": "",
      "newData": "Object representing a nested set of choices to be displayed in a grouped select list or a trait selector.\n@typedef {object} SelectChoicesEntry\n@property {string} label              Label, either pre- or post-localized.\n@property {boolean} [chosen]          Has this choice been selected?\n@property {boolean} [sorting=true]    Should this value be sorted? If there are a mixture of this value at\n                                      a level, unsorted values are listed first followed by sorted values.\n@property {SelectChoices} [children]  Nested choices. If wildcard filtering support is desired, then trait keys\n                                      should be provided prefixed for children (e.g. `parent:child`, rather than\n                                      just `child`).\n/\n\n/**\nObject with a number of methods for performing actions on a nested set of choices.\n@param {Object<string, SelectChoicesEntry>} [choices={}]  Initial choices for the object.\n/\nexport default class SelectChoices {\n  constructor(choices={}) {\n    const clone = foundry.utils.deepClone(choices);\n    for ( const value of Object.values(clone) ) {\n      if ( !value.children || (value.children instanceof SelectChoices) ) continue;\n      value.category = true;\n      value.children = new this.constructor(value.children);\n    }\n    Object.assign(this, clone);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreate a set of available choice keys.\n@param {Set<string>} [set]  Existing set to which the values will be added.\n@returns {Set<string>}\n/\n  asSet(set) {\n    set ??= new Set();\n    for ( const [key, choice] of Object.entries(this) ) {\n      if ( choice.children ) choice.children.asSet(set);\n      else set.add(key);\n    }\n    return set;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCreate a clone of this object.\n@returns {SelectChoices}",
      "clone": "",
      "k": "",
      "result": "",
      "options": "",
      "sorting": "",
      "inplace": "",
      "filter": "",
      "wildcardKey": ""
    },
    "AbilityScoreImprovementAdvancement": {
      "type": "",
      "configMode": "",
      "entries": "",
      "name": "",
      "class": "",
      "feat": "",
      "updates": "",
      "ability": "",
      "source": "",
      "assignments": "",
      "itemData": "",
      "featUuid": "",
      "item": "",
      "retainedItems": ""
    },
    "AdvancementError": {
      "name": ""
    },
    "HitPointsAdvancement": {
      "type": "",
      "configMode": "Advancement that presents the player with the option to roll hit points at each level or select the average value.\nKeeps track of player hit point rolls or selection for each class level. **Can only be added to classes and each\nclass can only have one.**\n/\nexport default class HitPointsAdvancement extends Advancement {\n\n  /** @inheritDoc */\n  static get metadata() {\n    return foundry.utils.mergeObject(super.metadata, {\n      order: 10,\n      icon: \"icons/magic/life/heart-pink.webp\",\n      typeIcon: \"systems/dnd5e/icons/svg/hit-points.svg\",\n      title: game.i18n.localize(\"DND5E.ADVANCEMENT.HitPoints.Title\"),\n      hint: game.i18n.localize(\"DND5E.ADVANCEMENT.HitPoints.Hint\"),\n      multiLevel: true,\n      apps: {\n        config: HitPointsConfig,\n        flow: HitPointsFlow\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n  /*  Instance Properties                         */\n  /* -------------------------------------------- */\n\n  /**\nThe amount gained if the average is taken.\n@type {number}\n/\n  get average() {\n    return (this.hitDieValue / 2) + 1;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get levels() {\n    return Array.fromRange(CONFIG.DND5E.maxLevel + 1).slice(1);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShortcut to the hit die used by the class.\n@returns {string}\n/\n  get hitDie() {\n    if ( this.actor?.type === \"npc\" ) return `d${this.actor.system.attributes.hd.denomination}`;\n    return this.item.system.hd.denomination;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe face value of the hit die used.\n@returns {number}\n/\n  get hitDieValue() {\n    return Number(this.hitDie.substring(1));\n  }\n\n  /* -------------------------------------------- */\n  /*  Display Methods                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  configuredForLevel(level) {\n    return this.valueForLevel(level) !== null;\n  }\n\n  /* --------------------------------------------",
      "value": "",
      "abilityId": "",
      "level": "Advancement that presents the player with the option to roll hit points at each level or select the average value.\nKeeps track of player hit point rolls or selection for each class level. **Can only be added to classes and each\nclass can only have one.**\n/\nexport default class HitPointsAdvancement extends Advancement {\n\n  /** @inheritDoc */\n  static get metadata() {\n    return foundry.utils.mergeObject(super.metadata, {\n      order: 10,\n      icon: \"icons/magic/life/heart-pink.webp\",\n      typeIcon: \"systems/dnd5e/icons/svg/hit-points.svg\",\n      title: game.i18n.localize(\"DND5E.ADVANCEMENT.HitPoints.Title\"),\n      hint: game.i18n.localize(\"DND5E.ADVANCEMENT.HitPoints.Hint\"),\n      multiLevel: true,\n      apps: {\n        config: HitPointsConfig,\n        flow: HitPointsFlow\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n  /*  Instance Properties                         */\n  /* -------------------------------------------- */\n\n  /**\nThe amount gained if the average is taken.\n@type {number}\n/\n  get average() {\n    return (this.hitDieValue / 2) + 1;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get levels() {\n    return Array.fromRange(CONFIG.DND5E.maxLevel + 1).slice(1);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShortcut to the hit die used by the class.\n@returns {string}\n/\n  get hitDie() {\n    if ( this.actor?.type === \"npc\" ) return `d${this.actor.system.attributes.hd.denomination}`;\n    return this.item.system.hd.denomination;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe face value of the hit die used.\n@returns {number}\n/\n  get hitDieValue() {\n    return Number(this.hitDie.substring(1));\n  }\n\n  /* -------------------------------------------- */\n  /*  Display Methods                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  configuredForLevel(level) {\n    return this.valueForLevel(level) !== null;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  titleForLevel(level, { configMode=false, legacyDisplay=false }={}) {\n    const hp = this.valueForLevel(level);\n    if ( !hp || configMode || !legacyDisplay ) return this.title;\n    return `${this.title}: <strong>${hp}</strong>`;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHit points given at the provided level.\n@param {number} level   Level for which to get hit points.\n@returns {number|null}  Hit points for level or null if none have been taken.\n/\n  valueForLevel(level) {\n    return this.constructor.valueForLevel(this.value, this.hitDieValue, level);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHit points given at the provided level.\n@param {object} data         Contents of `value` used to determine this value.\n@param {number} hitDieValue  Face value of the hit die used by this advancement.\n@param {number} level        Level for which to get hit points.\n@returns {number|null}       Hit points for level or null if none have been taken.\n/\n  static valueForLevel(data, hitDieValue, level) {\n    const value = data[level];\n    if ( !value ) return null;\n\n    if ( value === \"max\" ) return hitDieValue;\n    if ( value === \"avg\" ) return (hitDieValue / 2) + 1;\n    return value;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nTotal hit points provided by this advancement.\n@returns {number}  Hit points currently selected.\n/\n  total() {\n    return Object.keys(this.value).reduce((total, level) => total + this.valueForLevel(parseInt(level)), 0);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nTotal hit points taking the provided ability modifier into account, with a minimum of 1 per level.\n@param {number} mod  Modifier to add per level.\n@returns {number}    Total hit points plus modifier.\n/\n  getAdjustedTotal(mod) {\n    return Object.keys(this.value).reduce((total, level) => {\n      return total + Math.max(this.valueForLevel(parseInt(level)) + mod, 1);\n    }, 0);\n  }\n\n  /* -------------------------------------------- */\n  /*  Editing Methods                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static availableForItem(item) {\n    return !item.advancement.byType.HitPoints?.length;\n  }\n\n  /* -------------------------------------------- */\n  /*  Application Methods                         */\n  /* -------------------------------------------- */\n\n  /**\nAdd the ability modifier and any bonuses to the provided hit points value to get the number to apply.\n@param {number} value  Hit points taken at a given level.\n@returns {number}      Hit points adjusted with ability modifier and per-level bonuses.\n/\n  #getApplicableValue(value) {\n    const abilityId = CONFIG.DND5E.defaultAbilities.hitPoints || \"con\";\n    value = Math.max(value + (this.actor.system.abilities[abilityId]?.mod ?? 0), 1);\n    value += simplifyBonus(this.actor.system.attributes.hp.bonuses?.level, this.actor.getRollData());\n    return value;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  apply(level, data) {\n    let value = this.constructor.valueForLevel(data, this.hitDieValue, level);\n    if ( value === undefined ) return;\n    this.actor.updateSource({\n      \"system.attributes.hp.value\": this.actor.system.attributes.hp.value + this.#getApplicableValue(value)\n    });\n    this.updateSource({ value: data });\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override",
      "source": ""
    },
    "ItemChoiceAdvancement": {
      "configMode": "",
      "tag": "",
      "retainedData": "",
      "updates": "",
      "replacedLevel": "",
      "original": "Advancement that presents the player with a choice of multiple items that they can take. Keeps track of which\nitems were selected at which levels.\n/\nexport default class ItemChoiceAdvancement extends ItemGrantAdvancement {\n\n  /** @inheritDoc */\n  static get metadata() {\n    return foundry.utils.mergeObject(super.metadata, {\n      dataModels: {\n        configuration: ItemChoiceConfigurationData,\n        value: ItemChoiceValueData\n      },\n      order: 50,\n      icon: \"icons/magic/symbols/cog-orange-red.webp\",\n      typeIcon: \"systems/dnd5e/icons/svg/item-choice.svg\",\n      title: game.i18n.localize(\"DND5E.ADVANCEMENT.ItemChoice.Title\"),\n      hint: game.i18n.localize(\"DND5E.ADVANCEMENT.ItemChoice.Hint\"),\n      multiLevel: true,\n      apps: {\n        config: ItemChoiceConfig,\n        flow: ItemChoiceFlow\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n  /*  Instance Properties                         */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get levels() {\n    return Array.from(Object.keys(this.configuration.choices));\n  }\n\n  /* -------------------------------------------- */\n  /*  Display Methods                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  configuredForLevel(level) {\n    return (this.value.added?.[level] !== undefined) || !this.configuration.choices[level]?.count;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  titleForLevel(level, { configMode=false }={}) {\n    const data = this.configuration.choices[level] ?? {};\n    let tag;\n    if ( data.count ) tag = game.i18n.format(\"DND5E.ADVANCEMENT.ItemChoice.Choose\", { count: data.count });\n    else if ( data.replacement ) tag = game.i18n.localize(\"DND5E.ADVANCEMENT.ItemChoice.Replacement.Title\");\n    else return this.title;\n    return `${this.title} <em>(${tag})</em>`;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  summaryForLevel(level, { configMode=false }={}) {\n    const items = this.value.added?.[level];\n    if ( !items || configMode ) return \"\";\n    return Object.values(items).reduce((html, uuid) => html + game.dnd5e.utils.linkForUuid(uuid), \"\");\n  }\n\n  /* -------------------------------------------- */\n  /*  Application Methods                         */\n  /* -------------------------------------------- */\n\n  /** @override */\n  storagePath(level) {\n    return `value.added.${level}`;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async apply(level, { replace: original, ...data }, retainedData={}) {\n    let replacement;\n    if ( retainedData.replaced ) ({ original, replacement } = retainedData.replaced);\n\n    const updates = await super.apply(level, data, retainedData);\n\n    replacement ??= Object.keys(updates).pop();\n    if ( original && replacement ) {\n      const replacedLevel = Object.entries(this.value.added).reverse().reduce((level, [l, v]) => {\n        if ( (original in v) && (Number(l) > level) ) return Number(l);\n        return level;\n      }, 0);\n      if ( Number.isFinite(replacedLevel) ) {\n        this.actor.items.delete(original);\n        this.updateSource({ [`value.replaced.${level}`]: { level: replacedLevel, original, replacement } });\n      }\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  automaticApplicationValue(level) {\n    return false;\n  }\n\n  /* --------------------------------------------",
      "items": "",
      "replaced": "",
      "uuid": "",
      "itemData": "",
      "type": "",
      "strict": "",
      "subtype": "",
      "errorLabel": "",
      "l": ""
    },
    "ItemGrantAdvancement": {
      "static VALID_TYPES": "",
      "configMode": "Advancement that automatically grants one or more items to the player. Presents the player with the option of\nskipping any or all of the items.\n/\nexport default class ItemGrantAdvancement extends Advancement {\n\n  /** @inheritDoc */\n  static get metadata() {\n    return foundry.utils.mergeObject(super.metadata, {\n      dataModels: {\n        configuration: ItemGrantConfigurationData\n      },\n      order: 40,\n      icon: \"icons/sundries/books/book-open-purple.webp\",\n      typeIcon: \"systems/dnd5e/icons/svg/item-grant.svg\",\n      title: game.i18n.localize(\"DND5E.ADVANCEMENT.ItemGrant.Title\"),\n      hint: game.i18n.localize(\"DND5E.ADVANCEMENT.ItemGrant.Hint\"),\n      apps: {\n        config: ItemGrantConfig,\n        flow: ItemGrantFlow\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe item types that are supported in Item Grant.\n@type {Set<string>}\n/\n  static VALID_TYPES = new Set([\"feat\", \"spell\", \"consumable\", \"container\", \"equipment\", \"loot\", \"tool\", \"weapon\"]);\n\n  /* -------------------------------------------- */\n  /*  Display Methods                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  configuredForLevel(level) {\n    return !foundry.utils.isEmpty(this.value);\n  }\n\n  /* --------------------------------------------",
      "id": "",
      "retainedData": "",
      "updates": "",
      "itemData": "",
      "type": "",
      "i": "",
      "items": "Advancement that automatically grants one or more items to the player. Presents the player with the option of\nskipping any or all of the items.\n/\nexport default class ItemGrantAdvancement extends Advancement {\n\n  /** @inheritDoc */\n  static get metadata() {\n    return foundry.utils.mergeObject(super.metadata, {\n      dataModels: {\n        configuration: ItemGrantConfigurationData\n      },\n      order: 40,\n      icon: \"icons/sundries/books/book-open-purple.webp\",\n      typeIcon: \"systems/dnd5e/icons/svg/item-grant.svg\",\n      title: game.i18n.localize(\"DND5E.ADVANCEMENT.ItemGrant.Title\"),\n      hint: game.i18n.localize(\"DND5E.ADVANCEMENT.ItemGrant.Hint\"),\n      apps: {\n        config: ItemGrantConfig,\n        flow: ItemGrantFlow\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe item types that are supported in Item Grant.\n@type {Set<string>}\n/\n  static VALID_TYPES = new Set([\"feat\", \"spell\", \"consumable\", \"container\", \"equipment\", \"loot\", \"tool\", \"weapon\"]);\n\n  /* -------------------------------------------- */\n  /*  Display Methods                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  configuredForLevel(level) {\n    return !foundry.utils.isEmpty(this.value);\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  summaryForLevel(level, { configMode=false }={}) {\n    // Link to compendium items\n    if ( !this.value.added || configMode ) return this.configuration.items.filter(i => fromUuidSync(i.uuid))\n      .reduce((html, i) => html + dnd5e.utils.linkForUuid(i.uuid), \"\");\n\n    // Link to items on the actor\n    else {\n      return Object.keys(this.value.added).map(id => {\n        const item = this.actor.items.get(id);\n        return item?.toAnchor({classes: [\"content-link\"]}).outerHTML ?? \"\";\n      }).join(\"\");\n    }\n  }\n\n  /* -------------------------------------------- */\n  /*  Application Methods                         */\n  /* -------------------------------------------- */\n\n  /**\nLocation where the added items are stored for the specified level.\n@param {number} level  Level being advanced.\n@returns {string}\n/\n  storagePath(level) {\n    return \"value.added\";\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nLocally apply this advancement to the actor.\n@param {number} level              Level being advanced.\n@param {object} data               Data from the advancement form.\n@param {object} [retainedData={}]  Item data grouped by UUID. If present, this data will be used rather than\n                                   fetching new data from the source.\n@returns {object}\n/\n  async apply(level, data, retainedData={}) {\n    const items = [];\n    const updates = {};\n    for ( const uuid of filteredKeys(data) ) {\n      let itemData = retainedData[uuid];\n      if ( !itemData ) {\n        itemData = await this.createItemData(uuid);\n        if ( !itemData ) continue;\n      }\n      if ( itemData.type === \"spell\" ) this.configuration.spell?.applySpellChanges(itemData, {\n        ability: data.ability ?? this.retainedData?.ability ?? this.value?.ability\n      });\n\n      items.push(itemData);\n      updates[itemData._id] = uuid;\n    }\n    if ( items.length ) {\n      this.actor.updateSource({ items });\n      this.updateSource({\n        \"value.ability\": data.ability,\n        [this.storagePath(level)]: updates\n      });\n    }\n    return updates;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @override */\n  automaticApplicationValue(level) {\n    if ( this.configuration.optional\n      || (this.configuration.spell?.ability?.size > 1)\n      || this.configuration.items.some(i => i.optional) ) return false;\n    return Object.fromEntries(this.configuration.items.map(({ uuid }) => [uuid, true]));\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  restore(level, data) {\n    const updates = {};\n    for ( const item of data.items ) {\n      this.actor.updateSource({items: [item]});\n      updates[item._id] = item.flags.dnd5e.sourceId;\n    }\n    this.updateSource({\n      \"value.ability\": data.ability,\n      [this.storagePath(level)]: updates\n    });\n  }\n\n  /* --------------------------------------------",
      "keyPath": "",
      "item": "",
      "strict": ""
    },
    "ScaleValueAdvancement": {
      "static TYPES": "",
      "v": "",
      "l": "",
      "configMode": "",
      "key": "",
      "data": "",
      "TypeClass": "",
      "keys": "",
      "options": "",
      "class": ""
    },
    "SizeAdvancement": {
      "size": "",
      "listFormatter": "",
      "s": "",
      "configMode": ""
    },
    "SubclassAdvancement": {
      "configMode": "Advancement that allows the player to select a subclass for their class. Only allowed on class items\nand can only be taken once.\n/\nexport default class SubclassAdvancement extends Advancement {\n\n  /** @inheritDoc */\n  static get metadata() {\n    return foundry.utils.mergeObject(super.metadata, {\n      dataModels: {\n        value: SubclassValueData\n      },\n      order: 70,\n      icon: \"icons/skills/trades/mining-pickaxe-yellow-blue.webp\",\n      typeIcon: \"systems/dnd5e/icons/svg/subclass.svg\",\n      title: game.i18n.localize(\"DND5E.ADVANCEMENT.Subclass.Title\"),\n      hint: game.i18n.localize(\"DND5E.ADVANCEMENT.Subclass.Hint\"),\n      apps: {\n        flow: SubclassFlow\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n  /*  Display Methods                             */\n  /* -------------------------------------------- */\n\n  /** @inheritdoc */\n  configuredForLevel(level) {\n    return !foundry.utils.isEmpty(this.value);\n  }\n\n  /* --------------------------------------------",
      "useRetained": "",
      "itemData": "",
      "item": ""
    },
    "TraitAdvancement": {
      "rep": "",
      "traitConfig": "",
      "title": "",
      "icon": "",
      "traitOrder": "Advancement that grants the player with certain traits or presents them with a list of traits from which\nto choose.\n/\nexport default class TraitAdvancement extends Advancement {\n\n  /** @inheritDoc */\n  static get metadata() {\n    return foundry.utils.mergeObject(super.metadata, {\n      dataModels: {\n        configuration: TraitConfigurationData,\n        value: TraitValueData\n      },\n      order: 30,\n      icon: \"icons/sundries/scrolls/scroll-yellow-teal.webp\",\n      typeIcon: \"systems/dnd5e/icons/svg/trait.svg\",\n      title: game.i18n.localize(\"DND5E.ADVANCEMENT.Trait.Title\"),\n      hint: game.i18n.localize(\"DND5E.ADVANCEMENT.Trait.Hint\"),\n      apps: {\n        config: TraitConfig,\n        flow: TraitFlow\n      }\n    });\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nPerform the pre-localization of this data model.\n/\n  static localize() {\n    super.localize();\n    localizeSchema(\n      this.metadata.dataModels.configuration.schema.fields.choices.element,\n      [\"DND5E.ADVANCEMENT.Trait.FIELDS.choices\"]\n    );\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nThe maximum number of traits granted by this advancement. The number of traits actually granted may be lower if\nactor already has some traits.\n@type {number}\n/\n  get maxTraits() {\n    const { grants, choices } = this.configuration;\n    return grants.size + choices.reduce((acc, choice) => acc + choice.count, 0);\n  }\n\n  /* -------------------------------------------- */\n  /*  Preparation Methods                         */\n  /* -------------------------------------------- */\n\n  /**\nPrepare data for the Advancement.\n/\n  prepareData() {\n    const rep = this.representedTraits();\n    const traitConfig = rep.size === 1 ? CONFIG.DND5E.traits[rep.first()] : null;\n    this.title = this.title || traitConfig?.labels.title || this.constructor.metadata.title;\n    this.icon = this.icon || traitConfig?.icon || this.constructor.metadata.icon;\n  }\n\n  /* -------------------------------------------- */\n  /*  Display Methods                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  configuredForLevel(level) {\n    return !!this.value.chosen?.size;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc",
      "modeOrder": "",
      "order": "",
      "configMode": "",
      "k": "",
      "updates": "",
      "keyPath": "",
      "existingValue": "",
      "mode": "",
      "toolId": "",
      "ability": "",
      "kp": "",
      "retainedData": "",
      "selected": "",
      "available": "",
      "traitTypes": "",
      "actorValues": "",
      "choices": "",
      "value": "",
      "category": "",
      "set": "",
      "c": "",
      "unfilteredLength": "",
      "size": "",
      "remainingSet": "",
      "actorData": "",
      "grant": "",
      "allChoices": "",
      "a": ""
    },
    "ChatMessage5e": {
      "static TRAY_TYPES": "",
      "_highlighted": "",
      "type": "",
      "author": "",
      "source": "",
      "use": "",
      "itemData": "",
      "options": "",
      "element": "",
      "collapse": "",
      "chatCard": "",
      "flavor": "",
      "displayChallenge": "",
      "actor": "",
      "isCreator": "",
      "visibility": "",
      "originatingMessage": "",
      "displayAttackResult": "",
      "forceSuccess": "",
      "icon": "HTML tag names for chat trays that can open and close.\n@type {string[]}\n/\n  static TRAY_TYPES = [\"damage-application\", \"effect-application\"];\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nThe currently highlighted token for attack roll evaluation.\n@type {Token5e|null}\n/\n  _highlighted = null;\n\n  /* -------------------------------------------- */\n\n  /**\nShould the apply damage options appear?\n@type {boolean}\n/\n  get canApplyDamage() {\n    const type = this.flags.dnd5e?.roll?.type;\n    if ( type && (type !== \"damage\") ) return false;\n    return this.isRoll && this.isContentVisible && !!canvas.tokens?.controlled.length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShould the select targets options appear?\n@type {boolean}\n/\n  get canSelectTargets() {\n    if ( this.flags.dnd5e?.roll?.type !== \"attack\" ) return false;\n    return this.isRoll && this.isContentVisible;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get isRoll() {\n    if ( this.system?.isRoll !== undefined ) return this.system.isRoll;\n    return super.isRoll && !this.flags.dnd5e?.rest;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShould roll DCs and other challenge details be displayed on this card?\n@type {boolean}\n/\n  get shouldDisplayChallenge() {\n    if ( game.user.isGM || (this.author === game.user) ) return true;\n    switch ( game.settings.get(\"dnd5e\", \"challengeVisibility\") ) {\n      case \"all\": return true;\n      case \"player\": return !this.author.isGM;\n      default: return false;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStore the state of any trays in the message.\n@type {Map<string, boolean>}\n@protected\n/\n  _trayStates;\n\n  /* -------------------------------------------- */\n  /*  Data Migrations                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static migrateData(source) {\n    source = super.migrateData(source);\n    if ( foundry.utils.hasProperty(source, \"flags.dnd5e.itemData\") ) {\n      foundry.utils.setProperty(source, \"flags.dnd5e.item.data\", source.flags.dnd5e.itemData);\n      delete source.flags.dnd5e.itemData;\n    }\n    if ( foundry.utils.hasProperty(source, \"flags.dnd5e.use\") ) {\n      const use = source.flags.dnd5e.use;\n      foundry.utils.setProperty(source, \"flags.dnd5e.messageType\", \"usage\");\n      if ( use.type ) foundry.utils.setProperty(source, \"flags.dnd5e.item.type\", use.type);\n      if ( use.itemId ) foundry.utils.setProperty(source, \"flags.dnd5e.item.id\", use.itemId);\n      if ( use.itemUuid ) foundry.utils.setProperty(source, \"flags.dnd5e.item.uuid\", use.itemUuid);\n    }\n    return source;\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  prepareData() {\n    super.prepareData();\n    this._shimFlags();\n    if ( !this.flags.dnd5e?.item?.data && this.flags.dnd5e?.item?.id ) {\n      const itemData = this.getFlag(\"dnd5e\", \"use.consumed.deleted\")?.find(i => i._id === this.flags.dnd5e.item.id);\n      if ( itemData ) Object.defineProperty(this.flags.dnd5e.item, \"data\", { value: itemData });\n    }\n    dnd5e.registry.messages.track(this);\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async getHTML(options={}) {\n    const html = await super.getHTML(options);\n    const element = (html instanceof HTMLElement) ? html : html[0];\n\n    if ( foundry.utils.getType(this.system?.getHTML) === \"function\" ) {\n      await this.system.getHTML(element, options);\n      return html;\n    }\n\n    this._displayChatActionButtons(html);\n    this._highlightCriticalSuccessFailure(html);\n    if ( game.settings.get(\"dnd5e\", \"autoCollapseItemCards\") ) {\n      html.find(\".description.collapsible\").each((i, el) => el.classList.add(\"collapsed\"));\n    }\n\n    this._enrichChatCard(element);\n    this._collapseTrays(element);\n    this._activateActivityListeners(element);\n    dnd5e.bastion._activateChatListeners(this, element);\n\n    /**\nA hook event that fires after dnd5e-specific chat message modifications have completed.\n@function dnd5e.renderChatMessage\n@memberof hookEvents\n@param {ChatMessage5e} message  Chat message being rendered.\n@param {HTMLElement} html       HTML contents of the message.\n/\n    Hooks.callAll(\"dnd5e.renderChatMessage\", this, element);\n\n    return html;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle collapsing or expanding trays depending on user settings.\n@param {HTMLElement} html  Rendered contents of the message.\n/\n  _collapseTrays(html) {\n    let collapse;\n    switch ( game.settings.get(\"dnd5e\", \"autoCollapseChatTrays\") ) {\n      case \"always\": collapse = true; break;\n      case \"never\": collapse = false; break;\n      // Collapse chat message trays older than 5 minutes\n      case \"older\": collapse = this.timestamp < Date.now() - (5 * 60 * 1000); break;\n    }\n    for ( const tray of html.querySelectorAll(\".card-tray\") ) {\n      tray.classList.toggle(\"collapsed\", this._trayStates?.get(tray.className.replace(\" collapsed\", \"\")) ?? collapse);\n    }\n    for ( const element of html.querySelectorAll(this.constructor.TRAY_TYPES.join(\", \")) ) {\n      element.toggleAttribute(\"open\", this._trayStates?.get(element.tagName) ?? !collapse);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nOptionally hide the display of chat card action buttons which cannot be performed by the user\n@param {jQuery} html     Rendered contents of the message.\n@protected\n/\n  _displayChatActionButtons(html) {\n    const chatCard = html.find(\".dnd5e.chat-card, .dnd5e2.chat-card\");\n    if ( chatCard.length > 0 ) {\n      const flavor = html.find(\".flavor-text\");\n      if ( flavor.text() === html.find(\".item-name\").text() ) flavor.remove();\n\n      if ( this.shouldDisplayChallenge ) chatCard[0].dataset.displayChallenge = \"\";\n\n      const actor = game.actors.get(this.speaker.actor);\n      const isCreator = game.user.isGM || actor?.isOwner || (this.author.id === game.user.id);\n      for ( const button of html[0].querySelectorAll(\".card-buttons button\") ) {\n        if ( button.dataset.visibility === \"all\" ) continue;\n\n        // GM buttons should only be visible to GMs, otherwise button should only be visible to message's creator\n        if ( ((button.dataset.visibility === \"gm\") && !game.user.isGM) || !isCreator\n          || this.getAssociatedActivity()?.shouldHideChatButton(button, this) ) button.hidden = true;\n      }\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHighlight critical success or failure on d20 rolls.\n@param {jQuery} html     Rendered contents of the message.\n@protected\n/\n  _highlightCriticalSuccessFailure(html) {\n    if ( !this.isContentVisible || !this.rolls.length ) return;\n    const originatingMessage = this.getOriginatingMessage();\n    const displayChallenge = originatingMessage?.shouldDisplayChallenge;\n    const displayAttackResult = game.user.isGM || (game.settings.get(\"dnd5e\", \"attackRollVisibility\") !== \"none\");\n    const forceSuccess = this.flags.dnd5e?.roll?.forceSuccess === true;\n\n    /**\nCreate an icon to indicate success or failure.\n@param {string} cls  The icon class.\n@returns {HTMLElement}",
      "d0": "",
      "d20Roll": "",
      "d": "",
      "isModifiedRoll": "",
      "total": "",
      "canCrit": "",
      "isAttack": "",
      "showResult": "",
      "icons": "",
      "img": "",
      "nameText": "",
      "avatar": "",
      "uuid": "",
      "avatarImg": "",
      "name": "",
      "title": "",
      "subtitle": "",
      "innerText": "",
      "sender": "",
      "metadata": "",
      "deleteButton": "",
      "anchor": "",
      "contextMenu": "",
      "innerHTML": "",
      "el": "",
      "src": "",
      "roll": "",
      "item": "",
      "activity": "",
      "isCritical": "",
      "r": "",
      "constant": "",
      "sign": "",
      "part": "",
      "attackRoll": "HTML tag names for chat trays that can open and close.\n@type {string[]}\n/\n  static TRAY_TYPES = [\"damage-application\", \"effect-application\"];\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nThe currently highlighted token for attack roll evaluation.\n@type {Token5e|null}\n/\n  _highlighted = null;\n\n  /* -------------------------------------------- */\n\n  /**\nShould the apply damage options appear?\n@type {boolean}\n/\n  get canApplyDamage() {\n    const type = this.flags.dnd5e?.roll?.type;\n    if ( type && (type !== \"damage\") ) return false;\n    return this.isRoll && this.isContentVisible && !!canvas.tokens?.controlled.length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShould the select targets options appear?\n@type {boolean}\n/\n  get canSelectTargets() {\n    if ( this.flags.dnd5e?.roll?.type !== \"attack\" ) return false;\n    return this.isRoll && this.isContentVisible;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get isRoll() {\n    if ( this.system?.isRoll !== undefined ) return this.system.isRoll;\n    return super.isRoll && !this.flags.dnd5e?.rest;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShould roll DCs and other challenge details be displayed on this card?\n@type {boolean}\n/\n  get shouldDisplayChallenge() {\n    if ( game.user.isGM || (this.author === game.user) ) return true;\n    switch ( game.settings.get(\"dnd5e\", \"challengeVisibility\") ) {\n      case \"all\": return true;\n      case \"player\": return !this.author.isGM;\n      default: return false;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStore the state of any trays in the message.\n@type {Map<string, boolean>}\n@protected\n/\n  _trayStates;\n\n  /* -------------------------------------------- */\n  /*  Data Migrations                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static migrateData(source) {\n    source = super.migrateData(source);\n    if ( foundry.utils.hasProperty(source, \"flags.dnd5e.itemData\") ) {\n      foundry.utils.setProperty(source, \"flags.dnd5e.item.data\", source.flags.dnd5e.itemData);\n      delete source.flags.dnd5e.itemData;\n    }\n    if ( foundry.utils.hasProperty(source, \"flags.dnd5e.use\") ) {\n      const use = source.flags.dnd5e.use;\n      foundry.utils.setProperty(source, \"flags.dnd5e.messageType\", \"usage\");\n      if ( use.type ) foundry.utils.setProperty(source, \"flags.dnd5e.item.type\", use.type);\n      if ( use.itemId ) foundry.utils.setProperty(source, \"flags.dnd5e.item.id\", use.itemId);\n      if ( use.itemUuid ) foundry.utils.setProperty(source, \"flags.dnd5e.item.uuid\", use.itemUuid);\n    }\n    return source;\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  prepareData() {\n    super.prepareData();\n    this._shimFlags();\n    if ( !this.flags.dnd5e?.item?.data && this.flags.dnd5e?.item?.id ) {\n      const itemData = this.getFlag(\"dnd5e\", \"use.consumed.deleted\")?.find(i => i._id === this.flags.dnd5e.item.id);\n      if ( itemData ) Object.defineProperty(this.flags.dnd5e.item, \"data\", { value: itemData });\n    }\n    dnd5e.registry.messages.track(this);\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async getHTML(options={}) {\n    const html = await super.getHTML(options);\n    const element = (html instanceof HTMLElement) ? html : html[0];\n\n    if ( foundry.utils.getType(this.system?.getHTML) === \"function\" ) {\n      await this.system.getHTML(element, options);\n      return html;\n    }\n\n    this._displayChatActionButtons(html);\n    this._highlightCriticalSuccessFailure(html);\n    if ( game.settings.get(\"dnd5e\", \"autoCollapseItemCards\") ) {\n      html.find(\".description.collapsible\").each((i, el) => el.classList.add(\"collapsed\"));\n    }\n\n    this._enrichChatCard(element);\n    this._collapseTrays(element);\n    this._activateActivityListeners(element);\n    dnd5e.bastion._activateChatListeners(this, element);\n\n    /**\nA hook event that fires after dnd5e-specific chat message modifications have completed.\n@function dnd5e.renderChatMessage\n@memberof hookEvents\n@param {ChatMessage5e} message  Chat message being rendered.\n@param {HTMLElement} html       HTML contents of the message.\n/\n    Hooks.callAll(\"dnd5e.renderChatMessage\", this, element);\n\n    return html;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle collapsing or expanding trays depending on user settings.\n@param {HTMLElement} html  Rendered contents of the message.\n/\n  _collapseTrays(html) {\n    let collapse;\n    switch ( game.settings.get(\"dnd5e\", \"autoCollapseChatTrays\") ) {\n      case \"always\": collapse = true; break;\n      case \"never\": collapse = false; break;\n      // Collapse chat message trays older than 5 minutes\n      case \"older\": collapse = this.timestamp < Date.now() - (5 * 60 * 1000); break;\n    }\n    for ( const tray of html.querySelectorAll(\".card-tray\") ) {\n      tray.classList.toggle(\"collapsed\", this._trayStates?.get(tray.className.replace(\" collapsed\", \"\")) ?? collapse);\n    }\n    for ( const element of html.querySelectorAll(this.constructor.TRAY_TYPES.join(\", \")) ) {\n      element.toggleAttribute(\"open\", this._trayStates?.get(element.tagName) ?? !collapse);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nOptionally hide the display of chat card action buttons which cannot be performed by the user\n@param {jQuery} html     Rendered contents of the message.\n@protected\n/\n  _displayChatActionButtons(html) {\n    const chatCard = html.find(\".dnd5e.chat-card, .dnd5e2.chat-card\");\n    if ( chatCard.length > 0 ) {\n      const flavor = html.find(\".flavor-text\");\n      if ( flavor.text() === html.find(\".item-name\").text() ) flavor.remove();\n\n      if ( this.shouldDisplayChallenge ) chatCard[0].dataset.displayChallenge = \"\";\n\n      const actor = game.actors.get(this.speaker.actor);\n      const isCreator = game.user.isGM || actor?.isOwner || (this.author.id === game.user.id);\n      for ( const button of html[0].querySelectorAll(\".card-buttons button\") ) {\n        if ( button.dataset.visibility === \"all\" ) continue;\n\n        // GM buttons should only be visible to GMs, otherwise button should only be visible to message's creator\n        if ( ((button.dataset.visibility === \"gm\") && !game.user.isGM) || !isCreator\n          || this.getAssociatedActivity()?.shouldHideChatButton(button, this) ) button.hidden = true;\n      }\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHighlight critical success or failure on d20 rolls.\n@param {jQuery} html     Rendered contents of the message.\n@protected\n/\n  _highlightCriticalSuccessFailure(html) {\n    if ( !this.isContentVisible || !this.rolls.length ) return;\n    const originatingMessage = this.getOriginatingMessage();\n    const displayChallenge = originatingMessage?.shouldDisplayChallenge;\n    const displayAttackResult = game.user.isGM || (game.settings.get(\"dnd5e\", \"attackRollVisibility\") !== \"none\");\n    const forceSuccess = this.flags.dnd5e?.roll?.forceSuccess === true;\n\n    /**\nCreate an icon to indicate success or failure.\n@param {string} cls  The icon class.\n@returns {HTMLElement}\n/\n    function makeIcon(cls) {\n      const icon = document.createElement(\"i\");\n      icon.classList.add(\"fas\", cls);\n      icon.setAttribute(\"inert\", \"\");\n      return icon;\n    }\n\n    // Highlight rolls where the first part is a d20 roll\n    for ( let [index, d20Roll] of this.rolls.entries() ) {\n\n      const d0 = d20Roll.dice[0];\n      if ( (d0?.faces !== 20) || (d0?.values.length !== 1) ) continue;\n\n      d20Roll = dnd5e.dice.D20Roll.fromRoll(d20Roll);\n      const d = d20Roll.dice[0];\n\n      const isModifiedRoll = (\"success\" in d.results[0]) || d.options.marginSuccess || d.options.marginFailure;\n      if ( isModifiedRoll ) continue;\n\n      // Highlight successes and failures\n      const total = html.find(\".dice-total\")[index];\n      if ( !total ) continue;\n      // Only attack rolls and death saves can crit or fumble.\n      const canCrit = [\"attack\", \"death\"].includes(this.getFlag(\"dnd5e\", \"roll.type\"));\n      const isAttack = this.getFlag(\"dnd5e\", \"roll.type\") === \"attack\";\n      const showResult = isAttack ? displayAttackResult : displayChallenge;\n      if ( d.options.target && showResult ) {\n        if ( d20Roll.isSuccess || forceSuccess ) total.classList.add(\"success\");\n        else total.classList.add(\"failure\");\n      }\n      if ( canCrit && d20Roll.isCritical ) total.classList.add(\"critical\");\n      if ( canCrit && d20Roll.isFumble && !forceSuccess ) total.classList.add(\"fumble\");\n\n      const icons = document.createElement(\"div\");\n      icons.classList.add(\"icons\");\n      if ( total.classList.contains(\"critical\") ) icons.append(makeIcon(\"fa-check\"), makeIcon(\"fa-check\"));\n      else if ( total.classList.contains(\"fumble\") ) icons.append(makeIcon(\"fa-xmark\"), makeIcon(\"fa-xmark\"));\n      else if ( total.classList.contains(\"success\") ) icons.append(makeIcon(\"fa-check\"));\n      else if ( total.classList.contains(\"failure\") ) icons.append(makeIcon(\"fa-xmark\"));\n      if ( icons.children.length ) total.append(icons);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAugment the chat card markup for additional styling.\n@param {HTMLElement} html  The chat card markup.\n@protected\n/\n  _enrichChatCard(html) {\n    // Header matter\n    const actor = this.getAssociatedActor();\n\n    let img;\n    let nameText;\n    if ( this.isContentVisible ) {\n      img = actor?.img ?? this.author.avatar;\n      nameText = this.alias;\n    } else {\n      img = this.author.avatar;\n      nameText = this.author.name;\n    }\n\n    const avatar = document.createElement(\"a\");\n    avatar.classList.add(\"avatar\");\n    if ( actor ) avatar.dataset.uuid = actor.uuid;\n    const avatarImg = document.createElement(\"img\");\n    Object.assign(avatarImg, { src: img, alt: nameText });\n    avatar.append(avatarImg);\n\n    const name = document.createElement(\"span\");\n    name.classList.add(\"name-stacked\");\n    const title = document.createElement(\"span\");\n    title.classList.add(\"title\");\n    title.append(nameText);\n    name.append(title);\n\n    const subtitle = document.createElement(\"span\");\n    subtitle.classList.add(\"subtitle\");\n    if ( this.whisper.length ) subtitle.innerText = html.querySelector(\".whisper-to\")?.innerText ?? \"\";\n    if ( (nameText !== this.author?.name) && !subtitle.innerText.length ) subtitle.innerText = this.author?.name ?? \"\";\n\n    name.appendChild(subtitle);\n\n    const sender = html.querySelector(\".message-sender\");\n    sender?.replaceChildren(avatar, name);\n    html.querySelector(\".whisper-to\")?.remove();\n\n    // Context menu\n    const metadata = html.querySelector(\".message-metadata\");\n    const deleteButton = metadata.querySelector(\".message-delete\");\n    if ( !game.user.isGM ) deleteButton?.remove();\n    const anchor = document.createElement(\"a\");\n    anchor.setAttribute(\"aria-label\", game.i18n.localize(\"DND5E.AdditionalControls\"));\n    anchor.classList.add(\"chat-control\");\n    anchor.dataset.contextMenu = \"\";\n    anchor.innerHTML = '<i class=\"fas fa-ellipsis-vertical fa-fw\"></i>';\n    metadata.appendChild(anchor);\n\n    // SVG icons\n    html.querySelectorAll(\"i.dnd5e-icon\").forEach(el => {\n      const icon = document.createElement(\"dnd5e-icon\");\n      icon.src = el.dataset.src;\n      el.replaceWith(icon);\n    });\n\n    // Enriched roll flavor\n    const roll = this.getFlag(\"dnd5e\", \"roll\");\n    const item = this.getAssociatedItem();\n    const activity = this.getAssociatedActivity();\n    if ( this.isContentVisible && item && roll ) {\n      const isCritical = (roll.type === \"damage\") && this.rolls[0]?.isCritical;\n      const subtitle = roll.type === \"damage\"\n        ? isCritical\n          ? game.i18n.localize(\"DND5E.CriticalHit\")\n          : activity?.damageFlavor ?? game.i18n.localize(\"DND5E.DamageRoll\")\n        : roll.type === \"attack\"\n          ? (activity?.getActionLabel(roll.attackMode) ?? \"\")\n          : (item.system.type?.label ?? game.i18n.localize(CONFIG.Item.typeLabels[item.type]));\n      const flavor = document.createElement(\"div\");\n      flavor.classList.add(\"dnd5e2\", \"chat-card\");\n      flavor.innerHTML = `\n        <section class=\"card-header description ${isCritical ? \"critical\" : \"\"}\">\n          <header class=\"summary\">\n            <div class=\"name-stacked\">\n              <span class=\"subtitle\">${subtitle}</span>\n            </div>\n          </header>\n        </section>\n      `;\n      const icon = document.createElement(\"img\");\n      Object.assign(icon, { className: \"gold-icon\", src: item.img, alt: item.name });\n      flavor.querySelector(\"header\").insertAdjacentElement(\"afterbegin\", icon);\n      const title = document.createElement(\"span\");\n      title.classList.add(\"title\");\n      title.append(item.name);\n      flavor.querySelector(\".name-stacked\").insertAdjacentElement(\"afterbegin\", title);\n      html.querySelector(\".message-header .flavor-text\").remove();\n      html.querySelector(\".message-content\").insertAdjacentElement(\"afterbegin\", flavor);\n    }\n\n    // Attack targets\n    this._enrichAttackTargets(html);\n\n    // Dice rolls\n    if ( this.isContentVisible ) {\n      html.querySelectorAll(\".dice-tooltip\").forEach((el, i) => {\n        if ( !(roll instanceof DamageRoll) && this.rolls[i] ) this._enrichRollTooltip(this.rolls[i], el);\n      });\n      this._enrichDamageTooltip(this.rolls.filter(r => r instanceof DamageRoll), html);\n      this._enrichSaveTooltip(html);\n      this._enrichEnchantmentTooltip(html);\n      html.querySelectorAll(\".dice-roll\").forEach(el => el.addEventListener(\"click\", this._onClickDiceRoll.bind(this)));\n    } else {\n      html.querySelectorAll(\".dice-roll\").forEach(el => el.classList.add(\"secret-roll\"));\n    }\n\n    // Effects tray\n    this._enrichUsageEffects(html);\n\n    avatar.addEventListener(\"click\", this._onTargetMouseDown.bind(this));\n    avatar.addEventListener(\"pointerover\", this._onTargetHoverIn.bind(this));\n    avatar.addEventListener(\"pointerout\", this._onTargetHoverOut.bind(this));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAugment roll tooltips with some additional information and styling.\n@param {Roll} roll            The roll instance.\n@param {HTMLDivElement} html  The roll tooltip markup.\n/\n  _enrichRollTooltip(roll, html) {\n    const constant = Number(simplifyRollFormula(roll._formula, { deterministic: true }));\n    if ( !constant ) return;\n    const sign = constant < 0 ? \"-\" : \"+\";\n    const part = document.createElement(\"section\");\n    part.classList.add(\"tooltip-part\", \"constant\");\n    part.innerHTML = `\n      <div class=\"dice\">\n        <ol class=\"dice-rolls\"></ol>\n        <div class=\"total\">\n          <span class=\"value\"><span class=\"sign\">${sign}</span>${Math.abs(constant)}</span>\n        </div>\n      </div>\n    `;\n    html.appendChild(part);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAugment attack cards with additional information.\n@param {HTMLLIElement} html   The chat card.\n@protected",
      "masteryConfig": "",
      "p": "",
      "mastery": "",
      "isVisible": "",
      "targets": "",
      "tray": "",
      "evaluation": "",
      "rows": "",
      "isMiss": "",
      "li": "",
      "className": "",
      "missA": "",
      "missB": "",
      "target": "",
      "aggregatedRolls": "",
      "formula": "",
      "tooltipContents": "",
      "class": "",
      "damageOnSave": "",
      "damageApplication": "",
      "damages": "",
      "aggregate": "HTML tag names for chat trays that can open and close.\n@type {string[]}\n/\n  static TRAY_TYPES = [\"damage-application\", \"effect-application\"];\n\n  /* -------------------------------------------- */\n  /*  Properties                                  */\n  /* -------------------------------------------- */\n\n  /**\nThe currently highlighted token for attack roll evaluation.\n@type {Token5e|null}\n/\n  _highlighted = null;\n\n  /* -------------------------------------------- */\n\n  /**\nShould the apply damage options appear?\n@type {boolean}\n/\n  get canApplyDamage() {\n    const type = this.flags.dnd5e?.roll?.type;\n    if ( type && (type !== \"damage\") ) return false;\n    return this.isRoll && this.isContentVisible && !!canvas.tokens?.controlled.length;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShould the select targets options appear?\n@type {boolean}\n/\n  get canSelectTargets() {\n    if ( this.flags.dnd5e?.roll?.type !== \"attack\" ) return false;\n    return this.isRoll && this.isContentVisible;\n  }\n\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  get isRoll() {\n    if ( this.system?.isRoll !== undefined ) return this.system.isRoll;\n    return super.isRoll && !this.flags.dnd5e?.rest;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nShould roll DCs and other challenge details be displayed on this card?\n@type {boolean}\n/\n  get shouldDisplayChallenge() {\n    if ( game.user.isGM || (this.author === game.user) ) return true;\n    switch ( game.settings.get(\"dnd5e\", \"challengeVisibility\") ) {\n      case \"all\": return true;\n      case \"player\": return !this.author.isGM;\n      default: return false;\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nStore the state of any trays in the message.\n@type {Map<string, boolean>}\n@protected\n/\n  _trayStates;\n\n  /* -------------------------------------------- */\n  /*  Data Migrations                             */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  static migrateData(source) {\n    source = super.migrateData(source);\n    if ( foundry.utils.hasProperty(source, \"flags.dnd5e.itemData\") ) {\n      foundry.utils.setProperty(source, \"flags.dnd5e.item.data\", source.flags.dnd5e.itemData);\n      delete source.flags.dnd5e.itemData;\n    }\n    if ( foundry.utils.hasProperty(source, \"flags.dnd5e.use\") ) {\n      const use = source.flags.dnd5e.use;\n      foundry.utils.setProperty(source, \"flags.dnd5e.messageType\", \"usage\");\n      if ( use.type ) foundry.utils.setProperty(source, \"flags.dnd5e.item.type\", use.type);\n      if ( use.itemId ) foundry.utils.setProperty(source, \"flags.dnd5e.item.id\", use.itemId);\n      if ( use.itemUuid ) foundry.utils.setProperty(source, \"flags.dnd5e.item.uuid\", use.itemUuid);\n    }\n    return source;\n  }\n\n  /* -------------------------------------------- */\n  /*  Data Preparation                            */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  prepareData() {\n    super.prepareData();\n    this._shimFlags();\n    if ( !this.flags.dnd5e?.item?.data && this.flags.dnd5e?.item?.id ) {\n      const itemData = this.getFlag(\"dnd5e\", \"use.consumed.deleted\")?.find(i => i._id === this.flags.dnd5e.item.id);\n      if ( itemData ) Object.defineProperty(this.flags.dnd5e.item, \"data\", { value: itemData });\n    }\n    dnd5e.registry.messages.track(this);\n  }\n\n  /* -------------------------------------------- */\n  /*  Rendering                                   */\n  /* -------------------------------------------- */\n\n  /** @inheritDoc */\n  async getHTML(options={}) {\n    const html = await super.getHTML(options);\n    const element = (html instanceof HTMLElement) ? html : html[0];\n\n    if ( foundry.utils.getType(this.system?.getHTML) === \"function\" ) {\n      await this.system.getHTML(element, options);\n      return html;\n    }\n\n    this._displayChatActionButtons(html);\n    this._highlightCriticalSuccessFailure(html);\n    if ( game.settings.get(\"dnd5e\", \"autoCollapseItemCards\") ) {\n      html.find(\".description.collapsible\").each((i, el) => el.classList.add(\"collapsed\"));\n    }\n\n    this._enrichChatCard(element);\n    this._collapseTrays(element);\n    this._activateActivityListeners(element);\n    dnd5e.bastion._activateChatListeners(this, element);\n\n    /**\nA hook event that fires after dnd5e-specific chat message modifications have completed.\n@function dnd5e.renderChatMessage\n@memberof hookEvents\n@param {ChatMessage5e} message  Chat message being rendered.\n@param {HTMLElement} html       HTML contents of the message.\n/\n    Hooks.callAll(\"dnd5e.renderChatMessage\", this, element);\n\n    return html;\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHandle collapsing or expanding trays depending on user settings.\n@param {HTMLElement} html  Rendered contents of the message.\n/\n  _collapseTrays(html) {\n    let collapse;\n    switch ( game.settings.get(\"dnd5e\", \"autoCollapseChatTrays\") ) {\n      case \"always\": collapse = true; break;\n      case \"never\": collapse = false; break;\n      // Collapse chat message trays older than 5 minutes\n      case \"older\": collapse = this.timestamp < Date.now() - (5 * 60 * 1000); break;\n    }\n    for ( const tray of html.querySelectorAll(\".card-tray\") ) {\n      tray.classList.toggle(\"collapsed\", this._trayStates?.get(tray.className.replace(\" collapsed\", \"\")) ?? collapse);\n    }\n    for ( const element of html.querySelectorAll(this.constructor.TRAY_TYPES.join(\", \")) ) {\n      element.toggleAttribute(\"open\", this._trayStates?.get(element.tagName) ?? !collapse);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nOptionally hide the display of chat card action buttons which cannot be performed by the user\n@param {jQuery} html     Rendered contents of the message.\n@protected\n/\n  _displayChatActionButtons(html) {\n    const chatCard = html.find(\".dnd5e.chat-card, .dnd5e2.chat-card\");\n    if ( chatCard.length > 0 ) {\n      const flavor = html.find(\".flavor-text\");\n      if ( flavor.text() === html.find(\".item-name\").text() ) flavor.remove();\n\n      if ( this.shouldDisplayChallenge ) chatCard[0].dataset.displayChallenge = \"\";\n\n      const actor = game.actors.get(this.speaker.actor);\n      const isCreator = game.user.isGM || actor?.isOwner || (this.author.id === game.user.id);\n      for ( const button of html[0].querySelectorAll(\".card-buttons button\") ) {\n        if ( button.dataset.visibility === \"all\" ) continue;\n\n        // GM buttons should only be visible to GMs, otherwise button should only be visible to message's creator\n        if ( ((button.dataset.visibility === \"gm\") && !game.user.isGM) || !isCreator\n          || this.getAssociatedActivity()?.shouldHideChatButton(button, this) ) button.hidden = true;\n      }\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nHighlight critical success or failure on d20 rolls.\n@param {jQuery} html     Rendered contents of the message.\n@protected\n/\n  _highlightCriticalSuccessFailure(html) {\n    if ( !this.isContentVisible || !this.rolls.length ) return;\n    const originatingMessage = this.getOriginatingMessage();\n    const displayChallenge = originatingMessage?.shouldDisplayChallenge;\n    const displayAttackResult = game.user.isGM || (game.settings.get(\"dnd5e\", \"attackRollVisibility\") !== \"none\");\n    const forceSuccess = this.flags.dnd5e?.roll?.forceSuccess === true;\n\n    /**\nCreate an icon to indicate success or failure.\n@param {string} cls  The icon class.\n@returns {HTMLElement}\n/\n    function makeIcon(cls) {\n      const icon = document.createElement(\"i\");\n      icon.classList.add(\"fas\", cls);\n      icon.setAttribute(\"inert\", \"\");\n      return icon;\n    }\n\n    // Highlight rolls where the first part is a d20 roll\n    for ( let [index, d20Roll] of this.rolls.entries() ) {\n\n      const d0 = d20Roll.dice[0];\n      if ( (d0?.faces !== 20) || (d0?.values.length !== 1) ) continue;\n\n      d20Roll = dnd5e.dice.D20Roll.fromRoll(d20Roll);\n      const d = d20Roll.dice[0];\n\n      const isModifiedRoll = (\"success\" in d.results[0]) || d.options.marginSuccess || d.options.marginFailure;\n      if ( isModifiedRoll ) continue;\n\n      // Highlight successes and failures\n      const total = html.find(\".dice-total\")[index];\n      if ( !total ) continue;\n      // Only attack rolls and death saves can crit or fumble.\n      const canCrit = [\"attack\", \"death\"].includes(this.getFlag(\"dnd5e\", \"roll.type\"));\n      const isAttack = this.getFlag(\"dnd5e\", \"roll.type\") === \"attack\";\n      const showResult = isAttack ? displayAttackResult : displayChallenge;\n      if ( d.options.target && showResult ) {\n        if ( d20Roll.isSuccess || forceSuccess ) total.classList.add(\"success\");\n        else total.classList.add(\"failure\");\n      }\n      if ( canCrit && d20Roll.isCritical ) total.classList.add(\"critical\");\n      if ( canCrit && d20Roll.isFumble && !forceSuccess ) total.classList.add(\"fumble\");\n\n      const icons = document.createElement(\"div\");\n      icons.classList.add(\"icons\");\n      if ( total.classList.contains(\"critical\") ) icons.append(makeIcon(\"fa-check\"), makeIcon(\"fa-check\"));\n      else if ( total.classList.contains(\"fumble\") ) icons.append(makeIcon(\"fa-xmark\"), makeIcon(\"fa-xmark\"));\n      else if ( total.classList.contains(\"success\") ) icons.append(makeIcon(\"fa-check\"));\n      else if ( total.classList.contains(\"failure\") ) icons.append(makeIcon(\"fa-xmark\"));\n      if ( icons.children.length ) total.append(icons);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAugment the chat card markup for additional styling.\n@param {HTMLElement} html  The chat card markup.\n@protected\n/\n  _enrichChatCard(html) {\n    // Header matter\n    const actor = this.getAssociatedActor();\n\n    let img;\n    let nameText;\n    if ( this.isContentVisible ) {\n      img = actor?.img ?? this.author.avatar;\n      nameText = this.alias;\n    } else {\n      img = this.author.avatar;\n      nameText = this.author.name;\n    }\n\n    const avatar = document.createElement(\"a\");\n    avatar.classList.add(\"avatar\");\n    if ( actor ) avatar.dataset.uuid = actor.uuid;\n    const avatarImg = document.createElement(\"img\");\n    Object.assign(avatarImg, { src: img, alt: nameText });\n    avatar.append(avatarImg);\n\n    const name = document.createElement(\"span\");\n    name.classList.add(\"name-stacked\");\n    const title = document.createElement(\"span\");\n    title.classList.add(\"title\");\n    title.append(nameText);\n    name.append(title);\n\n    const subtitle = document.createElement(\"span\");\n    subtitle.classList.add(\"subtitle\");\n    if ( this.whisper.length ) subtitle.innerText = html.querySelector(\".whisper-to\")?.innerText ?? \"\";\n    if ( (nameText !== this.author?.name) && !subtitle.innerText.length ) subtitle.innerText = this.author?.name ?? \"\";\n\n    name.appendChild(subtitle);\n\n    const sender = html.querySelector(\".message-sender\");\n    sender?.replaceChildren(avatar, name);\n    html.querySelector(\".whisper-to\")?.remove();\n\n    // Context menu\n    const metadata = html.querySelector(\".message-metadata\");\n    const deleteButton = metadata.querySelector(\".message-delete\");\n    if ( !game.user.isGM ) deleteButton?.remove();\n    const anchor = document.createElement(\"a\");\n    anchor.setAttribute(\"aria-label\", game.i18n.localize(\"DND5E.AdditionalControls\"));\n    anchor.classList.add(\"chat-control\");\n    anchor.dataset.contextMenu = \"\";\n    anchor.innerHTML = '<i class=\"fas fa-ellipsis-vertical fa-fw\"></i>';\n    metadata.appendChild(anchor);\n\n    // SVG icons\n    html.querySelectorAll(\"i.dnd5e-icon\").forEach(el => {\n      const icon = document.createElement(\"dnd5e-icon\");\n      icon.src = el.dataset.src;\n      el.replaceWith(icon);\n    });\n\n    // Enriched roll flavor\n    const roll = this.getFlag(\"dnd5e\", \"roll\");\n    const item = this.getAssociatedItem();\n    const activity = this.getAssociatedActivity();\n    if ( this.isContentVisible && item && roll ) {\n      const isCritical = (roll.type === \"damage\") && this.rolls[0]?.isCritical;\n      const subtitle = roll.type === \"damage\"\n        ? isCritical\n          ? game.i18n.localize(\"DND5E.CriticalHit\")\n          : activity?.damageFlavor ?? game.i18n.localize(\"DND5E.DamageRoll\")\n        : roll.type === \"attack\"\n          ? (activity?.getActionLabel(roll.attackMode) ?? \"\")\n          : (item.system.type?.label ?? game.i18n.localize(CONFIG.Item.typeLabels[item.type]));\n      const flavor = document.createElement(\"div\");\n      flavor.classList.add(\"dnd5e2\", \"chat-card\");\n      flavor.innerHTML = `\n        <section class=\"card-header description ${isCritical ? \"critical\" : \"\"}\">\n          <header class=\"summary\">\n            <div class=\"name-stacked\">\n              <span class=\"subtitle\">${subtitle}</span>\n            </div>\n          </header>\n        </section>\n      `;\n      const icon = document.createElement(\"img\");\n      Object.assign(icon, { className: \"gold-icon\", src: item.img, alt: item.name });\n      flavor.querySelector(\"header\").insertAdjacentElement(\"afterbegin\", icon);\n      const title = document.createElement(\"span\");\n      title.classList.add(\"title\");\n      title.append(item.name);\n      flavor.querySelector(\".name-stacked\").insertAdjacentElement(\"afterbegin\", title);\n      html.querySelector(\".message-header .flavor-text\").remove();\n      html.querySelector(\".message-content\").insertAdjacentElement(\"afterbegin\", flavor);\n    }\n\n    // Attack targets\n    this._enrichAttackTargets(html);\n\n    // Dice rolls\n    if ( this.isContentVisible ) {\n      html.querySelectorAll(\".dice-tooltip\").forEach((el, i) => {\n        if ( !(roll instanceof DamageRoll) && this.rolls[i] ) this._enrichRollTooltip(this.rolls[i], el);\n      });\n      this._enrichDamageTooltip(this.rolls.filter(r => r instanceof DamageRoll), html);\n      this._enrichSaveTooltip(html);\n      this._enrichEnchantmentTooltip(html);\n      html.querySelectorAll(\".dice-roll\").forEach(el => el.addEventListener(\"click\", this._onClickDiceRoll.bind(this)));\n    } else {\n      html.querySelectorAll(\".dice-roll\").forEach(el => el.classList.add(\"secret-roll\"));\n    }\n\n    // Effects tray\n    this._enrichUsageEffects(html);\n\n    avatar.addEventListener(\"click\", this._onTargetMouseDown.bind(this));\n    avatar.addEventListener(\"pointerover\", this._onTargetHoverIn.bind(this));\n    avatar.addEventListener(\"pointerout\", this._onTargetHoverOut.bind(this));\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAugment roll tooltips with some additional information and styling.\n@param {Roll} roll            The roll instance.\n@param {HTMLDivElement} html  The roll tooltip markup.\n/\n  _enrichRollTooltip(roll, html) {\n    const constant = Number(simplifyRollFormula(roll._formula, { deterministic: true }));\n    if ( !constant ) return;\n    const sign = constant < 0 ? \"-\" : \"+\";\n    const part = document.createElement(\"section\");\n    part.classList.add(\"tooltip-part\", \"constant\");\n    part.innerHTML = `\n      <div class=\"dice\">\n        <ol class=\"dice-rolls\"></ol>\n        <div class=\"total\">\n          <span class=\"value\"><span class=\"sign\">${sign}</span>${Math.abs(constant)}</span>\n        </div>\n      </div>\n    `;\n    html.appendChild(part);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nAugment attack cards with additional information.\n@param {HTMLLIElement} html   The chat card.\n@protected\n/\n  _enrichAttackTargets(html) {\n    const attackRoll = this.rolls[0];\n    if ( !(attackRoll instanceof dnd5e.dice.D20Roll) ) return;\n\n    const masteryConfig = CONFIG.DND5E.weaponMasteries[attackRoll.options.mastery];\n    if ( masteryConfig ) {\n      const p = document.createElement(\"p\");\n      p.classList.add(\"supplement\");\n      let mastery = masteryConfig.label;\n      if ( masteryConfig.reference ) mastery = `\n        <a class=\"content-link\" draggable=\"true\" data-link data-uuid=\"${masteryConfig.reference}\"\n           data-tooltip=\"${mastery}\">${mastery}</a>\n      `;\n      p.innerHTML = `<strong>${game.i18n.format(\"DND5E.WEAPON.Mastery.Flavor\")}</strong> ${mastery}`;\n      (html.querySelector(\".chat-card\") ?? html.querySelector(\".message-content\"))?.appendChild(p);\n    }\n\n    const visibility = game.settings.get(\"dnd5e\", \"attackRollVisibility\");\n    const isVisible = game.user.isGM || (visibility !== \"none\");\n    if ( !isVisible ) return;\n\n    const targets = this.getFlag(\"dnd5e\", \"targets\");\n    if ( !targets?.length ) return;\n    const tray = document.createElement(\"div\");\n    tray.classList.add(\"dnd5e2\");\n    tray.innerHTML = `\n      <div class=\"card-tray targets-tray collapsible collapsed\">\n        <label class=\"roboto-upper\">\n          <i class=\"fas fa-bullseye\" inert></i>\n          <span>${game.i18n.localize(\"DND5E.TargetPl\")}</span>\n          <i class=\"fas fa-caret-down\" inert></i>\n        </label>\n        <div class=\"collapsible-content\">\n          <ul class=\"dnd5e2 unlist evaluation wrapper\"></ul>\n        </div>\n      </div>\n    `;\n    const evaluation = tray.querySelector(\"ul\");\n    const rows = targets.map(({ name, ac, uuid }) => {\n      if ( !game.user.isGM && (visibility !== \"all\") ) ac = \"\";\n      const isMiss = !attackRoll.isCritical && ((attackRoll.total < ac) || attackRoll.isFumble);\n      const li = document.createElement(\"li\");\n      Object.assign(li.dataset, { uuid, miss: isMiss });\n      li.className = `target ${isMiss ? \"miss\" : \"hit\"}`;\n      li.innerHTML = `\n        <i class=\"fas ${isMiss ? \"fa-times\" : \"fa-check\"}\"></i>\n        <div class=\"name\"></div>\n        ${(ac !== \"\") ? `\n        <div class=\"ac\">\n          <i class=\"fas fa-shield-halved\"></i>\n          <span>${(ac === null) ? \"&infin;\" : ac}</span>\n        </div>\n        ` : \"\"}\n      `;\n      li.querySelector(\".name\").append(name);\n      return li;\n    }).sort((a, b) => {\n      const missA = Boolean(a.dataset.miss);\n      const missB = Boolean(b.dataset.miss);\n      return missA === missB ? 0 : missA ? 1 : -1;\n    });\n    evaluation.append(...rows);\n    evaluation.querySelectorAll(\"li.target\").forEach(target => {\n      target.addEventListener(\"click\", this._onTargetMouseDown.bind(this));\n      target.addEventListener(\"pointerover\", this._onTargetHoverIn.bind(this));\n      target.addEventListener(\"pointerout\", this._onTargetHoverOut.bind(this));\n    });\n    html.querySelector(\".message-content\")?.appendChild(tray);\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nCoalesce damage rolls into a single breakdown.\n@param {DamageRoll[]} rolls  The damage rolls.\n@param {HTMLElement} html    The chat card markup.\n@protected\n/\n  _enrichDamageTooltip(rolls, html) {\n    if ( !rolls.length ) return;\n    const aggregatedRolls = CONFIG.DND5E.aggregateDamageDisplay ? aggregateDamageRolls(rolls) : rolls;\n    let { formula, total, breakdown } = aggregatedRolls.reduce((obj, r) => {\n      obj.formula.push(CONFIG.DND5E.aggregateDamageDisplay ? r.formula : ` + ${r.formula}`);\n      obj.total += r.total;\n      obj.breakdown.push(this._simplifyDamageRoll(r));\n      return obj;\n    }, { formula: [], total: 0, breakdown: [] });\n    formula = formula.join(\"\").replace(/^ \\+ /, \"\");\n    html.querySelectorAll(\".dice-roll\").forEach(el => el.remove());\n    const roll = document.createElement(\"div\");\n    roll.classList.add(\"dice-roll\");\n\n    const tooltipContents = breakdown.reduce((str, { type, total, constant, dice }) => {\n      const config = CONFIG.DND5E.damageTypes[type] ?? CONFIG.DND5E.healingTypes[type];\n      return `${str}\n        <section class=\"tooltip-part\">\n          <div class=\"dice\">\n            <ol class=\"dice-rolls\">\n              ${dice.reduce((str, { result, classes }) => `\n                ${str}<li class=\"roll ${classes}\">${result}</li>\n              `, \"\")}\n              ${constant ? `\n              <li class=\"constant\"><span class=\"sign\">${constant < 0 ? \"-\" : \"+\"}</span>${Math.abs(constant)}</li>\n              ` : \"\"}\n            </ol>\n            <div class=\"total\">\n              ${config ? `<img src=\"${config.icon}\" alt=\"${config.label}\">` : \"\"}\n              <span class=\"label\">${config?.label ?? \"\"}</span>\n              <span class=\"value\">${total}</span>\n            </div>\n          </div>\n        </section>\n      `;\n    }, \"\");\n\n    roll.innerHTML = `\n      <div class=\"dice-result\">\n        <div class=\"dice-formula\">${formula}</div>\n        <div class=\"dice-tooltip-collapser\">\n          <div class=\"dice-tooltip\">\n            ${tooltipContents}\n          </div>\n        </div>\n        <h4 class=\"dice-total\">${total}</h4>\n      </div>\n    `;\n    html.querySelector(\".message-content\").appendChild(roll);\n\n    const damageOnSave = this.getFlag(\"dnd5e\", \"roll.damageOnSave\");\n    if ( damageOnSave ) {\n      const p = document.createElement(\"p\");\n      p.classList.add(\"supplement\");\n      p.innerHTML = `<strong>${game.i18n.format(\"DND5E.SAVE.OnSave\")}</strong> ${\n        game.i18n.localize(`DND5E.SAVE.FIELDS.damage.onSave.${damageOnSave.capitalize()}`)\n      }`;\n      html.querySelector(\".chat-card, .message-content\")?.appendChild(p);\n    }\n\n    if ( game.user.isGM ) {\n      const damageApplication = document.createElement(\"damage-application\");\n      damageApplication.classList.add(\"dnd5e2\");\n      damageApplication.damages = aggregateDamageRolls(rolls, { respectProperties: true }).map(roll => ({\n        value: roll.total,\n        type: roll.options.type,\n        properties: new Set(roll.options.properties ?? [])\n      }));\n      html.querySelector(\".message-content\").appendChild(damageApplication);\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  /**\nSimplify damage roll information for use by damage tooltip.\n@param {DamageRoll} roll   The damage roll to simplify.\n@returns {object}          The object holding simplified damage roll data.\n@protected",
      "hasMultiplication": "",
      "i": "",
      "term": "",
      "value": "",
      "multiplier": "",
      "operator": "",
      "enchantmentProfile": "",
      "concentrationId": "",
      "enchantmentApplication": "",
      "afterElement": "",
      "content": "",
      "button": "",
      "effects": "",
      "effectApplication": "",
      "canApply": "",
      "canTarget": "",
      "token": "",
      "releaseOthers": "",
      "t": "",
      "lis": "",
      "uuids": "",
      "tokens": "",
      "html": "",
      "close": "",
      "tooltip": "",
      "gmUser": "",
      "releaseAll": "",
      "chatlog": "",
      "scene": "",
      "storedData": "",
      "flags": "",
      "messageType": ""
    },
    "Combat5e": {
      "expandedGroups": "",
      "ids": "",
      "combatant": "",
      "initiative": "",
      "options": "",
      "name": "",
      "groups": "",
      "key": "",
      "periods": ""
    },
    "Combatant5e": {
      "data": "",
      "create": "",
      "initiative": "",
      "results": "",
      "rollData": "",
      "updateTarget": "",
      "deltas": "",
      "message": "",
      "updates": "",
      "i": "",
      "update": "",
      "combatant": ""
    },
    "JournalEntryPage5e": {},
    "SystemFlags": {
      "dnd5e": "",
      "scope": "",
      "changes": "",
      "diff": ""
    },
    "PseudoDocument": {
      "parent": "",
      "static _apps": "",
      "static _sheets": "",
      "cls": "",
      "sheet": "",
      "options": "",
      "dragData": "",
      "uuid": "",
      "data": "",
      "label": "",
      "title": "",
      "type": "",
      "content": "",
      "html": "",
      "folder": "",
      "btn": "",
      "icon": "",
      "innerHTML": "",
      "tooltip": "",
      "fd": "",
      "createData": ""
    },
    "Scaling": {
      "increase": ""
    },
    "ModuleArt": {
      "suppressArt": "",
      "json": "",
      "settings": "",
      "pack": "",
      "entry": "",
      "img": "",
      "credit": "",
      "uuid": "",
      "info": "",
      "flags": "",
      "artPath": "",
      "unsorted": "",
      "configs": "",
      "mapping": "",
      "config": "",
      "priority": "",
      "maxPriority": ""
    },
    "EnchantmentRegisty": {
      "appliedEnchantments": "",
      "source": "",
      "a": "",
      "uuid": ""
    },
    "ItemRegistry": {
      "itemType": "",
      "items": "",
      "status": "",
      "STATUS_STATES": "",
      "initialized": "",
      "indexes": "",
      "identifier": "",
      "itemData": "",
      "name": "",
      "img": ""
    },
    "MessageRegistry": {
      "messages": "",
      "originMap": "",
      "ids": "",
      "id": "",
      "origin": "",
      "type": ""
    },
    "SpellListRegistry": {
      "bySpell": "",
      "byType": "",
      "loading": "",
      "lists": "",
      "size": "",
      "page": "",
      "type": "",
      "list": "",
      "uuid": ""
    },
    "SpellList": {
      "metadata": "",
      "REGISTRIES": "",
      "s": "",
      "spells": "",
      "unlinked": "",
      "added": ""
    },
    "SummonRegistry": {
      "creatures": "",
      "uuid": ""
    },
    "Tooltips5e": {
      "observer": "",
      "isActive": "",
      "tooltip": "",
      "type": "",
      "doc": "",
      "loading": "",
      "innerHTML": "",
      "c": "",
      "skillConfig": "",
      "abilityConfig": "",
      "label": "",
      "party": "",
      "context": "",
      "systemData": "",
      "ability": "",
      "customSkillData": "",
      "passive": "",
      "abilityMod": "",
      "data": "",
      "status": "",
      "direction": "",
      "pos": "",
      "dirs": "",
      "description": "",
      "event": ""
    }
  },
  "propertyTypes": {
    "Accordion": {
      "contentSelector": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "sections": {
        "type": "any",
        "isStatic": false
      },
      "ongoing": {
        "type": "any",
        "isStatic": false
      },
      "firstBind": {
        "type": "any",
        "isStatic": false
      },
      "collapsed": {
        "type": "any",
        "isStatic": false
      },
      "collapsedIndex": {
        "type": "any",
        "isStatic": false
      },
      "content": {
        "type": "any",
        "isStatic": false
      },
      "wrapper": {
        "type": "any",
        "isStatic": false
      },
      "_fullHeight": {
        "type": "any",
        "isStatic": false
      },
      "heading": {
        "type": "any",
        "isStatic": false
      },
      "animate": {
        "type": "any",
        "isStatic": false
      },
      "height": {
        "type": "any",
        "isStatic": false
      },
      "onEnd": {
        "type": "any",
        "isStatic": false
      },
      "entries": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActivityChoiceDialog": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "controlHint": {
        "type": "any",
        "isStatic": false
      },
      "activities": {
        "type": "any",
        "isStatic": false
      },
      "activity": {
        "type": "any",
        "isStatic": false
      },
      "resolve": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActivitySheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "static CLEAN_ARRAYS": {
        "type": "any",
        "isStatic": true
      },
      "tabGroups": {
        "type": "any",
        "isStatic": false
      },
      "expandedSections": {
        "type": "any",
        "isStatic": false
      },
      "tab": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "disabled": {
        "type": "any",
        "isStatic": false
      },
      "activationTypes": {
        "type": "any",
        "isStatic": false
      },
      "affectsPlaceholder": {
        "type": "any",
        "isStatic": false
      },
      "durationUnits": {
        "type": "any",
        "isStatic": false
      },
      "rangeUnits": {
        "type": "any",
        "isStatic": false
      },
      "canScale": {
        "type": "any",
        "isStatic": false
      },
      "consumptionTypeOptions": {
        "type": "any",
        "isStatic": false
      },
      "consumptionTargets": {
        "type": "any",
        "isStatic": false
      },
      "showTextTarget": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "showConsumeSpellSlot": {
        "type": "number",
        "isStatic": false
      },
      "showScaling": {
        "type": "any",
        "isStatic": false
      },
      "recoveryPeriods": {
        "type": "any",
        "isStatic": false
      },
      "recoveryTypes": {
        "type": "any",
        "isStatic": false
      },
      "usesRecovery": {
        "type": "string",
        "isStatic": false
      },
      "dimensions": {
        "type": "any",
        "isStatic": false
      },
      "appliedEffects": {
        "type": "any",
        "isStatic": false
      },
      "allEffects": {
        "type": "string",
        "isStatic": false
      },
      "effect": {
        "type": "any",
        "isStatic": false
      },
      "denominationOptions": {
        "type": "any",
        "isStatic": false
      },
      "scaleKey": {
        "type": "string",
        "isStatic": false
      },
      "scalingOptions": {
        "type": "any",
        "isStatic": false
      },
      "typeOptions": {
        "type": "any",
        "isStatic": false
      },
      "makePart": {
        "type": "any",
        "isStatic": false
      },
      "damageParts": {
        "type": "any",
        "isStatic": false
      },
      "placeholder": {
        "type": "any",
        "isStatic": false
      },
      "active": {
        "type": "any",
        "isStatic": false
      },
      "cssClass": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "primary": {
        "type": "any",
        "isStatic": false
      },
      "types": {
        "type": "any",
        "isStatic": false
      },
      "existingTypes": {
        "type": "any",
        "isStatic": false
      },
      "filteredTypes": {
        "type": "any",
        "isStatic": false
      },
      "effectData": {
        "type": "any",
        "isStatic": false
      },
      "periods": {
        "type": "string[]",
        "isStatic": false
      },
      "existingPeriods": {
        "type": "any",
        "isStatic": false
      },
      "filteredPeriods": {
        "type": "any",
        "isStatic": false
      },
      "consumption": {
        "type": "any",
        "isStatic": false
      },
      "parts": {
        "type": "any",
        "isStatic": false
      },
      "effectId": {
        "type": "any",
        "isStatic": false
      },
      "result": {
        "type": "any",
        "isStatic": false
      },
      "effects": {
        "type": "any",
        "isStatic": false
      },
      "recovery": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "string[]",
        "isStatic": false
      },
      "e": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActivityUsageDialog": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "activityId": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "used": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "hasConcentration": {
        "type": "any",
        "isStatic": false
      },
      "notes": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "existingConcentration": {
        "type": "any",
        "isStatic": false
      },
      "optional": {
        "type": "any",
        "isStatic": false
      },
      "containsLegendaryConsumption": {
        "type": "string",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "value": {
        "type": "boolean",
        "isStatic": false
      },
      "warn": {
        "type": "any",
        "isStatic": false
      },
      "addResources": {
        "type": "any",
        "isStatic": false
      },
      "isArray": {
        "type": "string",
        "isStatic": false
      },
      "hasConsumption": {
        "type": "any",
        "isStatic": false
      },
      "hasCreation": {
        "type": "any",
        "isStatic": false
      },
      "template": {
        "type": "any",
        "isStatic": false
      },
      "buttons": {
        "type": "any",
        "isStatic": false
      },
      "hasScaling": {
        "type": "any",
        "isStatic": false
      },
      "scale": {
        "type": "any",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "minimumLevel": {
        "type": "any",
        "isStatic": false
      },
      "maximumLevel": {
        "type": "any",
        "isStatic": false
      },
      "spellSlotOptions": {
        "type": "any",
        "isStatic": false
      },
      "_": {
        "type": "any",
        "isStatic": false
      },
      "spellSlots": {
        "type": "any",
        "isStatic": false
      },
      "consumeSlot": {
        "type": "boolean",
        "isStatic": false
      },
      "spellSlotValue": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "disabled": {
        "type": "number",
        "isStatic": false
      },
      "o": {
        "type": "any",
        "isStatic": false
      },
      "scaling": {
        "type": "number",
        "isStatic": false
      },
      "display": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      },
      "formData": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "any",
        "isStatic": false
      },
      "resources": {
        "type": "any",
        "isStatic": false
      },
      "dialog": {
        "type": "any",
        "isStatic": false
      },
      "event": {
        "type": "any",
        "isStatic": false
      }
    },
    "AttackSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "availableAbilities": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "string",
        "isStatic": false
      },
      "hasBaseDamage": {
        "type": "any",
        "isStatic": false
      },
      "attackTypeOptions": {
        "type": "any",
        "isStatic": false
      },
      "t": {
        "type": "any",
        "isStatic": false
      },
      "attackClassificationOptions": {
        "type": "any",
        "isStatic": false
      }
    },
    "CastSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "contentLink": {
        "type": "any",
        "isStatic": false
      },
      "levelOptions": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "any",
        "isStatic": false
      },
      "propertyOptions": {
        "type": "any",
        "isStatic": false
      },
      "placeholder": {
        "type": "any",
        "isStatic": false
      },
      "tabs": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "icon": {
        "type": "any",
        "isStatic": false
      }
    },
    "CheckSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "group": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "any",
        "isStatic": false
      },
      "associated": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "size": {
        "type": "number",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "associatedOptions": {
        "type": "any",
        "isStatic": false
      },
      "calculationOptions": {
        "type": "any",
        "isStatic": false
      }
    },
    "DamageSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      }
    },
    "EnchantSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "tabGroups": {
        "type": "any",
        "isStatic": false
      },
      "activityOptions": {
        "type": "any",
        "isStatic": false
      },
      "effectOptions": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "appliedEnchantments": {
        "type": "any",
        "isStatic": false
      },
      "allEnchantments": {
        "type": "string",
        "isStatic": false
      },
      "enchantableTypes": {
        "type": "any",
        "isStatic": false
      },
      "typeOptions": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "typeDataModel": {
        "type": "any",
        "isStatic": false
      },
      "categoryOptions": {
        "type": "string",
        "isStatic": false
      },
      "propertyOptions": {
        "type": "any",
        "isStatic": false
      },
      "tabs": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "icon": {
        "type": "any",
        "isStatic": false
      }
    },
    "EnchantUsageDialog": {
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "enchantments": {
        "type": "any",
        "isStatic": false
      },
      "hasCreation": {
        "type": "any",
        "isStatic": false
      },
      "enchantment": {
        "type": "any",
        "isStatic": false
      }
    },
    "ForwardSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "showConsumeSpellSlot": {
        "type": "any",
        "isStatic": false
      },
      "showScaling": {
        "type": "any",
        "isStatic": false
      },
      "activityOptions": {
        "type": "boolean",
        "isStatic": false
      }
    },
    "HealSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "typeOptions": {
        "type": "any",
        "isStatic": false
      },
      "scaleKey": {
        "type": "string",
        "isStatic": false
      },
      "scalingOptions": {
        "type": "any",
        "isStatic": false
      }
    },
    "OrderUsageDialog": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "build": {
        "type": "any",
        "isStatic": false
      },
      "costs": {
        "type": "any",
        "isStatic": false
      },
      "craft": {
        "type": "any",
        "isStatic": false
      },
      "order": {
        "type": "boolean",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "quantity": {
        "type": "any",
        "isStatic": false
      },
      "baseItem": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "sizes": {
        "type": "any",
        "isStatic": false
      },
      "index": {
        "type": "any",
        "isStatic": false
      },
      "description": {
        "type": "any",
        "isStatic": false
      },
      "days": {
        "type": "string",
        "isStatic": false
      },
      "buttons": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "duration": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "trade": {
        "type": "any",
        "isStatic": false
      },
      "isSelling": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "stock": {
        "type": "any",
        "isStatic": false
      },
      "sell": {
        "type": "any",
        "isStatic": false
      },
      "buy": {
        "type": "boolean",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "removable": {
        "type": "any",
        "isStatic": false
      },
      "doc": {
        "type": "any",
        "isStatic": false
      },
      "creatures": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "recalculateCosts": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      },
      "gold": {
        "type": "any",
        "isStatic": false
      },
      "k": {
        "type": "any",
        "isStatic": false
      }
    },
    "SaveSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "additionalSettings": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "any",
        "isStatic": false
      },
      "calculationOptions": {
        "type": "any",
        "isStatic": false
      },
      "onSaveOptions": {
        "type": "any",
        "isStatic": false
      }
    },
    "SummonSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "static CLEAN_ARRAYS": {
        "type": "any",
        "isStatic": true
      },
      "tabGroups": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "any",
        "isStatic": false
      },
      "creatureSizeOptions": {
        "type": "any",
        "isStatic": false
      },
      "creatureTypeOptions": {
        "type": "any",
        "isStatic": false
      },
      "profileModes": {
        "type": "any",
        "isStatic": false
      },
      "profiles": {
        "type": "string",
        "isStatic": false
      },
      "tabs": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "icon": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "profileId": {
        "type": "any",
        "isStatic": false
      },
      "profile": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      }
    },
    "SummonUsageDialog": {
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "profiles": {
        "type": "any",
        "isStatic": false
      },
      "hasCreation": {
        "type": "any",
        "isStatic": false
      },
      "summonsFields": {
        "type": "any",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "o": {
        "type": "any",
        "isStatic": false
      },
      "summonsProfile": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "cr": {
        "type": "any",
        "isStatic": false
      },
      "doc": {
        "type": "any",
        "isStatic": false
      },
      "count": {
        "type": "any",
        "isStatic": false
      }
    },
    "UtilitySheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      }
    },
    "BaseConfigSheet": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "advantageModeOptions": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "boolean",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActorSheet5eCharacter": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "resources": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "number",
        "isStatic": false
      },
      "max": {
        "type": "number",
        "isStatic": false
      },
      "classes": {
        "type": "any",
        "isStatic": false
      },
      "c": {
        "type": "any",
        "isStatic": false
      },
      "inventory": {
        "type": "any",
        "isStatic": false
      },
      "inventoryTypes": {
        "type": "any",
        "isStatic": false
      },
      "ctx": {
        "type": "Record<string, any>",
        "isStatic": false
      },
      "isStack": {
        "type": "number",
        "isStatic": false
      },
      "attunement": {
        "type": "any",
        "isStatic": false
      },
      "isExpanded": {
        "type": "any",
        "isStatic": false
      },
      "hasRecharge": {
        "type": "any",
        "isStatic": false
      },
      "hasUses": {
        "type": "any",
        "isStatic": false
      },
      "concealDetails": {
        "type": "boolean",
        "isStatic": false
      },
      "ungroup": {
        "type": "any",
        "isStatic": false
      },
      "group": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "totalWeight": {
        "type": "any",
        "isStatic": false
      },
      "spellbook": {
        "type": "any",
        "isStatic": false
      },
      "nPrepared": {
        "type": "any",
        "isStatic": false
      },
      "mode": {
        "type": "string",
        "isStatic": false
      },
      "maxLevelDelta": {
        "type": "any",
        "isStatic": false
      },
      "availableLevels": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "prefixedImage": {
        "type": "any",
        "isStatic": false
      },
      "identifier": {
        "type": "any",
        "isStatic": false
      },
      "subclass": {
        "type": "any",
        "isStatic": false
      },
      "subclassAdvancement": {
        "type": "any",
        "isStatic": false
      },
      "needsSubclass": {
        "type": "any",
        "isStatic": false
      },
      "message": {
        "type": "any",
        "isStatic": false
      },
      "features": {
        "type": "any",
        "isStatic": false
      },
      "inventoryFilters": {
        "type": "any",
        "isStatic": false
      },
      "preparedSpells": {
        "type": "any",
        "isStatic": false
      },
      "isAlways": {
        "type": "string",
        "isStatic": false
      },
      "isPrepared": {
        "type": "any",
        "isStatic": false
      },
      "toggleClass": {
        "type": "any",
        "isStatic": false
      },
      "toggleTitle": {
        "type": "any",
        "isStatic": false
      },
      "isActive": {
        "type": "any",
        "isStatic": false
      },
      "canToggle": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "string",
        "isStatic": false
      },
      "button": {
        "type": "any",
        "isStatic": false
      },
      "levels": {
        "type": "any",
        "isStatic": false
      },
      "err": {
        "type": "any",
        "isStatic": false
      },
      "cls": {
        "type": "any",
        "isStatic": false
      },
      "priorLevel": {
        "type": "any",
        "isStatic": false
      },
      "manager": {
        "type": "any",
        "isStatic": false
      }
    },
    "AbilityConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "proficiencyOptions": {
        "type": "any",
        "isStatic": false
      }
    },
    "ArmorClassConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "calculationOptions": {
        "type": "string",
        "isStatic": false
      },
      "value": {
        "type": "string",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "formula": {
        "type": "string",
        "isStatic": false
      },
      "dexterity": {
        "type": "any",
        "isStatic": false
      },
      "calculations": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "val": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "string",
        "isStatic": false
      }
    },
    "BaseProficiencyConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "uniqueId": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "keyPath": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "prefix": {
        "type": "any",
        "isStatic": false
      },
      "global": {
        "type": "any",
        "isStatic": false
      }
    },
    "ConcentrationConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "any",
        "isStatic": false
      },
      "global": {
        "type": "any",
        "isStatic": false
      }
    },
    "DamagesConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "bypasses": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "trait": {
        "type": "string",
        "isStatic": false
      },
      "bypassHint": {
        "type": "any",
        "isStatic": false
      },
      "hint": {
        "type": "any",
        "isStatic": false
      },
      "field": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      },
      "input": {
        "type": "any",
        "isStatic": false
      },
      "categoryChosen": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "icon": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      }
    },
    "DeathConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "global": {
        "type": "any",
        "isStatic": false
      }
    },
    "HabitatConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "any": {
        "type": "any",
        "isStatic": false
      },
      "custom": {
        "type": "any",
        "isStatic": false
      },
      "habitats": {
        "type": "string",
        "isStatic": false
      },
      "checked": {
        "type": "any",
        "isStatic": false
      },
      "rows": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      },
      "entry": {
        "type": "any",
        "isStatic": false
      },
      "subtype": {
        "type": "any",
        "isStatic": false
      }
    },
    "HitDiceConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "classes": {
        "type": "any",
        "isStatic": false
      },
      "valueField": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "string",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      },
      "classUpdates": {
        "type": "any",
        "isStatic": false
      }
    },
    "HitPointsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "mod": {
        "type": "any",
        "isStatic": false
      },
      "classes": {
        "type": "any",
        "isStatic": false
      },
      "effects": {
        "type": "any",
        "isStatic": false
      },
      "e": {
        "type": "any",
        "isStatic": false
      },
      "levels": {
        "type": "any",
        "isStatic": false
      },
      "levelMultiplier": {
        "type": "any",
        "isStatic": false
      },
      "showCalculation": {
        "type": "any",
        "isStatic": false
      },
      "showMaxInCalculation": {
        "type": "string",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "clone": {
        "type": "any",
        "isStatic": false
      },
      "maxDelta": {
        "type": "any",
        "isStatic": false
      },
      "current": {
        "type": "any",
        "isStatic": false
      },
      "hitDie": {
        "type": "any",
        "isStatic": false
      }
    },
    "InitiativeConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "defaultAbility": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "abilityConfig": {
        "type": "any",
        "isStatic": false
      },
      "flags": {
        "type": "any",
        "isStatic": false
      }
    },
    "LanguagesConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "unitOptions": {
        "type": "any",
        "isStatic": false
      },
      "communication": {
        "type": "any",
        "isStatic": false
      }
    },
    "SkillToolConfig": {
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "trait": {
        "type": "string",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "any",
        "isStatic": false
      },
      "proficiencyOptions": {
        "type": "any",
        "isStatic": false
      },
      "section": {
        "type": "string",
        "isStatic": false
      },
      "skill": {
        "type": "string",
        "isStatic": false
      }
    },
    "SkillsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "skills": {
        "type": "any",
        "isStatic": false
      },
      "rows": {
        "type": "any",
        "isStatic": false
      },
      "categoryChosen": {
        "type": "any",
        "isStatic": false
      },
      "skill": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "total": {
        "type": "any",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      },
      "e": {
        "type": "any",
        "isStatic": false
      }
    },
    "SpellSlotsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "overrides": {
        "type": "any",
        "isStatic": false
      },
      "hasSpell": {
        "type": "string",
        "isStatic": false
      }
    },
    "ToolsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "categoryChosen": {
        "type": "any",
        "isStatic": false
      },
      "tool": {
        "type": "any",
        "isStatic": false
      },
      "hasEntry": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "total": {
        "type": "any",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      },
      "e": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      }
    },
    "TraitsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "uniqueId": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "keyPath": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "checkbox": {
        "type": "any",
        "isStatic": false
      },
      "chosen": {
        "type": "any",
        "isStatic": false
      },
      "choices": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "other": {
        "type": "any",
        "isStatic": false
      },
      "OTHER": {
        "type": "any",
        "isStatic": false
      },
      "categoryChosen": {
        "type": "any",
        "isStatic": false
      },
      "disabled": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      }
    },
    "TreasureConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "any": {
        "type": "any",
        "isStatic": false
      },
      "treasure": {
        "type": "string",
        "isStatic": false
      }
    },
    "WeaponsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "categoryChosen": {
        "type": "any",
        "isStatic": false
      },
      "mastery": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActorAbilityConfig": {},
    "ActorArmorConfig": {},
    "ActorConcentrationConfig": {},
    "DamageModificationConfig": {
      "options": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActorHitDiceConfig": {},
    "ActorHitPointsConfig": {},
    "ActorInitiativeConfig": {},
    "ActorMovementConfig": {},
    "ProficiencyConfig": {
      "trait": {
        "type": "string",
        "isStatic": false
      }
    },
    "ActorSensesConfig": {},
    "ActorSkillsConfig": {
      "options": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActorSpellSlotsConfig": {},
    "ToolSelector": {
      "options": {
        "type": "any",
        "isStatic": false
      }
    },
    "TraitSelector": {
      "options": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActorTypeConfig": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "keyPath": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActorSheet5eNPC": {
      "context": {
        "type": "any",
        "isStatic": false
      },
      "cr": {
        "type": "any",
        "isStatic": false
      },
      "crLabels": {
        "type": "any",
        "isStatic": false
      },
      "classSpellcasting": {
        "type": "any",
        "isStatic": false
      },
      "features": {
        "type": "any",
        "isStatic": false
      },
      "maxLevelDelta": {
        "type": "any",
        "isStatic": false
      },
      "ctx": {
        "type": "Record<string, any>",
        "isStatic": false
      },
      "isStack": {
        "type": "number",
        "isStatic": false
      },
      "isExpanded": {
        "type": "any",
        "isStatic": false
      },
      "hasRecharge": {
        "type": "any",
        "isStatic": false
      },
      "hasUses": {
        "type": "any",
        "isStatic": false
      },
      "hasTarget": {
        "type": "any",
        "isStatic": false
      },
      "canToggle": {
        "type": "any",
        "isStatic": false
      },
      "totalWeight": {
        "type": "any",
        "isStatic": false
      },
      "isPassive": {
        "type": "any",
        "isStatic": false
      },
      "group": {
        "type": "any",
        "isStatic": false
      },
      "ungroup": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "spellbook": {
        "type": "any",
        "isStatic": false
      },
      "inventoryFilters": {
        "type": "any",
        "isStatic": false
      },
      "ac": {
        "type": "any",
        "isStatic": false
      },
      "calc": {
        "type": "string",
        "isStatic": false
      },
      "action": {
        "type": "string",
        "isStatic": false
      },
      "button": {
        "type": "any",
        "isStatic": false
      },
      "editor": {
        "type": "any",
        "isStatic": false
      },
      "initial": {
        "type": "any",
        "isStatic": false
      },
      "crs": {
        "type": "any",
        "isStatic": false
      },
      "crv": {
        "type": "any",
        "isStatic": false
      }
    },
    "BaseRestDialog": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "duration": {
        "type": "any",
        "isStatic": false
      },
      "rested": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "string",
        "isStatic": false
      },
      "app": {
        "type": "any",
        "isStatic": false
      }
    },
    "LongRestDialog": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "Record<string, any>",
        "isStatic": false
      }
    },
    "ShortRestDialog": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "string",
        "isStatic": false
      },
      "autoRoll": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "hitDice": {
        "type": "any",
        "isStatic": false
      },
      "denomination": {
        "type": "any",
        "isStatic": false
      },
      "denom": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "Record<string, any>",
        "isStatic": false
      }
    },
    "ActorSheetFlags": {
      "data": {
        "type": "any",
        "isStatic": false
      },
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "classes": {
        "type": "any",
        "isStatic": false
      },
      "flags": {
        "type": "any",
        "isStatic": false
      },
      "bonuses": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "baseData": {
        "type": "object",
        "isStatic": false
      },
      "flag": {
        "type": "any",
        "isStatic": false
      },
      "isCheckbox": {
        "type": "any",
        "isStatic": false
      },
      "isSelect": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "src": {
        "type": "any",
        "isStatic": false
      },
      "updateData": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActorSheet5eVehicle": {
      "static unsupportedItemTypes": {
        "type": "any",
        "isStatic": true
      },
      "largestPrimary": {
        "type": "object",
        "isStatic": false
      },
      "isCrewed": {
        "type": "any",
        "isStatic": false
      },
      "toggleClass": {
        "type": "any",
        "isStatic": false
      },
      "toggleTitle": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "cover": {
        "type": "string",
        "isStatic": false
      },
      "cargoColumns": {
        "type": "any",
        "isStatic": false
      },
      "equipmentColumns": {
        "type": "any",
        "isStatic": false
      },
      "features": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "ctx": {
        "type": "Record<string, any>",
        "isStatic": false
      },
      "canToggle": {
        "type": "any",
        "isStatic": false
      },
      "isExpanded": {
        "type": "any",
        "isStatic": false
      },
      "hasUses": {
        "type": "any",
        "isStatic": false
      },
      "cargo": {
        "type": "any",
        "isStatic": false
      },
      "isCargo": {
        "type": "boolean",
        "isStatic": false
      },
      "act": {
        "type": "any",
        "isStatic": false
      },
      "inventoryFilters": {
        "type": "any",
        "isStatic": false
      },
      "encumbrance": {
        "type": "any",
        "isStatic": false
      },
      "tab": {
        "type": "any",
        "isStatic": false
      },
      "evt": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "row": {
        "type": "any",
        "isStatic": false
      },
      "idx": {
        "type": "any",
        "isStatic": false
      },
      "property": {
        "type": "any",
        "isStatic": false
      },
      "entry": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "detail": {
        "type": "object",
        "isStatic": false
      },
      "cargoCollection": {
        "type": "any",
        "isStatic": false
      },
      "cargoTypes": {
        "type": "any",
        "isStatic": false
      }
    },
    "AbilityScoreImprovementConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "abilities": {
        "type": "any",
        "isStatic": false
      },
      "fixed": {
        "type": "any",
        "isStatic": false
      },
      "locked": {
        "type": "any",
        "isStatic": false
      },
      "points": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "any",
        "isStatic": false
      },
      "input": {
        "type": "any",
        "isStatic": false
      },
      "parent": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "string",
        "isStatic": false
      }
    },
    "AbilityScoreImprovementFlow": {
      "assignments": {
        "type": "any",
        "isStatic": false
      },
      "static _customElements": {
        "type": "any",
        "isStatic": true
      },
      "featUuid": {
        "type": "any",
        "isStatic": false
      },
      "feat": {
        "type": "any",
        "isStatic": false
      },
      "points": {
        "type": "any",
        "isStatic": false
      },
      "available": {
        "type": "any",
        "isStatic": false
      },
      "formatter": {
        "type": "any",
        "isStatic": false
      },
      "lockImprovement": {
        "type": "any",
        "isStatic": false
      },
      "abilities": {
        "type": "any",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "assignment": {
        "type": "any",
        "isStatic": false
      },
      "fixed": {
        "type": "any",
        "isStatic": false
      },
      "locked": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "min": {
        "type": "any",
        "isStatic": false
      },
      "modernRules": {
        "type": "string",
        "isStatic": false
      },
      "pluralRules": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "any",
        "isStatic": false
      },
      "input": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "string",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      },
      "filters": {
        "type": "any",
        "isStatic": false
      },
      "result": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      }
    },
    "AdvancementConfig": {
      "advancement": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "levels": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "string",
        "isStatic": false
      },
      "uuidToDelete": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "configuration": {
        "type": "any",
        "isStatic": false
      },
      "keep": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "existingItems": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "advancementId": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "action": {
        "type": "any",
        "isStatic": false
      },
      "force": {
        "type": "any",
        "isStatic": false
      }
    },
    "AdvancementConfirmationDialog": {
      "class": {
        "type": "any",
        "isStatic": false
      },
      "dialog": {
        "type": "any",
        "isStatic": false
      }
    },
    "AdvancementFlow": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "_advancementId": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "any",
        "isStatic": false
      },
      "retainedData": {
        "type": "any",
        "isStatic": false
      },
      "static _customElements": {
        "type": "any",
        "isStatic": true
      }
    },
    "AdvancementManager": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "clone": {
        "type": "any",
        "isStatic": false
      },
      "visualizer": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "advancing": {
        "type": "any",
        "isStatic": false
      },
      "parts": {
        "type": "Actor5e",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "any",
        "isStatic": false
      },
      "visibleSteps": {
        "type": "any",
        "isStatic": false
      },
      "visibleIndex": {
        "type": "any",
        "isStatic": false
      },
      "stepIndex": {
        "type": "any",
        "isStatic": false
      },
      "steps": {
        "type": "any",
        "isStatic": false
      },
      "nextIndex": {
        "type": "any",
        "isStatic": false
      },
      "clonedItem": {
        "type": "any",
        "isStatic": false
      },
      "currentLevel": {
        "type": "any",
        "isStatic": false
      },
      "minimumLevel": {
        "type": "any",
        "isStatic": false
      },
      "oldFlows": {
        "type": "any",
        "isStatic": false
      },
      "flow": {
        "type": "any",
        "isStatic": false
      },
      "advancementArray": {
        "type": "any",
        "isStatic": false
      },
      "a": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "newFlows": {
        "type": "any",
        "isStatic": false
      },
      "dataClone": {
        "type": "any",
        "isStatic": false
      },
      "_id": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "targetLevel": {
        "type": "any",
        "isStatic": false
      },
      "l": {
        "type": "any",
        "isStatic": false
      },
      "flows": {
        "type": "any",
        "isStatic": false
      },
      "f": {
        "type": "any",
        "isStatic": false
      },
      "advancement": {
        "type": "any",
        "isStatic": false
      },
      "raceItem": {
        "type": "any",
        "isStatic": false
      },
      "pushSteps": {
        "type": "any",
        "isStatic": false
      },
      "getItemFlows": {
        "type": "any",
        "isStatic": false
      },
      "offset": {
        "type": "any",
        "isStatic": false
      },
      "classLevel": {
        "type": "any",
        "isStatic": false
      },
      "characterLevel": {
        "type": "any",
        "isStatic": false
      },
      "stepData": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "forced": {
        "type": "number",
        "isStatic": false
      },
      "allowed": {
        "type": "any",
        "isStatic": false
      },
      "automaticData": {
        "type": "string",
        "isStatic": false
      },
      "_element": {
        "type": "any",
        "isStatic": false
      },
      "class": {
        "type": "any",
        "isStatic": false
      },
      "disabled": {
        "type": "any",
        "isStatic": false
      },
      "preEmbeddedItems": {
        "type": "any",
        "isStatic": false
      },
      "automatic": {
        "type": "any",
        "isStatic": false
      },
      "initialIds": {
        "type": "any",
        "isStatic": false
      },
      "preIds": {
        "type": "any",
        "isStatic": false
      },
      "postIds": {
        "type": "any",
        "isStatic": false
      },
      "addedIds": {
        "type": "any",
        "isStatic": false
      },
      "deletedIds": {
        "type": "any",
        "isStatic": false
      },
      "handledLevel": {
        "type": "any",
        "isStatic": false
      },
      "idx": {
        "type": "any",
        "isStatic": false
      },
      "thisLevel": {
        "type": "any",
        "isStatic": false
      },
      "nextLevel": {
        "type": "any",
        "isStatic": false
      },
      "render": {
        "type": "boolean",
        "isStatic": false
      },
      "modifiedIds": {
        "type": "any",
        "isStatic": false
      },
      "restart": {
        "type": "any",
        "isStatic": false
      },
      "s": {
        "type": "any",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "id": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      }
    },
    "AdvancementVisualizer": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "steps": {
        "type": "any",
        "isStatic": false
      }
    },
    "AdvancementMigrationDialog": {
      "advancementContext": {
        "type": "number",
        "isStatic": false
      },
      "dialog": {
        "type": "any",
        "isStatic": false
      }
    },
    "AdvancementSelection": {
      "dialogData": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "Item5e",
        "isStatic": false
      },
      "advancement": {
        "type": "any",
        "isStatic": false
      },
      "types": {
        "type": "any",
        "isStatic": false
      },
      "submit": {
        "type": "any",
        "isStatic": false
      },
      "disabled": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "Promise<any>",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      }
    },
    "HitPointsFlow": {
      "source": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "useAverage": {
        "type": "string",
        "isStatic": false
      },
      "lastValue": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "number",
        "isStatic": false
      },
      "event": {
        "type": "any",
        "isStatic": false
      },
      "disabled": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "errorType": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemChoiceConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "any",
        "isStatic": false
      },
      "choices": {
        "type": "any",
        "isStatic": false
      },
      "levelRestrictionOptions": {
        "type": "any",
        "isStatic": false
      },
      "showContainerWarning": {
        "type": "string",
        "isStatic": false
      },
      "showSpellConfig": {
        "type": "string",
        "isStatic": false
      },
      "showRequireSpellSlot": {
        "type": "any",
        "isStatic": false
      },
      "typeOptions": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "typeRestriction": {
        "type": "any",
        "isStatic": false
      },
      "pool": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemChoiceFlow": {
      "replacement": {
        "type": "any",
        "isStatic": false
      },
      "selected": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "dropped": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "levelConfig": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "replaceable": {
        "type": "any",
        "isStatic": false
      },
      "noReplacement": {
        "type": "any",
        "isStatic": false
      },
      "choices": {
        "type": "any",
        "isStatic": false
      },
      "previousLevels": {
        "type": "any",
        "isStatic": false
      },
      "previouslySelected": {
        "type": "any",
        "isStatic": false
      },
      "added": {
        "type": "any",
        "isStatic": false
      },
      "id": {
        "type": "any",
        "isStatic": false
      },
      "replaced": {
        "type": "any",
        "isStatic": false
      },
      "match": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "disabled": {
        "type": "any",
        "isStatic": false
      },
      "validLevel": {
        "type": "any",
        "isStatic": false
      },
      "available": {
        "type": "any",
        "isStatic": false
      },
      "abilities": {
        "type": "any",
        "isStatic": false
      },
      "tagName": {
        "type": "string",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "name": {
        "type": "string",
        "isStatic": false
      },
      "uuidToDelete": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "spellLevel": {
        "type": "any",
        "isStatic": false
      },
      "spellcasting": {
        "type": "any",
        "isStatic": false
      },
      "progression": {
        "type": "any",
        "isStatic": false
      },
      "maxSpellLevel": {
        "type": "any",
        "isStatic": false
      },
      "spells": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemGrantConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "abilityOptions": {
        "type": "any",
        "isStatic": false
      },
      "showContainerWarning": {
        "type": "string",
        "isStatic": false
      },
      "showSpellConfig": {
        "type": "string",
        "isStatic": false
      },
      "showRequireSpellSlot": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemGrantFlow": {
      "config": {
        "type": "any",
        "isStatic": false
      },
      "added": {
        "type": "any",
        "isStatic": false
      },
      "checked": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "optional": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "retainedData": {
        "type": "any",
        "isStatic": false
      }
    },
    "ScaleValueConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "distanceOptions": {
        "type": "any",
        "isStatic": false
      },
      "identifier": {
        "type": "any",
        "isStatic": false
      },
      "hint": {
        "type": "any",
        "isStatic": false
      },
      "levels": {
        "type": "any",
        "isStatic": false
      },
      "lastValue": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "className": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "slug": {
        "type": "any",
        "isStatic": false
      },
      "k": {
        "type": "any",
        "isStatic": false
      },
      "scale": {
        "type": "any",
        "isStatic": false
      },
      "typeChange": {
        "type": "any",
        "isStatic": false
      },
      "OriginalType": {
        "type": "any",
        "isStatic": false
      },
      "NewType": {
        "type": "any",
        "isStatic": false
      },
      "original": {
        "type": "any",
        "isStatic": false
      }
    },
    "ScaleValueFlow": {},
    "SizeConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "sizes": {
        "type": "any",
        "isStatic": false
      }
    },
    "SizeFlow": {
      "sizes": {
        "type": "any",
        "isStatic": false
      },
      "size": {
        "type": "number",
        "isStatic": false
      }
    },
    "SubclassFlow": {
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "subclass": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "any",
        "isStatic": false
      },
      "filters": {
        "type": "any",
        "isStatic": false
      },
      "result": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      }
    },
    "TraitConfig": {
      "selected": {
        "type": "any",
        "isStatic": false
      },
      "trait": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "pool": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "object",
        "isStatic": false
      },
      "grants": {
        "type": "any",
        "isStatic": false
      },
      "choices": {
        "type": "any",
        "isStatic": false
      },
      "chosen": {
        "type": "any",
        "isStatic": false
      },
      "count": {
        "type": "any",
        "isStatic": false
      },
      "selectedIndex": {
        "type": "any",
        "isStatic": false
      },
      "rep": {
        "type": "any",
        "isStatic": false
      },
      "disableAllowReplacements": {
        "type": "any",
        "isStatic": false
      },
      "traitConfig": {
        "type": "number",
        "isStatic": false
      },
      "title": {
        "type": "any",
        "isStatic": false
      },
      "icon": {
        "type": "any",
        "isStatic": false
      },
      "hint": {
        "type": "any",
        "isStatic": false
      },
      "mode": {
        "type": "string",
        "isStatic": false
      },
      "toCheck": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "boolean",
        "isStatic": false
      },
      "input": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "string",
        "isStatic": false
      },
      "types": {
        "type": "any",
        "isStatic": false
      },
      "validTraitTypes": {
        "type": "any",
        "isStatic": false
      },
      "configuration": {
        "type": "any",
        "isStatic": false
      },
      "prefix": {
        "type": "any",
        "isStatic": false
      },
      "filteredSelected": {
        "type": "any",
        "isStatic": false
      },
      "current": {
        "type": "any",
        "isStatic": false
      },
      "filteredPrevious": {
        "type": "any",
        "isStatic": false
      },
      "c": {
        "type": "any",
        "isStatic": false
      },
      "checkKey": {
        "type": "string",
        "isStatic": false
      }
    },
    "TraitFlow": {
      "available": {
        "type": "any",
        "isStatic": false
      },
      "s": {
        "type": "any",
        "isStatic": false
      },
      "addedTrait": {
        "type": "any",
        "isStatic": false
      },
      "tag": {
        "type": "any",
        "isStatic": false
      },
      "chosen": {
        "type": "any",
        "isStatic": false
      },
      "existingChosen": {
        "type": "Set<string>",
        "isStatic": false
      },
      "set": {
        "type": "any",
        "isStatic": false
      },
      "size": {
        "type": "number",
        "isStatic": false
      },
      "config": {
        "type": "Set<string>",
        "isStatic": false
      },
      "count": {
        "type": "any",
        "isStatic": false
      },
      "selectorShown": {
        "type": "any",
        "isStatic": false
      },
      "slots": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      }
    },
    "Dialog5e": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "tag": {
        "type": "HTMLFormElement|void",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "partId": {
        "type": "this",
        "isStatic": false
      },
      "buttons": {
        "type": "any",
        "isStatic": false
      }
    },
    "PseudoDocumentSheet": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "documentId": {
        "type": "any",
        "isStatic": false
      },
      "documentType": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "frame": {
        "type": "any",
        "isStatic": false
      },
      "autocomplete": {
        "type": "any",
        "isStatic": false
      },
      "copyLabel": {
        "type": "any",
        "isStatic": false
      },
      "copyId": {
        "type": "any",
        "isStatic": false
      },
      "id": {
        "type": "number",
        "isStatic": false
      },
      "type": {
        "type": "number",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      },
      "input": {
        "type": "any",
        "isStatic": false
      },
      "updateData": {
        "type": "any",
        "isStatic": false
      },
      "event": {
        "type": "any",
        "isStatic": false
      },
      "formData": {
        "type": "any",
        "isStatic": false
      }
    },
    "Award": {
      "_options": {
        "type": "any",
        "isStatic": false
      },
      "origin": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "primaryParty": {
        "type": "any",
        "isStatic": false
      },
      "u": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "string",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "currency": {
        "type": "any",
        "isStatic": false
      },
      "destinations": {
        "type": "any",
        "isStatic": false
      },
      "each": {
        "type": "any",
        "isStatic": false
      },
      "hideXP": {
        "type": "string",
        "isStatic": false
      },
      "noPrimaryParty": {
        "type": "any",
        "isStatic": false
      },
      "xp": {
        "type": "any",
        "isStatic": false
      },
      "icons": {
        "type": "any",
        "isStatic": false
      },
      "doc": {
        "type": "any",
        "isStatic": false
      },
      "formData": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "valid": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "results": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "originCurrency": {
        "type": "any",
        "isStatic": false
      },
      "remainingDestinations": {
        "type": "any",
        "isStatic": false
      },
      "destinationUpdates": {
        "type": "any",
        "isStatic": false
      },
      "result": {
        "type": "Record<string, any>",
        "isStatic": false
      },
      "amount": {
        "type": "any",
        "isStatic": false
      },
      "originUpdate": {
        "type": "any",
        "isStatic": false
      },
      "perDestination": {
        "type": "any",
        "isStatic": false
      },
      "cls": {
        "type": "any",
        "isStatic": false
      },
      "messages": {
        "type": "any",
        "isStatic": false
      },
      "entries": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "class": {
        "type": "any",
        "isStatic": false
      },
      "content": {
        "type": "any",
        "isStatic": false
      },
      "whisperTargets": {
        "type": "any",
        "isStatic": false
      },
      "whisper": {
        "type": "any",
        "isStatic": false
      },
      "messageData": {
        "type": "any",
        "isStatic": false
      },
      "static COMMAND_PATTERN": {
        "type": "any",
        "isStatic": true
      },
      "static VALUE_PATTERN": {
        "type": "any",
        "isStatic": true
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "savedDestinations": {
        "type": "any",
        "isStatic": false
      },
      "app": {
        "type": "any",
        "isStatic": false
      },
      "command": {
        "type": "any",
        "isStatic": false
      },
      "party": {
        "type": "any",
        "isStatic": false
      },
      "unrecognized": {
        "type": "any",
        "isStatic": false
      },
      "part": {
        "type": "boolean",
        "isStatic": false
      }
    },
    "BastionConfig": {},
    "CompendiumBrowserSourceConfig": {},
    "CompendiumBrowser": {
      "filters": {
        "type": "any",
        "isStatic": false
      },
      "_mode": {
        "type": "any",
        "isStatic": false
      },
      "isAdvanced": {
        "type": "any",
        "isStatic": false
      },
      "tab": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "static TABS": {
        "type": "any",
        "isStatic": true
      },
      "static MODES": {
        "type": "any",
        "isStatic": true
      },
      "static BATCHING": {
        "type": "any",
        "isStatic": true
      },
      "static SEARCH_DELAY": {
        "type": "any",
        "isStatic": true
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "resultIndex": {
        "type": "any",
        "isStatic": false
      },
      "renderThrottle": {
        "type": "any",
        "isStatic": false
      },
      "selected": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "CompendiumBrowserTabDescriptor5e[]",
        "isStatic": false
      },
      "min": {
        "type": "any",
        "isStatic": false
      },
      "_debouncedSearch": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "dataModels": {
        "type": "any",
        "isStatic": false
      },
      "filterDefinitions": {
        "type": "any",
        "isStatic": false
      },
      "k": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "displaySelection": {
        "type": "any",
        "isStatic": false
      },
      "invalid": {
        "type": "any",
        "isStatic": false
      },
      "suffix": {
        "type": "any",
        "isStatic": false
      },
      "summary": {
        "type": "any",
        "isStatic": false
      },
      "showModeToggle": {
        "type": "any",
        "isStatic": false
      },
      "isLocked": {
        "type": "any",
        "isStatic": false
      },
      "types": {
        "type": "any",
        "isStatic": false
      },
      "documentClass": {
        "type": "any",
        "isStatic": false
      },
      "partId": {
        "type": "string",
        "isStatic": false
      },
      "sort": {
        "type": "any",
        "isStatic": false
      },
      "results": {
        "type": "any",
        "isStatic": false
      },
      "tabs": {
        "type": "any",
        "isStatic": false
      },
      "advanced": {
        "type": "any",
        "isStatic": false
      },
      "activeTab": {
        "type": "any",
        "isStatic": false
      },
      "active": {
        "type": "any",
        "isStatic": false
      },
      "frame": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "any",
        "isStatic": false
      },
      "subtitle": {
        "type": "any",
        "isStatic": false
      },
      "html": {
        "type": "any",
        "isStatic": false
      },
      "template": {
        "type": "any",
        "isStatic": false
      },
      "innerHTML": {
        "type": "any",
        "isStatic": false
      },
      "element": {
        "type": "any",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      },
      "tooltipClass": {
        "type": "any",
        "isStatic": false
      },
      "rendered": {
        "type": "any",
        "isStatic": false
      },
      "batchEnd": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "hidden": {
        "type": "any",
        "isStatic": false
      },
      "part": {
        "type": "any",
        "isStatic": false
      },
      "sources": {
        "type": "any",
        "isStatic": false
      },
      "id": {
        "type": "any",
        "isStatic": false
      },
      "locked": {
        "type": "any",
        "isStatic": false
      },
      "filter": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "CompendiumBrowserTabDescriptor5e[]",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "event": {
        "type": "number",
        "isStatic": false
      },
      "group": {
        "type": "any",
        "isStatic": false
      },
      "children": {
        "type": "any",
        "isStatic": false
      },
      "e": {
        "type": "boolean",
        "isStatic": false
      },
      "indeterminate": {
        "type": "any",
        "isStatic": false
      },
      "checked": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "string",
        "isStatic": false
      },
      "handler": {
        "type": "any",
        "isStatic": false
      },
      "batchStart": {
        "type": "any",
        "isStatic": false
      },
      "input": {
        "type": "any",
        "isStatic": false
      },
      "pr": {
        "type": "any",
        "isStatic": false
      },
      "existingValue": {
        "type": "any",
        "isStatic": false
      },
      "tagName": {
        "type": "string",
        "isStatic": false
      },
      "indexFields": {
        "type": "any",
        "isStatic": false
      },
      "documents": {
        "type": "any",
        "isStatic": false
      },
      "sortFunc": {
        "type": "string",
        "isStatic": false
      },
      "def": {
        "type": "any",
        "isStatic": false
      },
      "choices": {
        "type": "any",
        "isStatic": false
      },
      "_blank": {
        "type": "any",
        "isStatic": false
      },
      "v": {
        "type": "number",
        "isStatic": false
      },
      "button": {
        "type": "CompendiumBrowserTabDescriptor5e[]",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "headerActions": {
        "type": "any",
        "isStatic": false
      },
      "className": {
        "type": "any",
        "isStatic": false
      },
      "final": {
        "type": "any",
        "isStatic": false
      },
      "secondConfig": {
        "type": "any",
        "isStatic": false
      },
      "finalConfig": {
        "type": "any",
        "isStatic": false
      }
    },
    "AdoptedStyleSheetElement": {
      "static _stylesheets": {
        "type": "any",
        "isStatic": true
      },
      "static CSS": {
        "type": "any",
        "isStatic": true
      },
      "sheet": {
        "type": "any",
        "isStatic": false
      }
    },
    "ChatTrayElement": {
      "static observedAttributes": {
        "type": "any",
        "isStatic": true
      },
      "name": {
        "type": "string",
        "isStatic": false
      },
      "popout": {
        "type": "any",
        "isStatic": false
      },
      "height": {
        "type": "any",
        "isStatic": false
      }
    },
    "CopyableTextElement": {
      "controller": {
        "type": "any",
        "isStatic": false
      },
      "button": {
        "type": "any",
        "isStatic": false
      },
      "ariaLabel": {
        "type": "any",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      },
      "innerHTML": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      }
    },
    "EffectsElement": {
      "app": {
        "type": "any",
        "isStatic": false
      },
      "event": {
        "type": "any",
        "isStatic": false
      },
      "MenuCls": {
        "type": "any",
        "isStatic": false
      },
      "element": {
        "type": "any",
        "isStatic": false
      },
      "menuItems": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "identified": {
        "type": "boolean",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "hidden": {
        "type": "any",
        "isStatic": false
      },
      "localizationPrefix": {
        "type": "any",
        "isStatic": false
      },
      "isConcentrationEffect": {
        "type": "Application",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "isFavorited": {
        "type": "any",
        "isStatic": false
      },
      "class": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "this",
        "isStatic": false
      },
      "dataset": {
        "type": "any",
        "isStatic": false
      },
      "effect": {
        "type": "any",
        "isStatic": false
      },
      "existing": {
        "type": "any",
        "isStatic": false
      },
      "li": {
        "type": "any",
        "isStatic": false
      },
      "isActor": {
        "type": "any",
        "isStatic": false
      },
      "isEnchantment": {
        "type": "any",
        "isStatic": false
      },
      "effectType": {
        "type": "string",
        "isStatic": false
      },
      "doc": {
        "type": "any",
        "isStatic": false
      }
    },
    "EnchantmentApplicationElement": {
      "messageId": {
        "type": "any",
        "isStatic": false
      },
      "chatMessage": {
        "type": "any",
        "isStatic": false
      },
      "div": {
        "type": "any",
        "isStatic": false
      },
      "innerHTML": {
        "type": "any",
        "isStatic": false
      },
      "dropArea": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "scaling": {
        "type": "any",
        "isStatic": false
      },
      "activity": {
        "type": "any",
        "isStatic": false
      },
      "maxTargets": {
        "type": "any",
        "isStatic": false
      },
      "countArea": {
        "type": "any",
        "isStatic": false
      },
      "enchantedItems": {
        "type": "any",
        "isStatic": false
      },
      "enchantmentUuid": {
        "type": "any",
        "isStatic": false
      },
      "control": {
        "type": "any",
        "isStatic": false
      },
      "ariaLabel": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "any",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      },
      "innerText": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "effect": {
        "type": "any",
        "isStatic": false
      },
      "droppedItem": {
        "type": "any",
        "isStatic": false
      },
      "errors": {
        "type": "any",
        "isStatic": false
      },
      "err": {
        "type": "any",
        "isStatic": false
      },
      "concentrationId": {
        "type": "any",
        "isStatic": false
      },
      "concentration": {
        "type": "any",
        "isStatic": false
      },
      "effectData": {
        "type": "any",
        "isStatic": false
      },
      "origin": {
        "type": "any",
        "isStatic": false
      },
      "applied": {
        "type": "any",
        "isStatic": false
      },
      "enchantment": {
        "type": "any",
        "isStatic": false
      }
    },
    "InventoryElement": {
      "app": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "inputmode": {
        "type": "any",
        "isStatic": false
      },
      "event": {
        "type": "any",
        "isStatic": false
      },
      "e": {
        "type": "any",
        "isStatic": false
      },
      "MenuCls": {
        "type": "any",
        "isStatic": false
      },
      "filterLists": {
        "type": "any",
        "isStatic": false
      },
      "state": {
        "type": "any",
        "isStatic": false
      },
      "set": {
        "type": "any",
        "isStatic": false
      },
      "filters": {
        "type": "any",
        "isStatic": false
      },
      "f": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "elementMap": {
        "type": "any",
        "isStatic": false
      },
      "el": {
        "type": "any",
        "isStatic": false
      },
      "hidden": {
        "type": "any",
        "isStatic": false
      },
      "compendiumLocked": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "li": {
        "type": "string",
        "isStatic": false
      },
      "class": {
        "type": "any",
        "isStatic": false
      },
      "mode": {
        "type": "string",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "isFavorited": {
        "type": "any",
        "isStatic": false
      },
      "expanded": {
        "type": "any",
        "isStatic": false
      },
      "itemId": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "min": {
        "type": "string",
        "isStatic": false
      },
      "max": {
        "type": "string",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "input": {
        "type": "any",
        "isStatic": false
      },
      "activity": {
        "type": "any",
        "isStatic": false
      },
      "result": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "string",
        "isStatic": false
      },
      "button": {
        "type": "any",
        "isStatic": false
      },
      "inventoryEvent": {
        "type": "any",
        "isStatic": false
      },
      "itemData": {
        "type": "any",
        "isStatic": false
      },
      "summary": {
        "type": "any",
        "isStatic": false
      },
      "chatData": {
        "type": "any",
        "isStatic": false
      },
      "menuItems": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemListControlsElement": {
      "app": {
        "type": "any",
        "isStatic": false
      },
      "list": {
        "type": "any",
        "isStatic": false
      },
      "state": {
        "type": "any",
        "isStatic": false
      },
      "tab": {
        "type": "any",
        "isStatic": false
      },
      "debouncedFilter": {
        "type": "any",
        "isStatic": false
      },
      "static SORT_MODES": {
        "type": "any",
        "isStatic": true
      },
      "static FILTER_DEBOUNCE_MS": {
        "type": "any",
        "isStatic": true
      },
      "sortMode": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "search": {
        "type": "any",
        "isStatic": false
      },
      "innerHTML": {
        "type": "any",
        "isStatic": false
      },
      "controls": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "option": {
        "type": "any",
        "isStatic": false
      },
      "groupLabel": {
        "type": "any",
        "isStatic": false
      },
      "_inputElement": {
        "type": "any",
        "isStatic": false
      },
      "_filterItems": {
        "type": "any",
        "isStatic": false
      },
      "_controls": {
        "type": "any",
        "isStatic": false
      },
      "el": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "className": {
        "type": "any",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      },
      "entries": {
        "type": "any",
        "isStatic": false
      },
      "elementMap": {
        "type": "any",
        "isStatic": false
      },
      "hidden": {
        "type": "any",
        "isStatic": false
      },
      "group": {
        "type": "boolean",
        "isStatic": false
      },
      "sections": {
        "type": "any",
        "isStatic": false
      },
      "section": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "element": {
        "type": "any",
        "isStatic": false
      },
      "itemPreparationMode": {
        "type": "string",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "filter": {
        "type": "any",
        "isStatic": false
      },
      "flag": {
        "type": "any",
        "isStatic": false
      },
      "current": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "boolean",
        "isStatic": false
      },
      "index": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      }
    },
    "SlideToggleElement": {
      "role": {
        "type": "any",
        "isStatic": false
      },
      "static tagName": {
        "type": "any",
        "isStatic": true
      },
      "static useShadowRoot": {
        "type": "any",
        "isStatic": true
      },
      "track": {
        "type": "any",
        "isStatic": false
      },
      "thumb": {
        "type": "any",
        "isStatic": false
      }
    },
    "TargetedApplicationElement": {
      "selectedTokensHook": {
        "type": "any",
        "isStatic": false
      },
      "pressed": {
        "type": "any",
        "isStatic": false
      },
      "mode": {
        "type": "any",
        "isStatic": false
      },
      "toPress": {
        "type": "any",
        "isStatic": false
      },
      "currentlyPressed": {
        "type": "any",
        "isStatic": false
      },
      "ariaPressed": {
        "type": "any",
        "isStatic": false
      },
      "targetSourceControl": {
        "type": "any",
        "isStatic": false
      },
      "innerHTML": {
        "type": "any",
        "isStatic": false
      },
      "b": {
        "type": "any",
        "isStatic": false
      },
      "hidden": {
        "type": "any",
        "isStatic": false
      },
      "targetList": {
        "type": "any",
        "isStatic": false
      },
      "targetedTokens": {
        "type": "any",
        "isStatic": false
      },
      "t": {
        "type": "any",
        "isStatic": false
      },
      "targets": {
        "type": "any",
        "isStatic": false
      },
      "li": {
        "type": "any",
        "isStatic": false
      },
      "innerText": {
        "type": "any",
        "isStatic": false
      },
      "targetingMode": {
        "type": "any",
        "isStatic": false
      }
    },
    "CurrencyManager": {
      "_options": {
        "type": "any",
        "isStatic": false
      },
      "document": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "tabGroups": {
        "type": "any",
        "isStatic": false
      },
      "destinations": {
        "type": "any",
        "isStatic": false
      },
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "b": {
        "type": "any",
        "isStatic": false
      },
      "primaryParty": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "Actor5e|Item5e",
        "isStatic": false
      },
      "currency": {
        "type": "any",
        "isStatic": false
      },
      "tabs": {
        "type": "any",
        "isStatic": false
      },
      "tab": {
        "type": "any",
        "isStatic": false
      },
      "primary": {
        "type": "string",
        "isStatic": false
      },
      "action": {
        "type": "string",
        "isStatic": false
      },
      "input": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "formData": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "valid": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "currencies": {
        "type": "any",
        "isStatic": false
      },
      "basis": {
        "type": "any",
        "isStatic": false
      },
      "amount": {
        "type": "any",
        "isStatic": false
      },
      "recursive": {
        "type": "number",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "priority": {
        "type": "string",
        "isStatic": false
      },
      "baseConversion": {
        "type": "any",
        "isStatic": false
      },
      "multiplier": {
        "type": "any",
        "isStatic": false
      },
      "deduct": {
        "type": "any",
        "isStatic": false
      }
    },
    "AttackRollConfigurationDialog": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "optionsFields": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      }
    },
    "D20RollConfigurationDialog": {
      "defaultButton": {
        "type": "any",
        "isStatic": false
      },
      "advantage": {
        "type": "any",
        "isStatic": false
      },
      "disadvantage": {
        "type": "any",
        "isStatic": false
      },
      "advantageMode": {
        "type": "boolean",
        "isStatic": false
      },
      "buttons": {
        "type": "string",
        "isStatic": false
      },
      "action": {
        "type": "string",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      }
    },
    "DamageRollConfigurationDialog": {
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "allowCritical": {
        "type": "boolean",
        "isStatic": false
      },
      "defaultCritical": {
        "type": "string",
        "isStatic": false
      },
      "buttons": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "allTypes": {
        "type": "any",
        "isStatic": false
      },
      "rolls": {
        "type": "any",
        "isStatic": false
      },
      "_": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "damageType": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "string",
        "isStatic": false
      }
    },
    "RollConfigurationDialog": {
      "config": {
        "type": "any",
        "isStatic": false
      },
      "message": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "dice": {
        "type": "any",
        "isStatic": false
      },
      "shouldDisplay": {
        "type": "any",
        "isStatic": false
      },
      "identifyTerm": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "identifyDice": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "byDenom": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "buttons": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "rolls": {
        "type": "any",
        "isStatic": false
      },
      "RollType": {
        "type": "any",
        "isStatic": false
      },
      "situational": {
        "type": "any",
        "isStatic": false
      },
      "v": {
        "type": "string",
        "isStatic": false
      },
      "rollMode": {
        "type": "any",
        "isStatic": false
      },
      "formData": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any[]",
        "isStatic": false
      }
    },
    "SkillToolRollConfigurationDialog": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "string",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "abilityLabel": {
        "type": "any",
        "isStatic": false
      },
      "flavor": {
        "type": "any",
        "isStatic": false
      }
    },
    "ContainerSheet": {
      "_expanded": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "capacity": {
        "type": "any",
        "isStatic": false
      },
      "itemContext": {
        "type": "any",
        "isStatic": false
      },
      "ctx": {
        "type": "Record<string, any>",
        "isStatic": false
      },
      "totalWeight": {
        "type": "any",
        "isStatic": false
      },
      "isExpanded": {
        "type": "any",
        "isStatic": false
      },
      "isStack": {
        "type": "any",
        "isStatic": false
      },
      "expanded": {
        "type": "any",
        "isStatic": false
      },
      "isContainer": {
        "type": "any",
        "isStatic": false
      },
      "inventory": {
        "type": "any",
        "isStatic": false
      },
      "li": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "dragData": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "this",
        "isStatic": false
      },
      "folder": {
        "type": "any",
        "isStatic": false
      },
      "recursiveWarning": {
        "type": "any",
        "isStatic": false
      },
      "parentContainers": {
        "type": "any",
        "isStatic": false
      },
      "containers": {
        "type": "any",
        "isStatic": false
      },
      "container": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "boolean",
        "isStatic": false
      },
      "toCreate": {
        "type": "any",
        "isStatic": false
      },
      "d": {
        "type": "any",
        "isStatic": false
      },
      "behavior": {
        "type": "any",
        "isStatic": false
      },
      "created": {
        "type": "any",
        "isStatic": false
      },
      "dropTarget": {
        "type": "any",
        "isStatic": false
      },
      "contents": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "id": {
        "type": "any",
        "isStatic": false
      },
      "siblings": {
        "type": "any",
        "isStatic": false
      },
      "siblingId": {
        "type": "any",
        "isStatic": false
      },
      "sortUpdates": {
        "type": "any",
        "isStatic": false
      },
      "updateData": {
        "type": "any",
        "isStatic": false
      },
      "_id": {
        "type": "any",
        "isStatic": false
      }
    },
    "CreateScrollDialog": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "spell": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "anchor": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "values": {
        "type": "any",
        "isStatic": false
      },
      "valuePlaceholders": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "any",
        "isStatic": false
      },
      "formData": {
        "type": "any",
        "isStatic": false
      },
      "event": {
        "type": "any",
        "isStatic": false
      }
    },
    "EnchantmentConfig": {},
    "StartingEquipmentConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "processEntry": {
        "type": "number",
        "isStatic": false
      },
      "children": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "showRequireProficiency": {
        "type": "any",
        "isStatic": false
      },
      "entries": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      },
      "startingEquipment": {
        "type": "any",
        "isStatic": false
      },
      "highestSort": {
        "type": "any",
        "isStatic": false
      },
      "deleteIds": {
        "type": "any",
        "isStatic": false
      },
      "getDeleteIds": {
        "type": "any",
        "isStatic": false
      },
      "c": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "entry": {
        "type": "any",
        "isStatic": false
      },
      "box": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "this",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "closestDrop": {
        "type": "any",
        "isStatic": false
      },
      "entryType": {
        "type": "string",
        "isStatic": false
      },
      "dropArea": {
        "type": "any",
        "isStatic": false
      },
      "dragEntry": {
        "type": "any",
        "isStatic": false
      },
      "dropEntry": {
        "type": "any",
        "isStatic": false
      },
      "_id": {
        "type": "any",
        "isStatic": false
      },
      "depth": {
        "type": "any",
        "isStatic": false
      },
      "updateData": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "group": {
        "type": "any",
        "isStatic": false
      },
      "sortBefore": {
        "type": "any",
        "isStatic": false
      },
      "sortedEntries": {
        "type": "any",
        "isStatic": false
      },
      "siblings": {
        "type": "any",
        "isStatic": false
      },
      "sortUpdates": {
        "type": "any",
        "isStatic": false
      }
    },
    "SummoningConfig": {},
    "JournalEditor": {
      "_options": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "rawText": {
        "type": "any",
        "isStatic": false
      }
    },
    "SpellsUnlinkedConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "submitData": {
        "type": "any",
        "isStatic": false
      },
      "unlinkedSpells": {
        "type": "any",
        "isStatic": false
      },
      "editing": {
        "type": "any",
        "isStatic": false
      }
    },
    "DragDropApplication": {
      "data": {
        "type": "any",
        "isStatic": false
      },
      "dropEffect": {
        "type": "string",
        "isStatic": false
      },
      "allowed": {
        "type": "any",
        "isStatic": false
      },
      "behavior": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      }
    },
    "PropertyAttribution": {
      "options": {
        "type": "any",
        "isStatic": false
      },
      "object": {
        "type": "any",
        "isStatic": false
      },
      "attributions": {
        "type": "any",
        "isStatic": false
      },
      "property": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "total": {
        "type": "any",
        "isStatic": false
      },
      "sources": {
        "type": "any",
        "isStatic": false
      },
      "entry": {
        "type": "any",
        "isStatic": false
      },
      "mode": {
        "type": "boolean",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "parts": {
        "type": "any",
        "isStatic": false
      }
    },
    "BaseSettingsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "buttons": {
        "type": "any",
        "isStatic": false
      },
      "setting": {
        "type": "any",
        "isStatic": false
      },
      "Field": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      }
    },
    "BastionSettingsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      }
    },
    "CombatSettingsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "legend": {
        "type": "any",
        "isStatic": false
      }
    },
    "CompendiumBrowserSettingsConfig": {
      "selected": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "static FILTER_DELAY": {
        "type": "any",
        "isStatic": true
      },
      "filter": {
        "type": "any",
        "isStatic": false
      },
      "_debouncedFilter": {
        "type": "any",
        "isStatic": false
      },
      "sources": {
        "type": "any",
        "isStatic": false
      },
      "byPackage": {
        "type": "any",
        "isStatic": false
      },
      "packageType": {
        "type": "string",
        "isStatic": false
      },
      "entry": {
        "type": "any",
        "isStatic": false
      },
      "packages": {
        "type": "any",
        "isStatic": false
      },
      "world": {
        "type": "any",
        "isStatic": false
      },
      "system": {
        "type": "any",
        "isStatic": false
      },
      "modules": {
        "type": "string",
        "isStatic": false
      },
      "id": {
        "type": "any",
        "isStatic": false
      },
      "module": {
        "type": "any",
        "isStatic": false
      },
      "packs": {
        "type": "any",
        "isStatic": false
      },
      "all": {
        "type": "any",
        "isStatic": false
      },
      "indeterminate": {
        "type": "any",
        "isStatic": false
      },
      "documentName": {
        "type": "any",
        "isStatic": false
      },
      "partId": {
        "type": "string",
        "isStatic": false
      },
      "query": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "string",
        "isStatic": false
      },
      "pkg": {
        "type": "string",
        "isStatic": false
      },
      "setting": {
        "type": "any",
        "isStatic": false
      },
      "input": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "string",
        "isStatic": false
      }
    },
    "ModuleArtSettingsConfig": {
      "object": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "settings": {
        "type": "any",
        "isStatic": false
      },
      "action": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "id": {
        "type": "any",
        "isStatic": false
      },
      "configs": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "string",
        "isStatic": false
      },
      "idx": {
        "type": "any",
        "isStatic": false
      },
      "sortBefore": {
        "type": "string",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      }
    },
    "VariantRulesSettingsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "string",
        "isStatic": false
      },
      "legend": {
        "type": "any",
        "isStatic": false
      }
    },
    "VisibilitySettingsConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      }
    },
    "CreatureTypeConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "keyPath": {
        "type": "any",
        "isStatic": false
      },
      "swarmOptions": {
        "type": "any",
        "isStatic": false
      },
      "typeOptions": {
        "type": "any",
        "isStatic": false
      },
      "custom": {
        "type": "string",
        "isStatic": false
      },
      "rows": {
        "type": "any",
        "isStatic": false
      },
      "preview": {
        "type": "any",
        "isStatic": false
      }
    },
    "MovementSensesConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "keyPath": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "uniqueId": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "placeholderData": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "extras": {
        "type": "any",
        "isStatic": false
      },
      "types": {
        "type": "any",
        "isStatic": false
      },
      "unitsOptions": {
        "type": "any",
        "isStatic": false
      }
    },
    "SourceConfig": {
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "buttons": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "keyPath": {
        "type": "any",
        "isStatic": false
      },
      "sourceUuid": {
        "type": "any",
        "isStatic": false
      },
      "sourceAnchor": {
        "type": "any",
        "isStatic": false
      },
      "rulesVersions": {
        "type": "any",
        "isStatic": false
      },
      "identifier": {
        "type": "any",
        "isStatic": false
      }
    },
    "TokenPlacement": {
      "config": {
        "type": "any",
        "isStatic": false
      },
      "currentPlacement": {
        "type": "any",
        "isStatic": false
      },
      "moveTime": {
        "type": "any",
        "isStatic": false
      },
      "throttle": {
        "type": "any",
        "isStatic": false
      },
      "placement": {
        "type": "any",
        "isStatic": false
      },
      "placements": {
        "type": "any",
        "isStatic": false
      },
      "total": {
        "type": "any",
        "isStatic": false
      },
      "uniqueTokens": {
        "type": "any",
        "isStatic": false
      },
      "obj": {
        "type": "any",
        "isStatic": false
      },
      "eventMode": {
        "type": "any",
        "isStatic": false
      },
      "actorId": {
        "type": "any",
        "isStatic": false
      },
      "index": {
        "type": "any",
        "isStatic": false
      },
      "previews": {
        "type": "any",
        "isStatic": false
      },
      "tokenData": {
        "type": "any",
        "isStatic": false
      },
      "enabled": {
        "type": "any",
        "isStatic": false
      },
      "_id": {
        "type": "any",
        "isStatic": false
      },
      "src": {
        "type": "any",
        "isStatic": false
      },
      "cls": {
        "type": "any",
        "isStatic": false
      },
      "doc": {
        "type": "any",
        "isStatic": false
      },
      "p": {
        "type": "any",
        "isStatic": false
      },
      "events": {
        "type": "any",
        "isStatic": false
      },
      "oncontextmenu": {
        "type": "any",
        "isStatic": false
      },
      "onwheel": {
        "type": "any",
        "isStatic": false
      },
      "idx": {
        "type": "any",
        "isStatic": false
      },
      "preview": {
        "type": "any",
        "isStatic": false
      },
      "clone": {
        "type": "any",
        "isStatic": false
      },
      "local": {
        "type": "any",
        "isStatic": false
      },
      "x": {
        "type": "any",
        "isStatic": false
      },
      "y": {
        "type": "any",
        "isStatic": false
      },
      "dest": {
        "type": "any",
        "isStatic": false
      },
      "delta": {
        "type": "any",
        "isStatic": false
      },
      "snap": {
        "type": "any",
        "isStatic": false
      },
      "regex": {
        "type": "any",
        "isStatic": false
      },
      "match": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActorDataModel": {
      "static metadata": {
        "type": "any",
        "isStatic": true
      },
      "primaryParty": {
        "type": "any",
        "isStatic": false
      },
      "destinations": {
        "type": "any",
        "isStatic": false
      },
      "scale": {
        "type": "any",
        "isStatic": false
      },
      "deterministic": {
        "type": "any",
        "isStatic": false
      },
      "prof": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemDataModel": {
      "static metadata": {
        "type": "any",
        "isStatic": true
      },
      "static ITEM_TOOLTIP_TEMPLATE": {
        "type": "any",
        "isStatic": true
      },
      "sourceId": {
        "type": "any",
        "isStatic": false
      },
      "enrichmentOptions": {
        "type": "any",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "isIdentified": {
        "type": "boolean",
        "isStatic": false
      },
      "chat": {
        "type": "any",
        "isStatic": false
      },
      "description": {
        "type": "any",
        "isStatic": false
      },
      "uses": {
        "type": "any",
        "isStatic": false
      },
      "price": {
        "type": "any",
        "isStatic": false
      },
      "subtitle": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "properties": {
        "type": "any",
        "isStatic": false
      },
      "hasProperties": {
        "type": "any",
        "isStatic": false
      },
      "baseItem": {
        "type": "number",
        "isStatic": false
      },
      "gold": {
        "type": "any",
        "isStatic": false
      },
      "valueInGP": {
        "type": "any",
        "isStatic": false
      },
      "base": {
        "type": "any",
        "isStatic": false
      },
      "costs": {
        "type": "any",
        "isStatic": false
      },
      "deterministic": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      }
    },
    "AttackActivityData": {
      "ability": {
        "type": "string",
        "isStatic": false
      },
      "availableAbilities": {
        "type": "any",
        "isStatic": false
      },
      "size": {
        "type": "number",
        "isStatic": false
      },
      "abilities": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "string",
        "isStatic": false
      },
      "labels": {
        "type": "any",
        "isStatic": false
      },
      "reach": {
        "type": "any",
        "isStatic": false
      },
      "classification": {
        "type": "string",
        "isStatic": false
      },
      "melee": {
        "type": "any",
        "isStatic": false
      },
      "ranged": {
        "type": "any",
        "isStatic": false
      },
      "threshold": {
        "type": "any",
        "isStatic": false
      },
      "sourceType": {
        "type": "any",
        "isStatic": false
      },
      "damageParts": {
        "type": "any",
        "isStatic": false
      },
      "hasBase": {
        "type": "string",
        "isStatic": false
      },
      "parts": {
        "type": "any",
        "isStatic": false
      },
      "part": {
        "type": "any",
        "isStatic": false
      },
      "basePart": {
        "type": "any",
        "isStatic": false
      },
      "base": {
        "type": "any",
        "isStatic": false
      },
      "locked": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "modifier": {
        "type": "any",
        "isStatic": false
      },
      "formula": {
        "type": "any",
        "isStatic": false
      },
      "toHit": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      },
      "attackModeLabel": {
        "type": "any",
        "isStatic": false
      },
      "actionType": {
        "type": "any",
        "isStatic": false
      },
      "actionTypeLabel": {
        "type": "any",
        "isStatic": false
      },
      "isLegacy": {
        "type": "string",
        "isStatic": false
      },
      "isUnarmed": {
        "type": "string",
        "isStatic": false
      },
      "isSpell": {
        "type": "string",
        "isStatic": false
      },
      "weaponType": {
        "type": "any",
        "isStatic": false
      },
      "weaponTypeLabel": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "weapon": {
        "type": "any",
        "isStatic": false
      },
      "ammo": {
        "type": "any",
        "isStatic": false
      },
      "properties": {
        "type": "any",
        "isStatic": false
      },
      "basePartIndex": {
        "type": "any",
        "isStatic": false
      },
      "damage": {
        "type": "any",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "range": {
        "type": "any",
        "isStatic": false
      },
      "_": {
        "type": "any",
        "isStatic": false
      },
      "index": {
        "type": "Set<string>",
        "isStatic": false
      },
      "attackMode": {
        "type": "string",
        "isStatic": false
      },
      "types": {
        "type": "any",
        "isStatic": false
      },
      "includeMod": {
        "type": "any",
        "isStatic": false
      },
      "p": {
        "type": "any",
        "isStatic": false
      },
      "magicalBonus": {
        "type": "any",
        "isStatic": false
      },
      "ammoBonus": {
        "type": "any",
        "isStatic": false
      },
      "criticalBonusDice": {
        "type": "any",
        "isStatic": false
      }
    },
    "CastActivityData": {
      "schema": {
        "type": "any",
        "isStatic": false
      },
      "spell": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "img": {
        "type": "any",
        "isStatic": false
      }
    },
    "CheckActivityData": {
      "calculation": {
        "type": "this",
        "isStatic": false
      },
      "ability": {
        "type": "string",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "this",
        "isStatic": false
      }
    },
    "DamageActivityData": {
      "part": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      }
    },
    "EnchantActivityData": {
      "keyPath": {
        "type": "string",
        "isStatic": false
      },
      "level": {
        "type": "any",
        "isStatic": false
      },
      "e": {
        "type": "any",
        "isStatic": false
      },
      "effects": {
        "type": "any",
        "isStatic": false
      }
    },
    "AppliedEffectField": {
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      }
    },
    "ConsumptionTargetsField": {
      "options": {
        "type": "any",
        "isStatic": false
      }
    },
    "ConsumptionError": {
      "name": {
        "type": "any",
        "isStatic": false
      }
    },
    "ForwardActivityData": {
      "schema": {
        "type": "any",
        "isStatic": false
      }
    },
    "HealActivityData": {
      "config": {
        "type": "any",
        "isStatic": false
      },
      "rollConfig": {
        "type": "any",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "rolls": {
        "type": "any",
        "isStatic": false
      }
    },
    "OrderActivityData": {
      "img": {
        "type": "any",
        "isStatic": false
      }
    },
    "SaveActivityData": {
      "calculation": {
        "type": "this",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "onSave": {
        "type": "number",
        "isStatic": false
      },
      "bonus": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "save": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      }
    },
    "SummonActivityData": {
      "level": {
        "type": "any",
        "isStatic": false
      },
      "e": {
        "type": "any",
        "isStatic": false
      },
      "keyPath": {
        "type": "string",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      }
    },
    "UtilityActivityData": {},
    "CharacterData": {
      "static LOCALIZATION_PREFIXES": {
        "type": "any",
        "isStatic": true
      },
      "static metadata": {
        "type": "any",
        "isStatic": true
      },
      "static _systemType": {
        "type": "any",
        "isStatic": true
      },
      "hd": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "prof": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "min": {
        "type": "any",
        "isStatic": false
      },
      "required": {
        "type": "any",
        "isStatic": false
      },
      "pct": {
        "type": "any",
        "isStatic": false
      },
      "overflow": {
        "type": "any",
        "isStatic": false
      },
      "boonsEarned": {
        "type": "any",
        "isStatic": false
      },
      "progress": {
        "type": "any",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "hpOptions": {
        "type": "any",
        "isStatic": false
      },
      "bonus": {
        "type": "any",
        "isStatic": false
      },
      "mod": {
        "type": "any",
        "isStatic": false
      },
      "f": {
        "type": "any",
        "isStatic": false
      },
      "maxSort": {
        "type": "any",
        "isStatic": false
      },
      "favorites": {
        "type": "any",
        "isStatic": false
      }
    },
    "DamageTraitField": {
      "fields": {
        "type": "any",
        "isStatic": false
      }
    },
    "SimpleTraitField": {
      "fields": {
        "type": "any",
        "isStatic": false
      }
    },
    "NPCData": {
      "static LOCALIZATION_PREFIXES": {
        "type": "any",
        "isStatic": true
      },
      "static metadata": {
        "type": "any",
        "isStatic": true
      },
      "static _systemType": {
        "type": "any",
        "isStatic": true
      },
      "value": {
        "type": "number",
        "isStatic": false
      },
      "v": {
        "type": "number",
        "isStatic": false
      },
      "custom": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "original": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "pattern": {
        "type": "any",
        "isStatic": false
      },
      "match": {
        "type": "any",
        "isStatic": false
      },
      "typeLc": {
        "type": "any",
        "isStatic": false
      },
      "typeMatch": {
        "type": "any",
        "isStatic": false
      },
      "subtype": {
        "type": "any",
        "isStatic": false
      },
      "sizeLc": {
        "type": "any",
        "isStatic": false
      },
      "sizeMatch": {
        "type": "any",
        "isStatic": false
      },
      "swarm": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "denomination": {
        "type": "any",
        "isStatic": false
      },
      "lairAdjustment": {
        "type": "any",
        "isStatic": false
      },
      "cr": {
        "type": "any",
        "isStatic": false
      },
      "prof": {
        "type": "any",
        "isStatic": false
      },
      "attributes": {
        "type": "any",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "pct": {
        "type": "any",
        "isStatic": false
      },
      "hpOptions": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "delta": {
        "type": "any",
        "isStatic": false
      },
      "mode": {
        "type": "this",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "pr": {
        "type": "any",
        "isStatic": false
      },
      "rulesVersion": {
        "type": "string",
        "isStatic": false
      },
      "i": {
        "type": "string",
        "isStatic": false
      },
      "options": {
        "type": "boolean",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "cite": {
        "type": "any",
        "isStatic": false
      },
      "anchor": {
        "type": "any",
        "isStatic": false
      },
      "template": {
        "type": "any",
        "isStatic": false
      },
      "innerHTML": {
        "type": "any",
        "isStatic": false
      },
      "formatter": {
        "type": "any",
        "isStatic": false
      },
      "prepareMeasured": {
        "type": "any",
        "isStatic": false
      },
      "prepareTrait": {
        "type": "any",
        "isStatic": false
      },
      "prepared": {
        "type": "any",
        "isStatic": false
      },
      "k": {
        "type": "string",
        "isStatic": false
      },
      "entries": {
        "type": "any",
        "isStatic": false
      },
      "category": {
        "type": "string",
        "isStatic": false
      },
      "trait": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "list": {
        "type": "any",
        "isStatic": false
      },
      "t": {
        "type": "any",
        "isStatic": false
      },
      "description": {
        "type": "any",
        "isStatic": false
      },
      "identifier": {
        "type": "string",
        "isStatic": false
      },
      "openingTag": {
        "type": "any",
        "isStatic": false
      },
      "uses": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "string",
        "isStatic": false
      }
    },
    "AttributesFields": {
      "init": {
        "type": "any",
        "isStatic": false
      },
      "bonus": {
        "type": "string",
        "isStatic": false
      },
      "ac": {
        "type": "any",
        "isStatic": false
      },
      "armor": {
        "type": "any",
        "isStatic": false
      },
      "shield": {
        "type": "number",
        "isStatic": false
      },
      "min": {
        "type": "string",
        "isStatic": false
      },
      "encumbrance": {
        "type": "Record<string, any>",
        "isStatic": false
      },
      "multipliers": {
        "type": "any",
        "isStatic": false
      },
      "bonuses": {
        "type": "any",
        "isStatic": false
      },
      "cfg": {
        "type": "any",
        "isStatic": false
      },
      "calc": {
        "type": "any",
        "isStatic": false
      },
      "flat": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "string",
        "isStatic": false
      },
      "base": {
        "type": "any",
        "isStatic": false
      },
      "formula": {
        "type": "string",
        "isStatic": false
      },
      "armorData": {
        "type": "any",
        "isStatic": false
      },
      "isHeavy": {
        "type": "string",
        "isStatic": false
      },
      "dex": {
        "type": "any",
        "isStatic": false
      },
      "equippedArmor": {
        "type": "any",
        "isStatic": false
      },
      "replaced": {
        "type": "any",
        "isStatic": false
      },
      "equippedShield": {
        "type": "any",
        "isStatic": false
      },
      "cover": {
        "type": "any",
        "isStatic": false
      },
      "abilityId": {
        "type": "any",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "save": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "baseUnits": {
        "type": "any",
        "isStatic": false
      },
      "unitSystem": {
        "type": "any",
        "isStatic": false
      },
      "weight": {
        "type": "any",
        "isStatic": false
      },
      "currency": {
        "type": "any",
        "isStatic": false
      },
      "numCoins": {
        "type": "any",
        "isStatic": false
      },
      "currencyPerWeight": {
        "type": "any",
        "isStatic": false
      },
      "keys": {
        "type": "any",
        "isStatic": false
      },
      "index": {
        "type": "any",
        "isStatic": false
      },
      "sizeConfig": {
        "type": "any",
        "isStatic": false
      },
      "sizeMod": {
        "type": "any",
        "isStatic": false
      },
      "calculateThreshold": {
        "type": "any",
        "isStatic": false
      },
      "multiplier": {
        "type": "any",
        "isStatic": false
      },
      "threshold": {
        "type": "string",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "thresholds": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "mod": {
        "type": "any",
        "isStatic": false
      },
      "stops": {
        "type": "any",
        "isStatic": false
      },
      "pct": {
        "type": "any",
        "isStatic": false
      },
      "encumbered": {
        "type": "any",
        "isStatic": false
      },
      "exhaustion": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "number",
        "isStatic": false
      },
      "effectiveMax": {
        "type": "any",
        "isStatic": false
      },
      "damage": {
        "type": "any",
        "isStatic": false
      },
      "flags": {
        "type": "any",
        "isStatic": false
      },
      "globalCheckBonus": {
        "type": "any",
        "isStatic": false
      },
      "isLegacy": {
        "type": "string",
        "isStatic": false
      },
      "prof": {
        "type": "any",
        "isStatic": false
      },
      "joat": {
        "type": "any",
        "isStatic": false
      },
      "ra": {
        "type": "any",
        "isStatic": false
      },
      "alert": {
        "type": "any",
        "isStatic": false
      },
      "initBonus": {
        "type": "any",
        "isStatic": false
      },
      "abilityBonus": {
        "type": "any",
        "isStatic": false
      },
      "total": {
        "type": "any",
        "isStatic": false
      },
      "score": {
        "type": "any",
        "isStatic": false
      },
      "statuses": {
        "type": "any",
        "isStatic": false
      },
      "noMovement": {
        "type": "any",
        "isStatic": false
      },
      "halfMovement": {
        "type": "any",
        "isStatic": false
      },
      "heavilyEncumbered": {
        "type": "any",
        "isStatic": false
      },
      "exceedingCarryingCapacity": {
        "type": "any",
        "isStatic": false
      },
      "crawl": {
        "type": "any",
        "isStatic": false
      },
      "units": {
        "type": "any",
        "isStatic": false
      },
      "reduction": {
        "type": "string",
        "isStatic": false
      },
      "speed": {
        "type": "any",
        "isStatic": false
      },
      "hover": {
        "type": "any",
        "isStatic": false
      },
      "special": {
        "type": "any",
        "isStatic": false
      },
      "abilityLabel": {
        "type": "any",
        "isStatic": false
      },
      "attack": {
        "type": "any",
        "isStatic": false
      },
      "dc": {
        "type": "any",
        "isStatic": false
      }
    },
    "CreatureTemplate": {
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "levels": {
        "type": "string",
        "isStatic": false
      },
      "original": {
        "type": "string[]",
        "isStatic": false
      },
      "pattern": {
        "type": "any",
        "isStatic": false
      },
      "wasMatched": {
        "type": "any",
        "isStatic": false
      },
      "s": {
        "type": "any",
        "isStatic": false
      },
      "match": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "special": {
        "type": "any",
        "isStatic": false
      },
      "validProf": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "globalCheckBonus": {
        "type": "any",
        "isStatic": false
      },
      "globalSkillBonus": {
        "type": "any",
        "isStatic": false
      },
      "flags": {
        "type": "any",
        "isStatic": false
      },
      "abilityData": {
        "type": "any",
        "isStatic": false
      },
      "baseBonus": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "checkBonusAbl": {
        "type": "any",
        "isStatic": false
      },
      "effectValue": {
        "type": "any",
        "isStatic": false
      },
      "bonus": {
        "type": "any",
        "isStatic": false
      },
      "mod": {
        "type": "any",
        "isStatic": false
      },
      "prof": {
        "type": "any",
        "isStatic": false
      },
      "total": {
        "type": "any",
        "isStatic": false
      },
      "passive": {
        "type": "any",
        "isStatic": false
      },
      "passiveBonus": {
        "type": "any",
        "isStatic": false
      },
      "deterministic": {
        "type": "any",
        "isStatic": false
      },
      "classes": {
        "type": "any",
        "isStatic": false
      },
      "hitDice": {
        "type": "any",
        "isStatic": false
      },
      "subclass": {
        "type": "any",
        "isStatic": false
      }
    },
    "DetailsField": {},
    "TraitsField": {
      "schemaOptions": {
        "type": "any",
        "isStatic": false
      },
      "languages": {
        "type": "any",
        "isStatic": false
      },
      "labels": {
        "type": "any",
        "isStatic": false
      },
      "processCategory": {
        "type": "any",
        "isStatic": false
      },
      "topLevel": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "custom": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      }
    },
    "VehicleData": {
      "static LOCALIZATION_PREFIXES": {
        "type": "any",
        "isStatic": true
      },
      "static _systemType": {
        "type": "any",
        "isStatic": true
      },
      "custom": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "prof": {
        "type": "any",
        "isStatic": false
      },
      "calc": {
        "type": "any",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "boolean",
        "isStatic": false
      }
    },
    "AbilityScoreImprovementValueData": {},
    "BaseAdvancement": {
      "v": {
        "type": "any",
        "isStatic": false
      },
      "hint": {
        "type": "any",
        "isStatic": false
      }
    },
    "ScaleValueTypeNumber": {
      "value": {
        "type": "ScaleValueTypeMetadata",
        "isStatic": false
      }
    },
    "ScaleValueTypeCR": {
      "static LOCALIZATION_PREFIXES": {
        "type": "any",
        "isStatic": true
      }
    },
    "ScaleValueTypeDice": {
      "static LOCALIZATION_PREFIXES": {
        "type": "any",
        "isStatic": true
      },
      "static FACES": {
        "type": "any",
        "isStatic": true
      },
      "number": {
        "type": "any",
        "isStatic": false
      },
      "faces": {
        "type": "any",
        "isStatic": false
      },
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "string",
        "isStatic": false
      }
    },
    "ScaleValueTypeDistance": {},
    "ActivationsField": {
      "i": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActorDeltasField": {
      "deltas": {
        "type": "any",
        "isStatic": false
      },
      "rolls": {
        "type": "any",
        "isStatic": false
      }
    },
    "IndividualDeltaField": {
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "deltas": {
        "type": "any",
        "isStatic": false
      },
      "currentValue": {
        "type": "any",
        "isStatic": false
      },
      "delta": {
        "type": "any",
        "isStatic": false
      },
      "rolls": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      }
    },
    "RestMessageData": {
      "static metadata": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "activities": {
        "type": "any",
        "isStatic": false
      },
      "deltas": {
        "type": "any",
        "isStatic": false
      }
    },
    "TurnMessageData": {
      "static metadata": {
        "type": "any",
        "isStatic": true
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "activities": {
        "type": "any",
        "isStatic": false
      },
      "deltas": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActivitiesField": {
      "activities": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActivityCollection": {
      "model": {
        "type": "any",
        "isStatic": false
      },
      "types": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "this",
        "isStatic": false
      }
    },
    "EnchantmentField": {
      "options": {
        "type": "any",
        "isStatic": false
      }
    },
    "EnchantmentError": {
      "name": {
        "type": "any",
        "isStatic": false
      }
    },
    "SpellcastingField": {
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "levels": {
        "type": "any",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "mod": {
        "type": "any",
        "isStatic": false
      },
      "modProf": {
        "type": "any",
        "isStatic": false
      },
      "msak": {
        "type": "any",
        "isStatic": false
      },
      "rsak": {
        "type": "any",
        "isStatic": false
      },
      "attack": {
        "type": "any",
        "isStatic": false
      },
      "save": {
        "type": "any",
        "isStatic": false
      }
    },
    "SummonsField": {
      "options": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActionTemplate": {
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "bonus": {
        "type": "any",
        "isStatic": false
      },
      "critical": {
        "type": "any",
        "isStatic": false
      },
      "damage": {
        "type": "string",
        "isStatic": false
      },
      "scaling": {
        "type": "string",
        "isStatic": false
      },
      "dc": {
        "type": "string",
        "isStatic": false
      },
      "ammoThreshold": {
        "type": "any",
        "isStatic": false
      },
      "threshold": {
        "type": "any",
        "isStatic": false
      },
      "actionType": {
        "type": "string|null",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      },
      "mod": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActivatedEffectTemplate": {
      "static ItemUsesField": {
        "type": "any",
        "isStatic": true
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "units": {
        "type": "string",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "duration": {
        "type": "any",
        "isStatic": false
      },
      "concentrationDuration": {
        "type": "any",
        "isStatic": false
      },
      "activation": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "range": {
        "type": "any",
        "isStatic": false
      },
      "recharge": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "property": {
        "type": "any",
        "isStatic": false
      },
      "formula": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "message": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "long": {
        "type": "string",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "amount": {
        "type": "any",
        "isStatic": false
      },
      "consume": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemUsesField": {
      "value": {
        "type": "any",
        "isStatic": false
      },
      "units": {
        "type": "string",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "duration": {
        "type": "any",
        "isStatic": false
      },
      "concentrationDuration": {
        "type": "any",
        "isStatic": false
      },
      "activation": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "range": {
        "type": "any",
        "isStatic": false
      },
      "recharge": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "property": {
        "type": "any",
        "isStatic": false
      },
      "formula": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "message": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "long": {
        "type": "string",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "amount": {
        "type": "any",
        "isStatic": false
      },
      "consume": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActivitiesTemplate": {
      "static LOCALIZATION_PREFIXES": {
        "type": "any",
        "isStatic": true
      },
      "activity": {
        "type": "any",
        "isStatic": false
      },
      "a": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "charged": {
        "type": "any",
        "isStatic": false
      },
      "spent": {
        "type": "any",
        "isStatic": false
      },
      "per": {
        "type": "string",
        "isStatic": false
      },
      "recovery": {
        "type": "any",
        "isStatic": false
      },
      "uses": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string|null",
        "isStatic": false
      },
      "cls": {
        "type": "any",
        "isStatic": false
      },
      "labels": {
        "type": "string|null",
        "isStatic": false
      },
      "updates": {
        "type": "string|null",
        "isStatic": false
      },
      "rolls": {
        "type": "any",
        "isStatic": false
      },
      "autoRecharge": {
        "type": "any",
        "isStatic": false
      },
      "shouldRecharge": {
        "type": "string",
        "isStatic": false
      },
      "recharge": {
        "type": "any",
        "isStatic": false
      },
      "message": {
        "type": "string",
        "isStatic": false
      },
      "result": {
        "type": "any",
        "isStatic": false
      },
      "spells": {
        "type": "any",
        "isStatic": false
      },
      "cloneChanges": {
        "type": "any",
        "isStatic": false
      },
      "riders": {
        "type": "any",
        "isStatic": false
      },
      "effect": {
        "type": "any",
        "isStatic": false
      },
      "removed": {
        "type": "any",
        "isStatic": false
      },
      "_": {
        "type": "any",
        "isStatic": false
      },
      "cachedInserts": {
        "type": "any",
        "isStatic": false
      },
      "existingSpell": {
        "type": "any",
        "isStatic": false
      },
      "enchantment": {
        "type": "any",
        "isStatic": false
      },
      "cached": {
        "type": "any",
        "isStatic": false
      },
      "spellIds": {
        "type": "any",
        "isStatic": false
      },
      "shim": {
        "type": "any",
        "isStatic": false
      },
      "addShims": {
        "type": "any",
        "isStatic": false
      },
      "firstActivity": {
        "type": "any",
        "isStatic": false
      },
      "d": {
        "type": "any",
        "isStatic": false
      },
      "activation": {
        "type": "any",
        "isStatic": false
      },
      "consumption": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "consume": {
        "type": "any",
        "isStatic": false
      }
    },
    "EquippableItemTemplate": {
      "value": {
        "type": "number",
        "isStatic": false
      },
      "filter": {
        "type": "any",
        "isStatic": false
      },
      "attuned": {
        "type": "any",
        "isStatic": false
      },
      "attunement": {
        "type": "any",
        "isStatic": false
      },
      "equipped": {
        "type": "boolean",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      }
    },
    "IdentifiableTemplate": {
      "description": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "fetchName": {
        "type": "any",
        "isStatic": false
      },
      "fetchDesc": {
        "type": "any",
        "isStatic": false
      },
      "baseItem": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemDescriptionTemplate": {
      "source": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemTypeTemplate": {
      "oldType": {
        "type": "any",
        "isStatic": false
      }
    },
    "MountableTemplate": {},
    "PhysicalItemTemplate": {
      "static MAX_DEPTH": {
        "type": "any",
        "isStatic": true
      },
      "hasPrice": {
        "type": "any",
        "isStatic": false
      },
      "multiplier": {
        "type": "any",
        "isStatic": false
      },
      "valueInGP": {
        "type": "any",
        "isStatic": false
      },
      "price": {
        "type": "any",
        "isStatic": false
      },
      "rarity": {
        "type": "any",
        "isStatic": false
      },
      "weight": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "c": {
        "type": "any",
        "isStatic": false
      },
      "a": {
        "type": "any",
        "isStatic": false
      },
      "former": {
        "type": "any",
        "isStatic": false
      },
      "formerContainer": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "depth": {
        "type": "any",
        "isStatic": false
      },
      "containers": {
        "type": "any",
        "isStatic": false
      },
      "container": {
        "type": "any",
        "isStatic": false
      },
      "w": {
        "type": "any",
        "isStatic": false
      }
    },
    "StartingEquipmentTemplate": {
      "topLevel": {
        "type": "any",
        "isStatic": false
      },
      "e": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActivationField": {
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "scalar": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "activation": {
        "type": "any",
        "isStatic": false
      }
    },
    "CurrencyTemplate": {
      "count": {
        "type": "any",
        "isStatic": false
      },
      "currencyPerWeight": {
        "type": "any",
        "isStatic": false
      }
    },
    "DamageField": {},
    "DurationField": {
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "scalar": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "duration": {
        "type": "any",
        "isStatic": false
      },
      "concentrationDuration": {
        "type": "any",
        "isStatic": false
      }
    },
    "RangeField": {
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "scalar": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "range": {
        "type": "any",
        "isStatic": false
      },
      "rangeParts": {
        "type": "any",
        "isStatic": false
      }
    },
    "SourceField": {
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "pkg": {
        "type": "any",
        "isStatic": false
      },
      "bookPlaceholder": {
        "type": "any",
        "isStatic": false
      },
      "book": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "page": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "slug": {
        "type": "any",
        "isStatic": false
      },
      "sourceBooks": {
        "type": "any",
        "isStatic": false
      },
      "keys": {
        "type": "any",
        "isStatic": false
      },
      "pack": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      }
    },
    "TargetField": {
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "scalar": {
        "type": "boolean",
        "isStatic": false
      },
      "count": {
        "type": "any",
        "isStatic": false
      },
      "dimensions": {
        "type": "any",
        "isStatic": false
      },
      "size": {
        "type": "any",
        "isStatic": false
      },
      "width": {
        "type": "any",
        "isStatic": false
      },
      "height": {
        "type": "any",
        "isStatic": false
      },
      "pr": {
        "type": "any",
        "isStatic": false
      },
      "templateConfig": {
        "type": "any",
        "isStatic": false
      },
      "parts": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "affectsConfig": {
        "type": "any",
        "isStatic": false
      },
      "labels": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "sizes": {
        "type": "any",
        "isStatic": false
      }
    },
    "UsesField": {
      "fields": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "periods": {
        "type": "any",
        "isStatic": false
      },
      "period": {
        "type": "string",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "recharge": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "recovery": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "min": {
        "type": "number",
        "isStatic": false
      },
      "max": {
        "type": "string",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "rolls": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "delta": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "total": {
        "type": "any",
        "isStatic": false
      },
      "newSpent": {
        "type": "any",
        "isStatic": false
      },
      "spent": {
        "type": "any",
        "isStatic": false
      },
      "oldReturn": {
        "type": "any",
        "isStatic": false
      },
      "apply": {
        "type": "any",
        "isStatic": false
      },
      "rollConfig": {
        "type": "any",
        "isStatic": false
      },
      "hookNames": {
        "type": "any",
        "isStatic": false
      },
      "subject": {
        "type": "any",
        "isStatic": false
      },
      "dialogConfig": {
        "type": "any",
        "isStatic": false
      },
      "messageConfig": {
        "type": "any",
        "isStatic": false
      },
      "hookData": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "create": {
        "type": "any",
        "isStatic": false
      },
      "flavor": {
        "type": "any",
        "isStatic": false
      }
    },
    "BasicRoll": {
      "static DefaultConfigurationDialog": {
        "type": "any",
        "isStatic": true
      },
      "formula": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "typeof RollConfigurationDialog",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "configure": {
        "type": "boolean",
        "isStatic": false
      },
      "DialogClass": {
        "type": "any",
        "isStatic": false
      },
      "rolls": {
        "type": "any",
        "isStatic": false
      },
      "rollType": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "messageId": {
        "type": "any",
        "isStatic": false
      },
      "document": {
        "type": "any",
        "isStatic": false
      },
      "create": {
        "type": "any",
        "isStatic": false
      },
      "messageData": {
        "type": "any",
        "isStatic": false
      },
      "cls": {
        "type": "any",
        "isStatic": false
      },
      "msg": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "terms": {
        "type": "any",
        "isStatic": false
      },
      "number": {
        "type": "any",
        "isStatic": false
      },
      "preCalculateOptions": {
        "type": "any",
        "isStatic": false
      },
      "currentModifiers": {
        "type": "any",
        "isStatic": false
      },
      "keep": {
        "type": "any",
        "isStatic": false
      },
      "drop": {
        "type": "any",
        "isStatic": false
      },
      "validModifiers": {
        "type": "any",
        "isStatic": false
      },
      "matchedModifier": {
        "type": "any",
        "isStatic": false
      },
      "rgx": {
        "type": "any",
        "isStatic": false
      },
      "match": {
        "type": "any",
        "isStatic": false
      },
      "command": {
        "type": "any",
        "isStatic": false
      },
      "amount": {
        "type": "string",
        "isStatic": false
      },
      "n": {
        "type": "any",
        "isStatic": false
      },
      "_number": {
        "type": "any",
        "isStatic": false
      },
      "f": {
        "type": "any",
        "isStatic": false
      },
      "_faces": {
        "type": "any",
        "isStatic": false
      },
      "flavor": {
        "type": "any",
        "isStatic": false
      },
      "other": {
        "type": "typeof RollConfigurationDialog",
        "isStatic": false
      }
    },
    "D20Die": {
      "number": {
        "type": "number",
        "isStatic": false
      },
      "static CRITICAL_SUCCESS_TOTAL": {
        "type": "any",
        "isStatic": true
      },
      "static CRITICAL_FAILURE_TOTAL": {
        "type": "any",
        "isStatic": true
      },
      "faces": {
        "type": "number",
        "isStatic": false
      },
      "advantageMode": {
        "type": "any",
        "isStatic": false
      },
      "m": {
        "type": "any",
        "isStatic": false
      },
      "isAdvantage": {
        "type": "any",
        "isStatic": false
      },
      "flag": {
        "type": "string",
        "isStatic": false
      },
      "index": {
        "type": "number",
        "isStatic": false
      },
      "mod": {
        "type": "any",
        "isStatic": false
      }
    },
    "D20Roll": {
      "static ADV_MODE": {
        "type": "any",
        "isStatic": true
      },
      "static DefaultConfigurationDialog": {
        "type": "any",
        "isStatic": true
      },
      "formula": {
        "type": "any",
        "isStatic": false
      },
      "newRoll": {
        "type": "any",
        "isStatic": false
      },
      "keys": {
        "type": "any",
        "isStatic": false
      },
      "k": {
        "type": "any",
        "isStatic": false
      },
      "advantage": {
        "type": "any",
        "isStatic": false
      },
      "disadvantage": {
        "type": "any",
        "isStatic": false
      },
      "advantageMode": {
        "type": "any",
        "isStatic": false
      },
      "rtLabel": {
        "type": "any",
        "isStatic": false
      },
      "r": {
        "type": "any",
        "isStatic": false
      },
      "minimum": {
        "type": "any",
        "isStatic": false
      },
      "elvenAccuracy": {
        "type": "boolean",
        "isStatic": false
      },
      "halflingLucky": {
        "type": "boolean",
        "isStatic": false
      },
      "criticalSuccess": {
        "type": "any",
        "isStatic": false
      },
      "criticalFailure": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "configured": {
        "type": "any",
        "isStatic": false
      },
      "defaultAction": {
        "type": "any",
        "isStatic": false
      },
      "DialogClass": {
        "type": "any",
        "isStatic": false
      },
      "defaultButton": {
        "type": "any",
        "isStatic": false
      }
    },
    "DamageRoll": {
      "static DefaultConfigurationDialog": {
        "type": "any",
        "isStatic": true
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "critical": {
        "type": "any",
        "isStatic": false
      },
      "keys": {
        "type": "any",
        "isStatic": false
      },
      "k": {
        "type": "any",
        "isStatic": false
      },
      "isCritical": {
        "type": "boolean",
        "isStatic": false
      },
      "nextTerm": {
        "type": "any",
        "isStatic": false
      },
      "prevTerm": {
        "type": "any",
        "isStatic": false
      },
      "formula": {
        "type": "any",
        "isStatic": false
      },
      "newTerm": {
        "type": "any",
        "isStatic": false
      },
      "term": {
        "type": "any",
        "isStatic": false
      },
      "newFormula": {
        "type": "any",
        "isStatic": false
      },
      "deleteCount": {
        "type": "any",
        "isStatic": false
      },
      "preprocessed": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "flatBonus": {
        "type": "any",
        "isStatic": false
      },
      "baseNumber": {
        "type": "any",
        "isStatic": false
      },
      "number": {
        "type": "any",
        "isStatic": false
      },
      "cm": {
        "type": "any",
        "isStatic": false
      },
      "bonus": {
        "type": "any",
        "isStatic": false
      },
      "flavor": {
        "type": "any",
        "isStatic": false
      },
      "cb": {
        "type": "number",
        "isStatic": false
      },
      "extra": {
        "type": "any",
        "isStatic": false
      },
      "configured": {
        "type": "any",
        "isStatic": false
      },
      "allowCritical": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "DialogClass": {
        "type": "any",
        "isStatic": false
      },
      "r": {
        "type": "any",
        "isStatic": false
      }
    },
    "ActiveEffect5e": {
      "static ID": {
        "type": "any",
        "isStatic": true
      },
      "static FORMULA_FIELDS": {
        "type": "any",
        "isStatic": true
      },
      "static LOCALIZATION_PREFIXES": {
        "type": "any",
        "isStatic": true
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "id": {
        "type": "this",
        "isStatic": false
      },
      "isSuppressed": {
        "type": "any",
        "isStatic": false
      },
      "description": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "change": {
        "type": "any",
        "isStatic": false
      },
      "field": {
        "type": "any",
        "isStatic": false
      },
      "changes": {
        "type": "Record<string, string>",
        "isStatic": false
      },
      "apply": {
        "type": "any",
        "isStatic": false
      },
      "activity": {
        "type": "any",
        "isStatic": false
      },
      "current": {
        "type": "any",
        "isStatic": false
      },
      "modes": {
        "type": "any",
        "isStatic": false
      },
      "mode": {
        "type": "any",
        "isStatic": false
      },
      "mappingField": {
        "type": "any",
        "isStatic": false
      },
      "keyPath": {
        "type": "any",
        "isStatic": false
      },
      "created": {
        "type": "any",
        "isStatic": false
      },
      "handle": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "initialValue": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "any",
        "isStatic": false
      },
      "img": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "s": {
        "type": "any",
        "isStatic": false
      },
      "riders": {
        "type": "Record<string, string>",
        "isStatic": false
      },
      "r": {
        "type": "any",
        "isStatic": false
      },
      "createRider": {
        "type": "any",
        "isStatic": false
      },
      "effect": {
        "type": "any",
        "isStatic": false
      },
      "effectData": {
        "type": "any",
        "isStatic": false
      },
      "_": {
        "type": "any",
        "isStatic": false
      },
      "message": {
        "type": "any",
        "isStatic": false
      },
      "profile": {
        "type": "any",
        "isStatic": false
      },
      "origin": {
        "type": "any",
        "isStatic": false
      },
      "riderActivities": {
        "type": "any",
        "isStatic": false
      },
      "riderEffects": {
        "type": "any",
        "isStatic": false
      },
      "activityData": {
        "type": "any",
        "isStatic": false
      },
      "_id": {
        "type": "any",
        "isStatic": false
      },
      "createdActivities": {
        "type": "any",
        "isStatic": false
      },
      "a": {
        "type": "any",
        "isStatic": false
      },
      "createdEffects": {
        "type": "any",
        "isStatic": false
      },
      "createdItems": {
        "type": "any",
        "isStatic": false
      },
      "riderItems": {
        "type": "any",
        "isStatic": false
      },
      "activityId": {
        "type": "any",
        "isStatic": false
      },
      "keepOrigin": {
        "type": "boolean",
        "isStatic": false
      },
      "errors": {
        "type": "any",
        "isStatic": false
      },
      "err": {
        "type": "any",
        "isStatic": false
      },
      "userId": {
        "type": "any",
        "isStatic": false
      },
      "originalLevel": {
        "type": "any",
        "isStatic": false
      },
      "newLevel": {
        "type": "any",
        "isStatic": false
      },
      "originalEncumbrance": {
        "type": "any",
        "isStatic": false
      },
      "newEncumbrance": {
        "type": "any",
        "isStatic": false
      },
      "increase": {
        "type": "string",
        "isStatic": false
      },
      "dependents": {
        "type": "any",
        "isStatic": false
      },
      "user": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "statusEffect": {
        "type": "any",
        "isStatic": false
      },
      "html": {
        "type": "any",
        "isStatic": false
      },
      "element": {
        "type": "any",
        "isStatic": false
      },
      "tab": {
        "type": "any",
        "isStatic": false
      },
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "elem": {
        "type": "any",
        "isStatic": false
      },
      "objectPosition": {
        "type": "any",
        "isStatic": false
      },
      "background": {
        "type": "any",
        "isStatic": false
      },
      "split": {
        "type": "any",
        "isStatic": false
      },
      "ext": {
        "type": "any",
        "isStatic": false
      },
      "path": {
        "type": "any",
        "isStatic": false
      },
      "button": {
        "type": "number",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "size": {
        "type": "number",
        "isStatic": false
      },
      "choices": {
        "type": "any",
        "isStatic": false
      },
      "content": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "d": {
        "type": "any",
        "isStatic": false
      },
      "delta": {
        "type": "any",
        "isStatic": false
      },
      "enrichmentOptions": {
        "type": "any[]",
        "isStatic": false
      },
      "p": {
        "type": "any",
        "isStatic": false
      },
      "dialogOptions": {
        "type": "any",
        "isStatic": false
      }
    },
    "SourcedItemsMap": {
      "remap": {
        "type": "any",
        "isStatic": false
      }
    },
    "Bastion": {
      "static ATTACK_TEMPLATE": {
        "type": "any",
        "isStatic": true
      },
      "static TURN_TEMPLATE": {
        "type": "any",
        "isStatic": true
      },
      "haveBastions": {
        "type": "string",
        "isStatic": false
      },
      "duration": {
        "type": "number",
        "isStatic": false
      },
      "order": {
        "type": "string",
        "isStatic": false
      },
      "gold": {
        "type": "any",
        "isStatic": false
      },
      "content": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "string",
        "isStatic": false
      },
      "newProgress": {
        "type": "any",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "summary": {
        "type": "number",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "deaths": {
        "type": "any",
        "isStatic": false
      },
      "defenders": {
        "type": "any",
        "isStatic": false
      },
      "undefended": {
        "type": "any",
        "isStatic": false
      },
      "event": {
        "type": "any",
        "isStatic": false
      },
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "el": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "draggable": {
        "type": "any",
        "isStatic": false
      },
      "sizes": {
        "type": "any",
        "isStatic": false
      },
      "index": {
        "type": "any",
        "isStatic": false
      },
      "operation": {
        "type": "boolean",
        "isStatic": false
      },
      "sold": {
        "type": "any",
        "isStatic": false
      },
      "allDefenders": {
        "type": "any",
        "isStatic": false
      },
      "results": {
        "type": "any",
        "isStatic": false
      },
      "gp": {
        "type": "any",
        "isStatic": false
      },
      "claimed": {
        "type": "any",
        "isStatic": false
      },
      "slain": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "a": {
        "type": "any",
        "isStatic": false
      },
      "special": {
        "type": "string",
        "isStatic": false
      },
      "damaged": {
        "type": "any",
        "isStatic": false
      },
      "resolved": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "plurals": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      },
      "description": {
        "type": "any",
        "isStatic": false
      },
      "buttons": {
        "type": "any",
        "isStatic": false
      },
      "class": {
        "type": "any",
        "isStatic": false
      },
      "facility": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "_": {
        "type": "any",
        "isStatic": false
      },
      "orders": {
        "type": "any",
        "isStatic": false
      },
      "supplements": {
        "type": "any",
        "isStatic": false
      },
      "proceed": {
        "type": "any",
        "isStatic": false
      },
      "turnButton": {
        "type": "any",
        "isStatic": false
      },
      "v12": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "formula": {
        "type": "any",
        "isStatic": false
      }
    },
    "BastionAttackDialog": {
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "static DEFAULT_OPTIONS": {
        "type": "any",
        "isStatic": true
      },
      "static PARTS": {
        "type": "any",
        "isStatic": true
      },
      "formula": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "resolve": {
        "type": "any",
        "isStatic": false
      }
    },
    "HitDice": {
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "max": {
        "type": "any",
        "isStatic": false
      },
      "sizes": {
        "type": "any",
        "isStatic": false
      },
      "classes": {
        "type": "any",
        "isStatic": false
      },
      "bySize": {
        "type": "any",
        "isStatic": false
      },
      "hd": {
        "type": "any",
        "isStatic": false
      },
      "cls": {
        "type": "any",
        "isStatic": false
      },
      "fraction": {
        "type": "number",
        "isStatic": false
      },
      "updateItems": {
        "type": "any",
        "isStatic": false
      },
      "recovered": {
        "type": "any",
        "isStatic": false
      },
      "used": {
        "type": "any",
        "isStatic": false
      },
      "delta": {
        "type": "any",
        "isStatic": false
      }
    },
    "Proficiency": {
      "roundDown": {
        "type": "any",
        "isStatic": false
      },
      "multiplier": {
        "type": "any",
        "isStatic": false
      },
      "rounding": {
        "type": "any",
        "isStatic": false
      },
      "deterministic": {
        "type": "any",
        "isStatic": false
      },
      "roundMethod": {
        "type": "string",
        "isStatic": false
      },
      "_baseProficiency": {
        "type": "number",
        "isStatic": false
      },
      "roundTerm": {
        "type": "string",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      }
    },
    "SelectChoices": {
      "choices": {
        "type": "any",
        "isStatic": false
      },
      "category": {
        "type": "any",
        "isStatic": false
      },
      "children": {
        "type": "any",
        "isStatic": false
      },
      "newData": {
        "type": "Set<string>",
        "isStatic": false
      },
      "clone": {
        "type": "any",
        "isStatic": false
      },
      "k": {
        "type": "any",
        "isStatic": false
      },
      "result": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "this",
        "isStatic": false
      },
      "sorting": {
        "type": "boolean",
        "isStatic": false
      },
      "inplace": {
        "type": "this",
        "isStatic": false
      },
      "filter": {
        "type": "any",
        "isStatic": false
      },
      "wildcardKey": {
        "type": "any",
        "isStatic": false
      }
    },
    "AbilityScoreImprovementAdvancement": {
      "type": {
        "type": "string",
        "isStatic": false
      },
      "configMode": {
        "type": "this",
        "isStatic": false
      },
      "entries": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "class": {
        "type": "any",
        "isStatic": false
      },
      "feat": {
        "type": "any",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "assignments": {
        "type": "any",
        "isStatic": false
      },
      "itemData": {
        "type": "any",
        "isStatic": false
      },
      "featUuid": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "retainedItems": {
        "type": "any",
        "isStatic": false
      }
    },
    "AdvancementError": {
      "name": {
        "type": "any",
        "isStatic": false
      }
    },
    "HitPointsAdvancement": {
      "type": {
        "type": "string",
        "isStatic": false
      },
      "configMode": {
        "type": "number",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "abilityId": {
        "type": "any",
        "isStatic": false
      },
      "level": {
        "type": "number",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemChoiceAdvancement": {
      "configMode": {
        "type": "any",
        "isStatic": false
      },
      "tag": {
        "type": "any",
        "isStatic": false
      },
      "retainedData": {
        "type": "any",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "replacedLevel": {
        "type": "any",
        "isStatic": false
      },
      "original": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "replaced": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "itemData": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "strict": {
        "type": "boolean",
        "isStatic": false
      },
      "subtype": {
        "type": "any",
        "isStatic": false
      },
      "errorLabel": {
        "type": "any",
        "isStatic": false
      },
      "l": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemGrantAdvancement": {
      "static VALID_TYPES": {
        "type": "any",
        "isStatic": true
      },
      "configMode": {
        "type": "Set<string>",
        "isStatic": false
      },
      "id": {
        "type": "any",
        "isStatic": false
      },
      "retainedData": {
        "type": "any[]",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "itemData": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "i": {
        "type": "boolean",
        "isStatic": false
      },
      "items": {
        "type": "Set<string>",
        "isStatic": false
      },
      "keyPath": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "strict": {
        "type": "boolean",
        "isStatic": false
      }
    },
    "ScaleValueAdvancement": {
      "static TYPES": {
        "type": "any",
        "isStatic": true
      },
      "v": {
        "type": "any",
        "isStatic": false
      },
      "l": {
        "type": "number",
        "isStatic": false
      },
      "configMode": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "TypeClass": {
        "type": "any",
        "isStatic": false
      },
      "keys": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "class": {
        "type": "any",
        "isStatic": false
      }
    },
    "SizeAdvancement": {
      "size": {
        "type": "number",
        "isStatic": false
      },
      "listFormatter": {
        "type": "any",
        "isStatic": false
      },
      "s": {
        "type": "any",
        "isStatic": false
      },
      "configMode": {
        "type": "any",
        "isStatic": false
      }
    },
    "SubclassAdvancement": {
      "configMode": {
        "type": "any",
        "isStatic": false
      },
      "useRetained": {
        "type": "any",
        "isStatic": false
      },
      "itemData": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      }
    },
    "TraitAdvancement": {
      "rep": {
        "type": "any",
        "isStatic": false
      },
      "traitConfig": {
        "type": "number",
        "isStatic": false
      },
      "title": {
        "type": "any",
        "isStatic": false
      },
      "icon": {
        "type": "any",
        "isStatic": false
      },
      "traitOrder": {
        "type": "number",
        "isStatic": false
      },
      "modeOrder": {
        "type": "any",
        "isStatic": false
      },
      "order": {
        "type": "any",
        "isStatic": false
      },
      "configMode": {
        "type": "any",
        "isStatic": false
      },
      "k": {
        "type": "any",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "keyPath": {
        "type": "string",
        "isStatic": false
      },
      "existingValue": {
        "type": "any",
        "isStatic": false
      },
      "mode": {
        "type": "string",
        "isStatic": false
      },
      "toolId": {
        "type": "any",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "kp": {
        "type": "any",
        "isStatic": false
      },
      "retainedData": {
        "type": "any",
        "isStatic": false
      },
      "selected": {
        "type": "any",
        "isStatic": false
      },
      "available": {
        "type": "any",
        "isStatic": false
      },
      "traitTypes": {
        "type": "string",
        "isStatic": false
      },
      "actorValues": {
        "type": "any",
        "isStatic": false
      },
      "choices": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "category": {
        "type": "any",
        "isStatic": false
      },
      "set": {
        "type": "any",
        "isStatic": false
      },
      "c": {
        "type": "any",
        "isStatic": false
      },
      "unfilteredLength": {
        "type": "any",
        "isStatic": false
      },
      "size": {
        "type": "number",
        "isStatic": false
      },
      "remainingSet": {
        "type": "any",
        "isStatic": false
      },
      "actorData": {
        "type": "any",
        "isStatic": false
      },
      "grant": {
        "type": "any",
        "isStatic": false
      },
      "allChoices": {
        "type": "any",
        "isStatic": false
      },
      "a": {
        "type": "any",
        "isStatic": false
      }
    },
    "ChatMessage5e": {
      "static TRAY_TYPES": {
        "type": "any",
        "isStatic": true
      },
      "_highlighted": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "author": {
        "type": "boolean",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "use": {
        "type": "any",
        "isStatic": false
      },
      "itemData": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "element": {
        "type": "any",
        "isStatic": false
      },
      "collapse": {
        "type": "any",
        "isStatic": false
      },
      "chatCard": {
        "type": "any",
        "isStatic": false
      },
      "flavor": {
        "type": "any",
        "isStatic": false
      },
      "displayChallenge": {
        "type": "any",
        "isStatic": false
      },
      "actor": {
        "type": "any",
        "isStatic": false
      },
      "isCreator": {
        "type": "any",
        "isStatic": false
      },
      "visibility": {
        "type": "string",
        "isStatic": false
      },
      "originatingMessage": {
        "type": "any",
        "isStatic": false
      },
      "displayAttackResult": {
        "type": "string",
        "isStatic": false
      },
      "forceSuccess": {
        "type": "boolean",
        "isStatic": false
      },
      "icon": {
        "type": "string[]",
        "isStatic": false
      },
      "d0": {
        "type": "any",
        "isStatic": false
      },
      "d20Roll": {
        "type": "any",
        "isStatic": false
      },
      "d": {
        "type": "any",
        "isStatic": false
      },
      "isModifiedRoll": {
        "type": "any",
        "isStatic": false
      },
      "total": {
        "type": "any",
        "isStatic": false
      },
      "canCrit": {
        "type": "any",
        "isStatic": false
      },
      "isAttack": {
        "type": "string",
        "isStatic": false
      },
      "showResult": {
        "type": "any",
        "isStatic": false
      },
      "icons": {
        "type": "any",
        "isStatic": false
      },
      "img": {
        "type": "any",
        "isStatic": false
      },
      "nameText": {
        "type": "any",
        "isStatic": false
      },
      "avatar": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "avatarImg": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "title": {
        "type": "any",
        "isStatic": false
      },
      "subtitle": {
        "type": "any",
        "isStatic": false
      },
      "innerText": {
        "type": "any",
        "isStatic": false
      },
      "sender": {
        "type": "any",
        "isStatic": false
      },
      "metadata": {
        "type": "any",
        "isStatic": false
      },
      "deleteButton": {
        "type": "any",
        "isStatic": false
      },
      "anchor": {
        "type": "any",
        "isStatic": false
      },
      "contextMenu": {
        "type": "any",
        "isStatic": false
      },
      "innerHTML": {
        "type": "any",
        "isStatic": false
      },
      "el": {
        "type": "any",
        "isStatic": false
      },
      "src": {
        "type": "any",
        "isStatic": false
      },
      "roll": {
        "type": "any",
        "isStatic": false
      },
      "item": {
        "type": "any",
        "isStatic": false
      },
      "activity": {
        "type": "any",
        "isStatic": false
      },
      "isCritical": {
        "type": "string",
        "isStatic": false
      },
      "r": {
        "type": "any",
        "isStatic": false
      },
      "constant": {
        "type": "any",
        "isStatic": false
      },
      "sign": {
        "type": "any",
        "isStatic": false
      },
      "part": {
        "type": "any",
        "isStatic": false
      },
      "attackRoll": {
        "type": "string[]",
        "isStatic": false
      },
      "masteryConfig": {
        "type": "any",
        "isStatic": false
      },
      "p": {
        "type": "any",
        "isStatic": false
      },
      "mastery": {
        "type": "any",
        "isStatic": false
      },
      "isVisible": {
        "type": "string",
        "isStatic": false
      },
      "targets": {
        "type": "any",
        "isStatic": false
      },
      "tray": {
        "type": "any",
        "isStatic": false
      },
      "evaluation": {
        "type": "any",
        "isStatic": false
      },
      "rows": {
        "type": "string",
        "isStatic": false
      },
      "isMiss": {
        "type": "any",
        "isStatic": false
      },
      "li": {
        "type": "any",
        "isStatic": false
      },
      "className": {
        "type": "any",
        "isStatic": false
      },
      "missA": {
        "type": "any",
        "isStatic": false
      },
      "missB": {
        "type": "any",
        "isStatic": false
      },
      "target": {
        "type": "any",
        "isStatic": false
      },
      "aggregatedRolls": {
        "type": "any",
        "isStatic": false
      },
      "formula": {
        "type": "any",
        "isStatic": false
      },
      "tooltipContents": {
        "type": "any",
        "isStatic": false
      },
      "class": {
        "type": "any",
        "isStatic": false
      },
      "damageOnSave": {
        "type": "any",
        "isStatic": false
      },
      "damageApplication": {
        "type": "any",
        "isStatic": false
      },
      "damages": {
        "type": "any",
        "isStatic": false
      },
      "aggregate": {
        "type": "string[]",
        "isStatic": false
      },
      "hasMultiplication": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "term": {
        "type": "any",
        "isStatic": false
      },
      "value": {
        "type": "any",
        "isStatic": false
      },
      "multiplier": {
        "type": "any",
        "isStatic": false
      },
      "operator": {
        "type": "any",
        "isStatic": false
      },
      "enchantmentProfile": {
        "type": "any",
        "isStatic": false
      },
      "concentrationId": {
        "type": "any",
        "isStatic": false
      },
      "enchantmentApplication": {
        "type": "any",
        "isStatic": false
      },
      "afterElement": {
        "type": "any",
        "isStatic": false
      },
      "content": {
        "type": "any",
        "isStatic": false
      },
      "button": {
        "type": "any",
        "isStatic": false
      },
      "effects": {
        "type": "any",
        "isStatic": false
      },
      "effectApplication": {
        "type": "any",
        "isStatic": false
      },
      "canApply": {
        "type": "any",
        "isStatic": false
      },
      "canTarget": {
        "type": "any",
        "isStatic": false
      },
      "token": {
        "type": "any",
        "isStatic": false
      },
      "releaseOthers": {
        "type": "any",
        "isStatic": false
      },
      "t": {
        "type": "any",
        "isStatic": false
      },
      "lis": {
        "type": "any",
        "isStatic": false
      },
      "uuids": {
        "type": "any",
        "isStatic": false
      },
      "tokens": {
        "type": "any",
        "isStatic": false
      },
      "html": {
        "type": "any",
        "isStatic": false
      },
      "close": {
        "type": "any",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      },
      "gmUser": {
        "type": "any",
        "isStatic": false
      },
      "releaseAll": {
        "type": "any",
        "isStatic": false
      },
      "chatlog": {
        "type": "string",
        "isStatic": false
      },
      "scene": {
        "type": "any",
        "isStatic": false
      },
      "storedData": {
        "type": "any",
        "isStatic": false
      },
      "flags": {
        "type": "any",
        "isStatic": false
      },
      "messageType": {
        "type": "string",
        "isStatic": false
      }
    },
    "Combat5e": {
      "expandedGroups": {
        "type": "any",
        "isStatic": false
      },
      "ids": {
        "type": "any",
        "isStatic": false
      },
      "combatant": {
        "type": "any",
        "isStatic": false
      },
      "initiative": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "groups": {
        "type": "any",
        "isStatic": false
      },
      "key": {
        "type": "any",
        "isStatic": false
      },
      "periods": {
        "type": "boolean",
        "isStatic": false
      }
    },
    "Combatant5e": {
      "data": {
        "type": "any",
        "isStatic": false
      },
      "create": {
        "type": "any",
        "isStatic": false
      },
      "initiative": {
        "type": "any",
        "isStatic": false
      },
      "results": {
        "type": "any",
        "isStatic": false
      },
      "rollData": {
        "type": "any",
        "isStatic": false
      },
      "updateTarget": {
        "type": "any",
        "isStatic": false
      },
      "deltas": {
        "type": "any",
        "isStatic": false
      },
      "message": {
        "type": "any",
        "isStatic": false
      },
      "updates": {
        "type": "any",
        "isStatic": false
      },
      "i": {
        "type": "any",
        "isStatic": false
      },
      "update": {
        "type": "any",
        "isStatic": false
      },
      "combatant": {
        "type": "any",
        "isStatic": false
      }
    },
    "JournalEntryPage5e": {},
    "SystemFlags": {
      "dnd5e": {
        "type": "any",
        "isStatic": false
      },
      "scope": {
        "type": "string",
        "isStatic": false
      },
      "changes": {
        "type": "any",
        "isStatic": false
      },
      "diff": {
        "type": "any",
        "isStatic": false
      }
    },
    "PseudoDocument": {
      "parent": {
        "type": "any",
        "isStatic": false
      },
      "static _apps": {
        "type": "any",
        "isStatic": true
      },
      "static _sheets": {
        "type": "any",
        "isStatic": true
      },
      "cls": {
        "type": "any",
        "isStatic": false
      },
      "sheet": {
        "type": "any",
        "isStatic": false
      },
      "options": {
        "type": "any",
        "isStatic": false
      },
      "dragData": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "title": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "content": {
        "type": "any",
        "isStatic": false
      },
      "html": {
        "type": "any",
        "isStatic": false
      },
      "folder": {
        "type": "any",
        "isStatic": false
      },
      "btn": {
        "type": "any",
        "isStatic": false
      },
      "icon": {
        "type": "any",
        "isStatic": false
      },
      "innerHTML": {
        "type": "any",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      },
      "fd": {
        "type": "any",
        "isStatic": false
      },
      "createData": {
        "type": "any",
        "isStatic": false
      }
    },
    "Scaling": {
      "increase": {
        "type": "any",
        "isStatic": false
      }
    },
    "ModuleArt": {
      "suppressArt": {
        "type": "any",
        "isStatic": false
      },
      "json": {
        "type": "any",
        "isStatic": false
      },
      "settings": {
        "type": "any",
        "isStatic": false
      },
      "pack": {
        "type": "any",
        "isStatic": false
      },
      "entry": {
        "type": "any",
        "isStatic": false
      },
      "img": {
        "type": "any",
        "isStatic": false
      },
      "credit": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      },
      "info": {
        "type": "any",
        "isStatic": false
      },
      "flags": {
        "type": "any",
        "isStatic": false
      },
      "artPath": {
        "type": "any",
        "isStatic": false
      },
      "unsorted": {
        "type": "any",
        "isStatic": false
      },
      "configs": {
        "type": "any",
        "isStatic": false
      },
      "mapping": {
        "type": "any",
        "isStatic": false
      },
      "config": {
        "type": "any",
        "isStatic": false
      },
      "priority": {
        "type": "any",
        "isStatic": false
      },
      "maxPriority": {
        "type": "any",
        "isStatic": false
      }
    },
    "EnchantmentRegisty": {
      "appliedEnchantments": {
        "type": "any",
        "isStatic": false
      },
      "source": {
        "type": "any",
        "isStatic": false
      },
      "a": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      }
    },
    "ItemRegistry": {
      "itemType": {
        "type": "any",
        "isStatic": false
      },
      "items": {
        "type": "any",
        "isStatic": false
      },
      "status": {
        "type": "any",
        "isStatic": false
      },
      "STATUS_STATES": {
        "type": "any",
        "isStatic": false
      },
      "initialized": {
        "type": "boolean",
        "isStatic": false
      },
      "indexes": {
        "type": "any",
        "isStatic": false
      },
      "identifier": {
        "type": "any",
        "isStatic": false
      },
      "itemData": {
        "type": "any",
        "isStatic": false
      },
      "name": {
        "type": "any",
        "isStatic": false
      },
      "img": {
        "type": "any",
        "isStatic": false
      }
    },
    "MessageRegistry": {
      "messages": {
        "type": "any",
        "isStatic": false
      },
      "originMap": {
        "type": "any",
        "isStatic": false
      },
      "ids": {
        "type": "any",
        "isStatic": false
      },
      "id": {
        "type": "any",
        "isStatic": false
      },
      "origin": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      }
    },
    "SpellListRegistry": {
      "bySpell": {
        "type": "any",
        "isStatic": false
      },
      "byType": {
        "type": "any",
        "isStatic": false
      },
      "loading": {
        "type": "any",
        "isStatic": false
      },
      "lists": {
        "type": "any",
        "isStatic": false
      },
      "size": {
        "type": "number",
        "isStatic": false
      },
      "page": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "any",
        "isStatic": false
      },
      "list": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      }
    },
    "SpellList": {
      "metadata": {
        "type": "any",
        "isStatic": false
      },
      "REGISTRIES": {
        "type": "any",
        "isStatic": false
      },
      "s": {
        "type": "any",
        "isStatic": false
      },
      "spells": {
        "type": "any",
        "isStatic": false
      },
      "unlinked": {
        "type": "any",
        "isStatic": false
      },
      "added": {
        "type": "any",
        "isStatic": false
      }
    },
    "SummonRegistry": {
      "creatures": {
        "type": "any",
        "isStatic": false
      },
      "uuid": {
        "type": "any",
        "isStatic": false
      }
    },
    "Tooltips5e": {
      "observer": {
        "type": "any",
        "isStatic": false
      },
      "isActive": {
        "type": "any",
        "isStatic": false
      },
      "tooltip": {
        "type": "any",
        "isStatic": false
      },
      "type": {
        "type": "string",
        "isStatic": false
      },
      "doc": {
        "type": "any",
        "isStatic": false
      },
      "loading": {
        "type": "any",
        "isStatic": false
      },
      "innerHTML": {
        "type": "any",
        "isStatic": false
      },
      "c": {
        "type": "any",
        "isStatic": false
      },
      "skillConfig": {
        "type": "any",
        "isStatic": false
      },
      "abilityConfig": {
        "type": "any",
        "isStatic": false
      },
      "label": {
        "type": "any",
        "isStatic": false
      },
      "party": {
        "type": "any",
        "isStatic": false
      },
      "context": {
        "type": "any",
        "isStatic": false
      },
      "systemData": {
        "type": "any",
        "isStatic": false
      },
      "ability": {
        "type": "any",
        "isStatic": false
      },
      "customSkillData": {
        "type": "any",
        "isStatic": false
      },
      "passive": {
        "type": "any",
        "isStatic": false
      },
      "abilityMod": {
        "type": "any",
        "isStatic": false
      },
      "data": {
        "type": "any",
        "isStatic": false
      },
      "status": {
        "type": "any",
        "isStatic": false
      },
      "direction": {
        "type": "any",
        "isStatic": false
      },
      "pos": {
        "type": "any",
        "isStatic": false
      },
      "dirs": {
        "type": "any",
        "isStatic": false
      },
      "description": {
        "type": "any",
        "isStatic": false
      },
      "event": {
        "type": "number",
        "isStatic": false
      }
    }
  },
  "configs": {},
  "hooks": [],
  "constants": {
    "PACK_DEST": {
      "value": "packs",
      "file": "utils\\packs.mjs"
    },
    "PACK_SRC": {
      "value": "packs/_source",
      "file": "utils\\packs.mjs"
    }
  }
}